// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	auditpb "go-wind-admin/api/gen/go/audit/service/v1"
	servicev1 "go-wind-admin/api/gen/go/identity/service/v1"
	resourcepb "go-wind-admin/api/gen/go/resource/service/v1"
	taskpb "go-wind-admin/api/gen/go/task/service/v1"
	"go-wind-admin/app/admin/service/internal/data/ent/api"
	"go-wind-admin/app/admin/service/internal/data/ent/apiauditlog"
	"go-wind-admin/app/admin/service/internal/data/ent/dataaccessauditlog"
	"go-wind-admin/app/admin/service/internal/data/ent/dictentry"
	"go-wind-admin/app/admin/service/internal/data/ent/dictentryi18n"
	"go-wind-admin/app/admin/service/internal/data/ent/dicttype"
	"go-wind-admin/app/admin/service/internal/data/ent/dicttypei18n"
	"go-wind-admin/app/admin/service/internal/data/ent/file"
	"go-wind-admin/app/admin/service/internal/data/ent/internalmessage"
	"go-wind-admin/app/admin/service/internal/data/ent/internalmessagecategory"
	"go-wind-admin/app/admin/service/internal/data/ent/internalmessagerecipient"
	"go-wind-admin/app/admin/service/internal/data/ent/language"
	"go-wind-admin/app/admin/service/internal/data/ent/loginauditlog"
	"go-wind-admin/app/admin/service/internal/data/ent/loginpolicy"
	"go-wind-admin/app/admin/service/internal/data/ent/membership"
	"go-wind-admin/app/admin/service/internal/data/ent/membershiporgunit"
	"go-wind-admin/app/admin/service/internal/data/ent/membershipposition"
	"go-wind-admin/app/admin/service/internal/data/ent/membershiprole"
	"go-wind-admin/app/admin/service/internal/data/ent/menu"
	"go-wind-admin/app/admin/service/internal/data/ent/operationauditlog"
	"go-wind-admin/app/admin/service/internal/data/ent/orgunit"
	"go-wind-admin/app/admin/service/internal/data/ent/permission"
	"go-wind-admin/app/admin/service/internal/data/ent/permissionapi"
	"go-wind-admin/app/admin/service/internal/data/ent/permissionauditlog"
	"go-wind-admin/app/admin/service/internal/data/ent/permissiongroup"
	"go-wind-admin/app/admin/service/internal/data/ent/permissionmenu"
	"go-wind-admin/app/admin/service/internal/data/ent/permissionpolicy"
	"go-wind-admin/app/admin/service/internal/data/ent/policyevaluationlog"
	"go-wind-admin/app/admin/service/internal/data/ent/position"
	"go-wind-admin/app/admin/service/internal/data/ent/predicate"
	"go-wind-admin/app/admin/service/internal/data/ent/role"
	"go-wind-admin/app/admin/service/internal/data/ent/rolemetadata"
	"go-wind-admin/app/admin/service/internal/data/ent/rolepermission"
	"go-wind-admin/app/admin/service/internal/data/ent/task"
	"go-wind-admin/app/admin/service/internal/data/ent/tenant"
	"go-wind-admin/app/admin/service/internal/data/ent/user"
	"go-wind-admin/app/admin/service/internal/data/ent/usercredential"
	"go-wind-admin/app/admin/service/internal/data/ent/userorgunit"
	"go-wind-admin/app/admin/service/internal/data/ent/userposition"
	"go-wind-admin/app/admin/service/internal/data/ent/userrole"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI                      = "Api"
	TypeApiAuditLog              = "ApiAuditLog"
	TypeDataAccessAuditLog       = "DataAccessAuditLog"
	TypeDictEntry                = "DictEntry"
	TypeDictEntryI18n            = "DictEntryI18n"
	TypeDictType                 = "DictType"
	TypeDictTypeI18n             = "DictTypeI18n"
	TypeFile                     = "File"
	TypeInternalMessage          = "InternalMessage"
	TypeInternalMessageCategory  = "InternalMessageCategory"
	TypeInternalMessageRecipient = "InternalMessageRecipient"
	TypeLanguage                 = "Language"
	TypeLoginAuditLog            = "LoginAuditLog"
	TypeLoginPolicy              = "LoginPolicy"
	TypeMembership               = "Membership"
	TypeMembershipOrgUnit        = "MembershipOrgUnit"
	TypeMembershipPosition       = "MembershipPosition"
	TypeMembershipRole           = "MembershipRole"
	TypeMenu                     = "Menu"
	TypeOperationAuditLog        = "OperationAuditLog"
	TypeOrgUnit                  = "OrgUnit"
	TypePermission               = "Permission"
	TypePermissionApi            = "PermissionApi"
	TypePermissionAuditLog       = "PermissionAuditLog"
	TypePermissionGroup          = "PermissionGroup"
	TypePermissionMenu           = "PermissionMenu"
	TypePermissionPolicy         = "PermissionPolicy"
	TypePolicyEvaluationLog      = "PolicyEvaluationLog"
	TypePosition                 = "Position"
	TypeRole                     = "Role"
	TypeRoleMetadata             = "RoleMetadata"
	TypeRolePermission           = "RolePermission"
	TypeTask                     = "Task"
	TypeTenant                   = "Tenant"
	TypeUser                     = "User"
	TypeUserCredential           = "UserCredential"
	TypeUserOrgUnit              = "UserOrgUnit"
	TypeUserPosition             = "UserPosition"
	TypeUserRole                 = "UserRole"
)

// APIMutation represents an operation that mutates the Api nodes in the graph.
type APIMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	created_by         *uint32
	addcreated_by      *int32
	updated_by         *uint32
	addupdated_by      *int32
	deleted_by         *uint32
	adddeleted_by      *int32
	status             *api.Status
	description        *string
	module             *string
	module_description *string
	operation          *string
	_path              *string
	method             *string
	scope              *api.Scope
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Api, error)
	predicates         []predicate.Api
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the Api entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiID sets the ID field of the mutation.
func withApiID(id uint32) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *Api
		)
		m.oldValue = func(ctx context.Context) (*Api, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Api.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApi sets the old Api of the mutation.
func withApi(node *Api) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*Api, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Api entities.
func (m *APIMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Api.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *APIMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[api.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *APIMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, api.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *APIMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[api.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *APIMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, api.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *APIMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[api.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *APIMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, api.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *APIMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *APIMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *APIMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *APIMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *APIMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[api.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *APIMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *APIMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, api.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *APIMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *APIMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *APIMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *APIMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *APIMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[api.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *APIMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *APIMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, api.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *APIMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *APIMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *APIMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *APIMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *APIMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[api.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *APIMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[api.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *APIMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, api.FieldDeletedBy)
}

// SetStatus sets the "status" field.
func (m *APIMutation) SetStatus(a api.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *APIMutation) Status() (r api.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldStatus(ctx context.Context) (v *api.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *APIMutation) ResetStatus() {
	m.status = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *APIMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[api.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *APIMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[api.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, api.FieldDescription)
}

// SetModule sets the "module" field.
func (m *APIMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *APIMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldModule(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ClearModule clears the value of the "module" field.
func (m *APIMutation) ClearModule() {
	m.module = nil
	m.clearedFields[api.FieldModule] = struct{}{}
}

// ModuleCleared returns if the "module" field was cleared in this mutation.
func (m *APIMutation) ModuleCleared() bool {
	_, ok := m.clearedFields[api.FieldModule]
	return ok
}

// ResetModule resets all changes to the "module" field.
func (m *APIMutation) ResetModule() {
	m.module = nil
	delete(m.clearedFields, api.FieldModule)
}

// SetModuleDescription sets the "module_description" field.
func (m *APIMutation) SetModuleDescription(s string) {
	m.module_description = &s
}

// ModuleDescription returns the value of the "module_description" field in the mutation.
func (m *APIMutation) ModuleDescription() (r string, exists bool) {
	v := m.module_description
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleDescription returns the old "module_description" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldModuleDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleDescription: %w", err)
	}
	return oldValue.ModuleDescription, nil
}

// ClearModuleDescription clears the value of the "module_description" field.
func (m *APIMutation) ClearModuleDescription() {
	m.module_description = nil
	m.clearedFields[api.FieldModuleDescription] = struct{}{}
}

// ModuleDescriptionCleared returns if the "module_description" field was cleared in this mutation.
func (m *APIMutation) ModuleDescriptionCleared() bool {
	_, ok := m.clearedFields[api.FieldModuleDescription]
	return ok
}

// ResetModuleDescription resets all changes to the "module_description" field.
func (m *APIMutation) ResetModuleDescription() {
	m.module_description = nil
	delete(m.clearedFields, api.FieldModuleDescription)
}

// SetOperation sets the "operation" field.
func (m *APIMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *APIMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldOperation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ClearOperation clears the value of the "operation" field.
func (m *APIMutation) ClearOperation() {
	m.operation = nil
	m.clearedFields[api.FieldOperation] = struct{}{}
}

// OperationCleared returns if the "operation" field was cleared in this mutation.
func (m *APIMutation) OperationCleared() bool {
	_, ok := m.clearedFields[api.FieldOperation]
	return ok
}

// ResetOperation resets all changes to the "operation" field.
func (m *APIMutation) ResetOperation() {
	m.operation = nil
	delete(m.clearedFields, api.FieldOperation)
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *APIMutation) ClearPath() {
	m._path = nil
	m.clearedFields[api.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *APIMutation) PathCleared() bool {
	_, ok := m.clearedFields[api.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, api.FieldPath)
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *APIMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[api.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *APIMutation) MethodCleared() bool {
	_, ok := m.clearedFields[api.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, api.FieldMethod)
}

// SetScope sets the "scope" field.
func (m *APIMutation) SetScope(a api.Scope) {
	m.scope = &a
}

// Scope returns the value of the "scope" field in the mutation.
func (m *APIMutation) Scope() (r api.Scope, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldScope(ctx context.Context) (v *api.Scope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ClearScope clears the value of the "scope" field.
func (m *APIMutation) ClearScope() {
	m.scope = nil
	m.clearedFields[api.FieldScope] = struct{}{}
}

// ScopeCleared returns if the "scope" field was cleared in this mutation.
func (m *APIMutation) ScopeCleared() bool {
	_, ok := m.clearedFields[api.FieldScope]
	return ok
}

// ResetScope resets all changes to the "scope" field.
func (m *APIMutation) ResetScope() {
	m.scope = nil
	delete(m.clearedFields, api.FieldScope)
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.Api) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Api, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Api).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, api.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, api.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, api.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, api.FieldDeletedBy)
	}
	if m.status != nil {
		fields = append(fields, api.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.module != nil {
		fields = append(fields, api.FieldModule)
	}
	if m.module_description != nil {
		fields = append(fields, api.FieldModuleDescription)
	}
	if m.operation != nil {
		fields = append(fields, api.FieldOperation)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	if m.scope != nil {
		fields = append(fields, api.FieldScope)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldDeletedAt:
		return m.DeletedAt()
	case api.FieldCreatedBy:
		return m.CreatedBy()
	case api.FieldUpdatedBy:
		return m.UpdatedBy()
	case api.FieldDeletedBy:
		return m.DeletedBy()
	case api.FieldStatus:
		return m.Status()
	case api.FieldDescription:
		return m.Description()
	case api.FieldModule:
		return m.Module()
	case api.FieldModuleDescription:
		return m.ModuleDescription()
	case api.FieldOperation:
		return m.Operation()
	case api.FieldPath:
		return m.Path()
	case api.FieldMethod:
		return m.Method()
	case api.FieldScope:
		return m.Scope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case api.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case api.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case api.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case api.FieldStatus:
		return m.OldStatus(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldModule:
		return m.OldModule(ctx)
	case api.FieldModuleDescription:
		return m.OldModuleDescription(ctx)
	case api.FieldOperation:
		return m.OldOperation(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	case api.FieldScope:
		return m.OldScope(ctx)
	}
	return nil, fmt.Errorf("unknown Api field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case api.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case api.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case api.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case api.FieldStatus:
		v, ok := value.(api.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case api.FieldModuleDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleDescription(v)
		return nil
	case api.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case api.FieldScope:
		v, ok := value.(api.Scope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	}
	return fmt.Errorf("unknown Api field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, api.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, api.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, api.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedBy:
		return m.AddedCreatedBy()
	case api.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case api.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case api.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case api.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Api numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldCreatedAt) {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.FieldCleared(api.FieldUpdatedAt) {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.FieldCleared(api.FieldDeletedAt) {
		fields = append(fields, api.FieldDeletedAt)
	}
	if m.FieldCleared(api.FieldCreatedBy) {
		fields = append(fields, api.FieldCreatedBy)
	}
	if m.FieldCleared(api.FieldUpdatedBy) {
		fields = append(fields, api.FieldUpdatedBy)
	}
	if m.FieldCleared(api.FieldDeletedBy) {
		fields = append(fields, api.FieldDeletedBy)
	}
	if m.FieldCleared(api.FieldDescription) {
		fields = append(fields, api.FieldDescription)
	}
	if m.FieldCleared(api.FieldModule) {
		fields = append(fields, api.FieldModule)
	}
	if m.FieldCleared(api.FieldModuleDescription) {
		fields = append(fields, api.FieldModuleDescription)
	}
	if m.FieldCleared(api.FieldOperation) {
		fields = append(fields, api.FieldOperation)
	}
	if m.FieldCleared(api.FieldPath) {
		fields = append(fields, api.FieldPath)
	}
	if m.FieldCleared(api.FieldMethod) {
		fields = append(fields, api.FieldMethod)
	}
	if m.FieldCleared(api.FieldScope) {
		fields = append(fields, api.FieldScope)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case api.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case api.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case api.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case api.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case api.FieldDescription:
		m.ClearDescription()
		return nil
	case api.FieldModule:
		m.ClearModule()
		return nil
	case api.FieldModuleDescription:
		m.ClearModuleDescription()
		return nil
	case api.FieldOperation:
		m.ClearOperation()
		return nil
	case api.FieldPath:
		m.ClearPath()
		return nil
	case api.FieldMethod:
		m.ClearMethod()
		return nil
	case api.FieldScope:
		m.ClearScope()
		return nil
	}
	return fmt.Errorf("unknown Api nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case api.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case api.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case api.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case api.FieldStatus:
		m.ResetStatus()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldModule:
		m.ResetModule()
		return nil
	case api.FieldModuleDescription:
		m.ResetModuleDescription()
		return nil
	case api.FieldOperation:
		m.ResetOperation()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	case api.FieldScope:
		m.ResetScope()
		return nil
	}
	return fmt.Errorf("unknown Api field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Api unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Api edge %s", name)
}

// ApiAuditLogMutation represents an operation that mutates the ApiAuditLog nodes in the graph.
type ApiAuditLogMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	tenant_id       *uint32
	addtenant_id    *int32
	user_id         *uint32
	adduser_id      *int32
	username        *string
	ip_address      *string
	geo_location    **auditpb.GeoLocation
	device_info     **auditpb.DeviceInfo
	referer         *string
	app_version     *string
	http_method     *string
	_path           *string
	request_uri     *string
	api_module      *string
	api_operation   *string
	api_description *string
	request_id      *string
	trace_id        *string
	span_id         *string
	latency_ms      *uint32
	addlatency_ms   *int32
	success         *bool
	status_code     *uint32
	addstatus_code  *int32
	reason          *string
	request_header  *string
	request_body    *string
	response        *string
	log_hash        *string
	signature       *[]byte
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ApiAuditLog, error)
	predicates      []predicate.ApiAuditLog
}

var _ ent.Mutation = (*ApiAuditLogMutation)(nil)

// apiauditlogOption allows management of the mutation configuration using functional options.
type apiauditlogOption func(*ApiAuditLogMutation)

// newApiAuditLogMutation creates new mutation for the ApiAuditLog entity.
func newApiAuditLogMutation(c config, op Op, opts ...apiauditlogOption) *ApiAuditLogMutation {
	m := &ApiAuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeApiAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiAuditLogID sets the ID field of the mutation.
func withApiAuditLogID(id uint32) apiauditlogOption {
	return func(m *ApiAuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiAuditLog
		)
		m.oldValue = func(ctx context.Context) (*ApiAuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiAuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiAuditLog sets the old ApiAuditLog of the mutation.
func withApiAuditLog(node *ApiAuditLog) apiauditlogOption {
	return func(m *ApiAuditLogMutation) {
		m.oldValue = func(context.Context) (*ApiAuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiAuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiAuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiAuditLog entities.
func (m *ApiAuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiAuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiAuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiAuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiAuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiAuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ApiAuditLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[apiauditlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ApiAuditLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiAuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, apiauditlog.FieldCreatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *ApiAuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ApiAuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *ApiAuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ApiAuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ApiAuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[apiauditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ApiAuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ApiAuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, apiauditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *ApiAuditLogMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApiAuditLogMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *ApiAuditLogMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ApiAuditLogMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *ApiAuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[apiauditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ApiAuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApiAuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, apiauditlog.FieldUserID)
}

// SetUsername sets the "username" field.
func (m *ApiAuditLogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ApiAuditLogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ApiAuditLogMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[apiauditlog.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ApiAuditLogMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ApiAuditLogMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, apiauditlog.FieldUsername)
}

// SetIPAddress sets the "ip_address" field.
func (m *ApiAuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ApiAuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *ApiAuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[apiauditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *ApiAuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ApiAuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, apiauditlog.FieldIPAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *ApiAuditLogMutation) SetGeoLocation(al *auditpb.GeoLocation) {
	m.geo_location = &al
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *ApiAuditLogMutation) GeoLocation() (r *auditpb.GeoLocation, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldGeoLocation(ctx context.Context) (v *auditpb.GeoLocation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *ApiAuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[apiauditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *ApiAuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *ApiAuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, apiauditlog.FieldGeoLocation)
}

// SetDeviceInfo sets the "device_info" field.
func (m *ApiAuditLogMutation) SetDeviceInfo(ai *auditpb.DeviceInfo) {
	m.device_info = &ai
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *ApiAuditLogMutation) DeviceInfo() (r *auditpb.DeviceInfo, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldDeviceInfo(ctx context.Context) (v *auditpb.DeviceInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *ApiAuditLogMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[apiauditlog.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *ApiAuditLogMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *ApiAuditLogMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, apiauditlog.FieldDeviceInfo)
}

// SetReferer sets the "referer" field.
func (m *ApiAuditLogMutation) SetReferer(s string) {
	m.referer = &s
}

// Referer returns the value of the "referer" field in the mutation.
func (m *ApiAuditLogMutation) Referer() (r string, exists bool) {
	v := m.referer
	if v == nil {
		return
	}
	return *v, true
}

// OldReferer returns the old "referer" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldReferer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferer: %w", err)
	}
	return oldValue.Referer, nil
}

// ClearReferer clears the value of the "referer" field.
func (m *ApiAuditLogMutation) ClearReferer() {
	m.referer = nil
	m.clearedFields[apiauditlog.FieldReferer] = struct{}{}
}

// RefererCleared returns if the "referer" field was cleared in this mutation.
func (m *ApiAuditLogMutation) RefererCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldReferer]
	return ok
}

// ResetReferer resets all changes to the "referer" field.
func (m *ApiAuditLogMutation) ResetReferer() {
	m.referer = nil
	delete(m.clearedFields, apiauditlog.FieldReferer)
}

// SetAppVersion sets the "app_version" field.
func (m *ApiAuditLogMutation) SetAppVersion(s string) {
	m.app_version = &s
}

// AppVersion returns the value of the "app_version" field in the mutation.
func (m *ApiAuditLogMutation) AppVersion() (r string, exists bool) {
	v := m.app_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersion returns the old "app_version" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldAppVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersion: %w", err)
	}
	return oldValue.AppVersion, nil
}

// ClearAppVersion clears the value of the "app_version" field.
func (m *ApiAuditLogMutation) ClearAppVersion() {
	m.app_version = nil
	m.clearedFields[apiauditlog.FieldAppVersion] = struct{}{}
}

// AppVersionCleared returns if the "app_version" field was cleared in this mutation.
func (m *ApiAuditLogMutation) AppVersionCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldAppVersion]
	return ok
}

// ResetAppVersion resets all changes to the "app_version" field.
func (m *ApiAuditLogMutation) ResetAppVersion() {
	m.app_version = nil
	delete(m.clearedFields, apiauditlog.FieldAppVersion)
}

// SetHTTPMethod sets the "http_method" field.
func (m *ApiAuditLogMutation) SetHTTPMethod(s string) {
	m.http_method = &s
}

// HTTPMethod returns the value of the "http_method" field in the mutation.
func (m *ApiAuditLogMutation) HTTPMethod() (r string, exists bool) {
	v := m.http_method
	if v == nil {
		return
	}
	return *v, true
}

// OldHTTPMethod returns the old "http_method" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldHTTPMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTTPMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTTPMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTTPMethod: %w", err)
	}
	return oldValue.HTTPMethod, nil
}

// ClearHTTPMethod clears the value of the "http_method" field.
func (m *ApiAuditLogMutation) ClearHTTPMethod() {
	m.http_method = nil
	m.clearedFields[apiauditlog.FieldHTTPMethod] = struct{}{}
}

// HTTPMethodCleared returns if the "http_method" field was cleared in this mutation.
func (m *ApiAuditLogMutation) HTTPMethodCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldHTTPMethod]
	return ok
}

// ResetHTTPMethod resets all changes to the "http_method" field.
func (m *ApiAuditLogMutation) ResetHTTPMethod() {
	m.http_method = nil
	delete(m.clearedFields, apiauditlog.FieldHTTPMethod)
}

// SetPath sets the "path" field.
func (m *ApiAuditLogMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ApiAuditLogMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *ApiAuditLogMutation) ClearPath() {
	m._path = nil
	m.clearedFields[apiauditlog.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *ApiAuditLogMutation) PathCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *ApiAuditLogMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, apiauditlog.FieldPath)
}

// SetRequestURI sets the "request_uri" field.
func (m *ApiAuditLogMutation) SetRequestURI(s string) {
	m.request_uri = &s
}

// RequestURI returns the value of the "request_uri" field in the mutation.
func (m *ApiAuditLogMutation) RequestURI() (r string, exists bool) {
	v := m.request_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestURI returns the old "request_uri" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldRequestURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestURI: %w", err)
	}
	return oldValue.RequestURI, nil
}

// ClearRequestURI clears the value of the "request_uri" field.
func (m *ApiAuditLogMutation) ClearRequestURI() {
	m.request_uri = nil
	m.clearedFields[apiauditlog.FieldRequestURI] = struct{}{}
}

// RequestURICleared returns if the "request_uri" field was cleared in this mutation.
func (m *ApiAuditLogMutation) RequestURICleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldRequestURI]
	return ok
}

// ResetRequestURI resets all changes to the "request_uri" field.
func (m *ApiAuditLogMutation) ResetRequestURI() {
	m.request_uri = nil
	delete(m.clearedFields, apiauditlog.FieldRequestURI)
}

// SetAPIModule sets the "api_module" field.
func (m *ApiAuditLogMutation) SetAPIModule(s string) {
	m.api_module = &s
}

// APIModule returns the value of the "api_module" field in the mutation.
func (m *ApiAuditLogMutation) APIModule() (r string, exists bool) {
	v := m.api_module
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIModule returns the old "api_module" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldAPIModule(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIModule: %w", err)
	}
	return oldValue.APIModule, nil
}

// ClearAPIModule clears the value of the "api_module" field.
func (m *ApiAuditLogMutation) ClearAPIModule() {
	m.api_module = nil
	m.clearedFields[apiauditlog.FieldAPIModule] = struct{}{}
}

// APIModuleCleared returns if the "api_module" field was cleared in this mutation.
func (m *ApiAuditLogMutation) APIModuleCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldAPIModule]
	return ok
}

// ResetAPIModule resets all changes to the "api_module" field.
func (m *ApiAuditLogMutation) ResetAPIModule() {
	m.api_module = nil
	delete(m.clearedFields, apiauditlog.FieldAPIModule)
}

// SetAPIOperation sets the "api_operation" field.
func (m *ApiAuditLogMutation) SetAPIOperation(s string) {
	m.api_operation = &s
}

// APIOperation returns the value of the "api_operation" field in the mutation.
func (m *ApiAuditLogMutation) APIOperation() (r string, exists bool) {
	v := m.api_operation
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIOperation returns the old "api_operation" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldAPIOperation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIOperation: %w", err)
	}
	return oldValue.APIOperation, nil
}

// ClearAPIOperation clears the value of the "api_operation" field.
func (m *ApiAuditLogMutation) ClearAPIOperation() {
	m.api_operation = nil
	m.clearedFields[apiauditlog.FieldAPIOperation] = struct{}{}
}

// APIOperationCleared returns if the "api_operation" field was cleared in this mutation.
func (m *ApiAuditLogMutation) APIOperationCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldAPIOperation]
	return ok
}

// ResetAPIOperation resets all changes to the "api_operation" field.
func (m *ApiAuditLogMutation) ResetAPIOperation() {
	m.api_operation = nil
	delete(m.clearedFields, apiauditlog.FieldAPIOperation)
}

// SetAPIDescription sets the "api_description" field.
func (m *ApiAuditLogMutation) SetAPIDescription(s string) {
	m.api_description = &s
}

// APIDescription returns the value of the "api_description" field in the mutation.
func (m *ApiAuditLogMutation) APIDescription() (r string, exists bool) {
	v := m.api_description
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIDescription returns the old "api_description" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldAPIDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIDescription: %w", err)
	}
	return oldValue.APIDescription, nil
}

// ClearAPIDescription clears the value of the "api_description" field.
func (m *ApiAuditLogMutation) ClearAPIDescription() {
	m.api_description = nil
	m.clearedFields[apiauditlog.FieldAPIDescription] = struct{}{}
}

// APIDescriptionCleared returns if the "api_description" field was cleared in this mutation.
func (m *ApiAuditLogMutation) APIDescriptionCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldAPIDescription]
	return ok
}

// ResetAPIDescription resets all changes to the "api_description" field.
func (m *ApiAuditLogMutation) ResetAPIDescription() {
	m.api_description = nil
	delete(m.clearedFields, apiauditlog.FieldAPIDescription)
}

// SetRequestID sets the "request_id" field.
func (m *ApiAuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *ApiAuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *ApiAuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[apiauditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *ApiAuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *ApiAuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, apiauditlog.FieldRequestID)
}

// SetTraceID sets the "trace_id" field.
func (m *ApiAuditLogMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *ApiAuditLogMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldTraceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *ApiAuditLogMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[apiauditlog.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *ApiAuditLogMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *ApiAuditLogMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, apiauditlog.FieldTraceID)
}

// SetSpanID sets the "span_id" field.
func (m *ApiAuditLogMutation) SetSpanID(s string) {
	m.span_id = &s
}

// SpanID returns the value of the "span_id" field in the mutation.
func (m *ApiAuditLogMutation) SpanID() (r string, exists bool) {
	v := m.span_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpanID returns the old "span_id" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldSpanID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpanID: %w", err)
	}
	return oldValue.SpanID, nil
}

// ClearSpanID clears the value of the "span_id" field.
func (m *ApiAuditLogMutation) ClearSpanID() {
	m.span_id = nil
	m.clearedFields[apiauditlog.FieldSpanID] = struct{}{}
}

// SpanIDCleared returns if the "span_id" field was cleared in this mutation.
func (m *ApiAuditLogMutation) SpanIDCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldSpanID]
	return ok
}

// ResetSpanID resets all changes to the "span_id" field.
func (m *ApiAuditLogMutation) ResetSpanID() {
	m.span_id = nil
	delete(m.clearedFields, apiauditlog.FieldSpanID)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *ApiAuditLogMutation) SetLatencyMs(u uint32) {
	m.latency_ms = &u
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *ApiAuditLogMutation) LatencyMs() (r uint32, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldLatencyMs(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds u to the "latency_ms" field.
func (m *ApiAuditLogMutation) AddLatencyMs(u int32) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += u
	} else {
		m.addlatency_ms = &u
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *ApiAuditLogMutation) AddedLatencyMs() (r int32, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatencyMs clears the value of the "latency_ms" field.
func (m *ApiAuditLogMutation) ClearLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
	m.clearedFields[apiauditlog.FieldLatencyMs] = struct{}{}
}

// LatencyMsCleared returns if the "latency_ms" field was cleared in this mutation.
func (m *ApiAuditLogMutation) LatencyMsCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldLatencyMs]
	return ok
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *ApiAuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
	delete(m.clearedFields, apiauditlog.FieldLatencyMs)
}

// SetSuccess sets the "success" field.
func (m *ApiAuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *ApiAuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldSuccess(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ClearSuccess clears the value of the "success" field.
func (m *ApiAuditLogMutation) ClearSuccess() {
	m.success = nil
	m.clearedFields[apiauditlog.FieldSuccess] = struct{}{}
}

// SuccessCleared returns if the "success" field was cleared in this mutation.
func (m *ApiAuditLogMutation) SuccessCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldSuccess]
	return ok
}

// ResetSuccess resets all changes to the "success" field.
func (m *ApiAuditLogMutation) ResetSuccess() {
	m.success = nil
	delete(m.clearedFields, apiauditlog.FieldSuccess)
}

// SetStatusCode sets the "status_code" field.
func (m *ApiAuditLogMutation) SetStatusCode(u uint32) {
	m.status_code = &u
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *ApiAuditLogMutation) StatusCode() (r uint32, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldStatusCode(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds u to the "status_code" field.
func (m *ApiAuditLogMutation) AddStatusCode(u int32) {
	if m.addstatus_code != nil {
		*m.addstatus_code += u
	} else {
		m.addstatus_code = &u
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *ApiAuditLogMutation) AddedStatusCode() (r int32, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusCode clears the value of the "status_code" field.
func (m *ApiAuditLogMutation) ClearStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	m.clearedFields[apiauditlog.FieldStatusCode] = struct{}{}
}

// StatusCodeCleared returns if the "status_code" field was cleared in this mutation.
func (m *ApiAuditLogMutation) StatusCodeCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldStatusCode]
	return ok
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *ApiAuditLogMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	delete(m.clearedFields, apiauditlog.FieldStatusCode)
}

// SetReason sets the "reason" field.
func (m *ApiAuditLogMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ApiAuditLogMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *ApiAuditLogMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[apiauditlog.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *ApiAuditLogMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *ApiAuditLogMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, apiauditlog.FieldReason)
}

// SetRequestHeader sets the "request_header" field.
func (m *ApiAuditLogMutation) SetRequestHeader(s string) {
	m.request_header = &s
}

// RequestHeader returns the value of the "request_header" field in the mutation.
func (m *ApiAuditLogMutation) RequestHeader() (r string, exists bool) {
	v := m.request_header
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeader returns the old "request_header" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldRequestHeader(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeader: %w", err)
	}
	return oldValue.RequestHeader, nil
}

// ClearRequestHeader clears the value of the "request_header" field.
func (m *ApiAuditLogMutation) ClearRequestHeader() {
	m.request_header = nil
	m.clearedFields[apiauditlog.FieldRequestHeader] = struct{}{}
}

// RequestHeaderCleared returns if the "request_header" field was cleared in this mutation.
func (m *ApiAuditLogMutation) RequestHeaderCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldRequestHeader]
	return ok
}

// ResetRequestHeader resets all changes to the "request_header" field.
func (m *ApiAuditLogMutation) ResetRequestHeader() {
	m.request_header = nil
	delete(m.clearedFields, apiauditlog.FieldRequestHeader)
}

// SetRequestBody sets the "request_body" field.
func (m *ApiAuditLogMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *ApiAuditLogMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldRequestBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *ApiAuditLogMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[apiauditlog.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *ApiAuditLogMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *ApiAuditLogMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, apiauditlog.FieldRequestBody)
}

// SetResponse sets the "response" field.
func (m *ApiAuditLogMutation) SetResponse(s string) {
	m.response = &s
}

// Response returns the value of the "response" field in the mutation.
func (m *ApiAuditLogMutation) Response() (r string, exists bool) {
	v := m.response
	if v == nil {
		return
	}
	return *v, true
}

// OldResponse returns the old "response" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldResponse(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponse: %w", err)
	}
	return oldValue.Response, nil
}

// ClearResponse clears the value of the "response" field.
func (m *ApiAuditLogMutation) ClearResponse() {
	m.response = nil
	m.clearedFields[apiauditlog.FieldResponse] = struct{}{}
}

// ResponseCleared returns if the "response" field was cleared in this mutation.
func (m *ApiAuditLogMutation) ResponseCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldResponse]
	return ok
}

// ResetResponse resets all changes to the "response" field.
func (m *ApiAuditLogMutation) ResetResponse() {
	m.response = nil
	delete(m.clearedFields, apiauditlog.FieldResponse)
}

// SetLogHash sets the "log_hash" field.
func (m *ApiAuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *ApiAuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldLogHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *ApiAuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[apiauditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *ApiAuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *ApiAuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, apiauditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *ApiAuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *ApiAuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the ApiAuditLog entity.
// If the ApiAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAuditLogMutation) OldSignature(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *ApiAuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[apiauditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *ApiAuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[apiauditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *ApiAuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, apiauditlog.FieldSignature)
}

// Where appends a list predicates to the ApiAuditLogMutation builder.
func (m *ApiAuditLogMutation) Where(ps ...predicate.ApiAuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiAuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiAuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiAuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiAuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiAuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiAuditLog).
func (m *ApiAuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiAuditLogMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.created_at != nil {
		fields = append(fields, apiauditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, apiauditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, apiauditlog.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, apiauditlog.FieldUsername)
	}
	if m.ip_address != nil {
		fields = append(fields, apiauditlog.FieldIPAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, apiauditlog.FieldGeoLocation)
	}
	if m.device_info != nil {
		fields = append(fields, apiauditlog.FieldDeviceInfo)
	}
	if m.referer != nil {
		fields = append(fields, apiauditlog.FieldReferer)
	}
	if m.app_version != nil {
		fields = append(fields, apiauditlog.FieldAppVersion)
	}
	if m.http_method != nil {
		fields = append(fields, apiauditlog.FieldHTTPMethod)
	}
	if m._path != nil {
		fields = append(fields, apiauditlog.FieldPath)
	}
	if m.request_uri != nil {
		fields = append(fields, apiauditlog.FieldRequestURI)
	}
	if m.api_module != nil {
		fields = append(fields, apiauditlog.FieldAPIModule)
	}
	if m.api_operation != nil {
		fields = append(fields, apiauditlog.FieldAPIOperation)
	}
	if m.api_description != nil {
		fields = append(fields, apiauditlog.FieldAPIDescription)
	}
	if m.request_id != nil {
		fields = append(fields, apiauditlog.FieldRequestID)
	}
	if m.trace_id != nil {
		fields = append(fields, apiauditlog.FieldTraceID)
	}
	if m.span_id != nil {
		fields = append(fields, apiauditlog.FieldSpanID)
	}
	if m.latency_ms != nil {
		fields = append(fields, apiauditlog.FieldLatencyMs)
	}
	if m.success != nil {
		fields = append(fields, apiauditlog.FieldSuccess)
	}
	if m.status_code != nil {
		fields = append(fields, apiauditlog.FieldStatusCode)
	}
	if m.reason != nil {
		fields = append(fields, apiauditlog.FieldReason)
	}
	if m.request_header != nil {
		fields = append(fields, apiauditlog.FieldRequestHeader)
	}
	if m.request_body != nil {
		fields = append(fields, apiauditlog.FieldRequestBody)
	}
	if m.response != nil {
		fields = append(fields, apiauditlog.FieldResponse)
	}
	if m.log_hash != nil {
		fields = append(fields, apiauditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, apiauditlog.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiAuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apiauditlog.FieldCreatedAt:
		return m.CreatedAt()
	case apiauditlog.FieldTenantID:
		return m.TenantID()
	case apiauditlog.FieldUserID:
		return m.UserID()
	case apiauditlog.FieldUsername:
		return m.Username()
	case apiauditlog.FieldIPAddress:
		return m.IPAddress()
	case apiauditlog.FieldGeoLocation:
		return m.GeoLocation()
	case apiauditlog.FieldDeviceInfo:
		return m.DeviceInfo()
	case apiauditlog.FieldReferer:
		return m.Referer()
	case apiauditlog.FieldAppVersion:
		return m.AppVersion()
	case apiauditlog.FieldHTTPMethod:
		return m.HTTPMethod()
	case apiauditlog.FieldPath:
		return m.Path()
	case apiauditlog.FieldRequestURI:
		return m.RequestURI()
	case apiauditlog.FieldAPIModule:
		return m.APIModule()
	case apiauditlog.FieldAPIOperation:
		return m.APIOperation()
	case apiauditlog.FieldAPIDescription:
		return m.APIDescription()
	case apiauditlog.FieldRequestID:
		return m.RequestID()
	case apiauditlog.FieldTraceID:
		return m.TraceID()
	case apiauditlog.FieldSpanID:
		return m.SpanID()
	case apiauditlog.FieldLatencyMs:
		return m.LatencyMs()
	case apiauditlog.FieldSuccess:
		return m.Success()
	case apiauditlog.FieldStatusCode:
		return m.StatusCode()
	case apiauditlog.FieldReason:
		return m.Reason()
	case apiauditlog.FieldRequestHeader:
		return m.RequestHeader()
	case apiauditlog.FieldRequestBody:
		return m.RequestBody()
	case apiauditlog.FieldResponse:
		return m.Response()
	case apiauditlog.FieldLogHash:
		return m.LogHash()
	case apiauditlog.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiAuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apiauditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apiauditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case apiauditlog.FieldUserID:
		return m.OldUserID(ctx)
	case apiauditlog.FieldUsername:
		return m.OldUsername(ctx)
	case apiauditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case apiauditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case apiauditlog.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case apiauditlog.FieldReferer:
		return m.OldReferer(ctx)
	case apiauditlog.FieldAppVersion:
		return m.OldAppVersion(ctx)
	case apiauditlog.FieldHTTPMethod:
		return m.OldHTTPMethod(ctx)
	case apiauditlog.FieldPath:
		return m.OldPath(ctx)
	case apiauditlog.FieldRequestURI:
		return m.OldRequestURI(ctx)
	case apiauditlog.FieldAPIModule:
		return m.OldAPIModule(ctx)
	case apiauditlog.FieldAPIOperation:
		return m.OldAPIOperation(ctx)
	case apiauditlog.FieldAPIDescription:
		return m.OldAPIDescription(ctx)
	case apiauditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case apiauditlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case apiauditlog.FieldSpanID:
		return m.OldSpanID(ctx)
	case apiauditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case apiauditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case apiauditlog.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case apiauditlog.FieldReason:
		return m.OldReason(ctx)
	case apiauditlog.FieldRequestHeader:
		return m.OldRequestHeader(ctx)
	case apiauditlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case apiauditlog.FieldResponse:
		return m.OldResponse(ctx)
	case apiauditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case apiauditlog.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown ApiAuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiAuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apiauditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apiauditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case apiauditlog.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apiauditlog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case apiauditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case apiauditlog.FieldGeoLocation:
		v, ok := value.(*auditpb.GeoLocation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case apiauditlog.FieldDeviceInfo:
		v, ok := value.(*auditpb.DeviceInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case apiauditlog.FieldReferer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferer(v)
		return nil
	case apiauditlog.FieldAppVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersion(v)
		return nil
	case apiauditlog.FieldHTTPMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTTPMethod(v)
		return nil
	case apiauditlog.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case apiauditlog.FieldRequestURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestURI(v)
		return nil
	case apiauditlog.FieldAPIModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIModule(v)
		return nil
	case apiauditlog.FieldAPIOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIOperation(v)
		return nil
	case apiauditlog.FieldAPIDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIDescription(v)
		return nil
	case apiauditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case apiauditlog.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case apiauditlog.FieldSpanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpanID(v)
		return nil
	case apiauditlog.FieldLatencyMs:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case apiauditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case apiauditlog.FieldStatusCode:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case apiauditlog.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case apiauditlog.FieldRequestHeader:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeader(v)
		return nil
	case apiauditlog.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case apiauditlog.FieldResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponse(v)
		return nil
	case apiauditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case apiauditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown ApiAuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiAuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, apiauditlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, apiauditlog.FieldUserID)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, apiauditlog.FieldLatencyMs)
	}
	if m.addstatus_code != nil {
		fields = append(fields, apiauditlog.FieldStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiAuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apiauditlog.FieldTenantID:
		return m.AddedTenantID()
	case apiauditlog.FieldUserID:
		return m.AddedUserID()
	case apiauditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	case apiauditlog.FieldStatusCode:
		return m.AddedStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiAuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apiauditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case apiauditlog.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case apiauditlog.FieldLatencyMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	case apiauditlog.FieldStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown ApiAuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiAuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apiauditlog.FieldCreatedAt) {
		fields = append(fields, apiauditlog.FieldCreatedAt)
	}
	if m.FieldCleared(apiauditlog.FieldTenantID) {
		fields = append(fields, apiauditlog.FieldTenantID)
	}
	if m.FieldCleared(apiauditlog.FieldUserID) {
		fields = append(fields, apiauditlog.FieldUserID)
	}
	if m.FieldCleared(apiauditlog.FieldUsername) {
		fields = append(fields, apiauditlog.FieldUsername)
	}
	if m.FieldCleared(apiauditlog.FieldIPAddress) {
		fields = append(fields, apiauditlog.FieldIPAddress)
	}
	if m.FieldCleared(apiauditlog.FieldGeoLocation) {
		fields = append(fields, apiauditlog.FieldGeoLocation)
	}
	if m.FieldCleared(apiauditlog.FieldDeviceInfo) {
		fields = append(fields, apiauditlog.FieldDeviceInfo)
	}
	if m.FieldCleared(apiauditlog.FieldReferer) {
		fields = append(fields, apiauditlog.FieldReferer)
	}
	if m.FieldCleared(apiauditlog.FieldAppVersion) {
		fields = append(fields, apiauditlog.FieldAppVersion)
	}
	if m.FieldCleared(apiauditlog.FieldHTTPMethod) {
		fields = append(fields, apiauditlog.FieldHTTPMethod)
	}
	if m.FieldCleared(apiauditlog.FieldPath) {
		fields = append(fields, apiauditlog.FieldPath)
	}
	if m.FieldCleared(apiauditlog.FieldRequestURI) {
		fields = append(fields, apiauditlog.FieldRequestURI)
	}
	if m.FieldCleared(apiauditlog.FieldAPIModule) {
		fields = append(fields, apiauditlog.FieldAPIModule)
	}
	if m.FieldCleared(apiauditlog.FieldAPIOperation) {
		fields = append(fields, apiauditlog.FieldAPIOperation)
	}
	if m.FieldCleared(apiauditlog.FieldAPIDescription) {
		fields = append(fields, apiauditlog.FieldAPIDescription)
	}
	if m.FieldCleared(apiauditlog.FieldRequestID) {
		fields = append(fields, apiauditlog.FieldRequestID)
	}
	if m.FieldCleared(apiauditlog.FieldTraceID) {
		fields = append(fields, apiauditlog.FieldTraceID)
	}
	if m.FieldCleared(apiauditlog.FieldSpanID) {
		fields = append(fields, apiauditlog.FieldSpanID)
	}
	if m.FieldCleared(apiauditlog.FieldLatencyMs) {
		fields = append(fields, apiauditlog.FieldLatencyMs)
	}
	if m.FieldCleared(apiauditlog.FieldSuccess) {
		fields = append(fields, apiauditlog.FieldSuccess)
	}
	if m.FieldCleared(apiauditlog.FieldStatusCode) {
		fields = append(fields, apiauditlog.FieldStatusCode)
	}
	if m.FieldCleared(apiauditlog.FieldReason) {
		fields = append(fields, apiauditlog.FieldReason)
	}
	if m.FieldCleared(apiauditlog.FieldRequestHeader) {
		fields = append(fields, apiauditlog.FieldRequestHeader)
	}
	if m.FieldCleared(apiauditlog.FieldRequestBody) {
		fields = append(fields, apiauditlog.FieldRequestBody)
	}
	if m.FieldCleared(apiauditlog.FieldResponse) {
		fields = append(fields, apiauditlog.FieldResponse)
	}
	if m.FieldCleared(apiauditlog.FieldLogHash) {
		fields = append(fields, apiauditlog.FieldLogHash)
	}
	if m.FieldCleared(apiauditlog.FieldSignature) {
		fields = append(fields, apiauditlog.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiAuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiAuditLogMutation) ClearField(name string) error {
	switch name {
	case apiauditlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case apiauditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case apiauditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case apiauditlog.FieldUsername:
		m.ClearUsername()
		return nil
	case apiauditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case apiauditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case apiauditlog.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case apiauditlog.FieldReferer:
		m.ClearReferer()
		return nil
	case apiauditlog.FieldAppVersion:
		m.ClearAppVersion()
		return nil
	case apiauditlog.FieldHTTPMethod:
		m.ClearHTTPMethod()
		return nil
	case apiauditlog.FieldPath:
		m.ClearPath()
		return nil
	case apiauditlog.FieldRequestURI:
		m.ClearRequestURI()
		return nil
	case apiauditlog.FieldAPIModule:
		m.ClearAPIModule()
		return nil
	case apiauditlog.FieldAPIOperation:
		m.ClearAPIOperation()
		return nil
	case apiauditlog.FieldAPIDescription:
		m.ClearAPIDescription()
		return nil
	case apiauditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case apiauditlog.FieldTraceID:
		m.ClearTraceID()
		return nil
	case apiauditlog.FieldSpanID:
		m.ClearSpanID()
		return nil
	case apiauditlog.FieldLatencyMs:
		m.ClearLatencyMs()
		return nil
	case apiauditlog.FieldSuccess:
		m.ClearSuccess()
		return nil
	case apiauditlog.FieldStatusCode:
		m.ClearStatusCode()
		return nil
	case apiauditlog.FieldReason:
		m.ClearReason()
		return nil
	case apiauditlog.FieldRequestHeader:
		m.ClearRequestHeader()
		return nil
	case apiauditlog.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	case apiauditlog.FieldResponse:
		m.ClearResponse()
		return nil
	case apiauditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case apiauditlog.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown ApiAuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiAuditLogMutation) ResetField(name string) error {
	switch name {
	case apiauditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apiauditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case apiauditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case apiauditlog.FieldUsername:
		m.ResetUsername()
		return nil
	case apiauditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case apiauditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case apiauditlog.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case apiauditlog.FieldReferer:
		m.ResetReferer()
		return nil
	case apiauditlog.FieldAppVersion:
		m.ResetAppVersion()
		return nil
	case apiauditlog.FieldHTTPMethod:
		m.ResetHTTPMethod()
		return nil
	case apiauditlog.FieldPath:
		m.ResetPath()
		return nil
	case apiauditlog.FieldRequestURI:
		m.ResetRequestURI()
		return nil
	case apiauditlog.FieldAPIModule:
		m.ResetAPIModule()
		return nil
	case apiauditlog.FieldAPIOperation:
		m.ResetAPIOperation()
		return nil
	case apiauditlog.FieldAPIDescription:
		m.ResetAPIDescription()
		return nil
	case apiauditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case apiauditlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case apiauditlog.FieldSpanID:
		m.ResetSpanID()
		return nil
	case apiauditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case apiauditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case apiauditlog.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case apiauditlog.FieldReason:
		m.ResetReason()
		return nil
	case apiauditlog.FieldRequestHeader:
		m.ResetRequestHeader()
		return nil
	case apiauditlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case apiauditlog.FieldResponse:
		m.ResetResponse()
		return nil
	case apiauditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case apiauditlog.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown ApiAuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiAuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiAuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiAuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiAuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiAuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiAuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiAuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiAuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiAuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiAuditLog edge %s", name)
}

// DataAccessAuditLogMutation represents an operation that mutates the DataAccessAuditLog nodes in the graph.
type DataAccessAuditLogMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	tenant_id        *uint32
	addtenant_id     *int32
	user_id          *uint32
	adduser_id       *int32
	username         *string
	ip_address       *string
	geo_location     **auditpb.GeoLocation
	device_info      **auditpb.DeviceInfo
	request_id       *string
	trace_id         *string
	data_source      *string
	table_name       *string
	data_id          *string
	access_type      *dataaccessauditlog.AccessType
	sql_digest       *string
	sql_text         *string
	affected_rows    *uint32
	addaffected_rows *int32
	latency_ms       *uint32
	addlatency_ms    *int32
	success          *bool
	sensitive_level  *dataaccessauditlog.SensitiveLevel
	data_masked      *bool
	masking_rules    *string
	business_purpose *string
	data_category    *string
	db_user          *string
	log_hash         *string
	signature        *[]byte
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*DataAccessAuditLog, error)
	predicates       []predicate.DataAccessAuditLog
}

var _ ent.Mutation = (*DataAccessAuditLogMutation)(nil)

// dataaccessauditlogOption allows management of the mutation configuration using functional options.
type dataaccessauditlogOption func(*DataAccessAuditLogMutation)

// newDataAccessAuditLogMutation creates new mutation for the DataAccessAuditLog entity.
func newDataAccessAuditLogMutation(c config, op Op, opts ...dataaccessauditlogOption) *DataAccessAuditLogMutation {
	m := &DataAccessAuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeDataAccessAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataAccessAuditLogID sets the ID field of the mutation.
func withDataAccessAuditLogID(id uint32) dataaccessauditlogOption {
	return func(m *DataAccessAuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *DataAccessAuditLog
		)
		m.oldValue = func(ctx context.Context) (*DataAccessAuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataAccessAuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataAccessAuditLog sets the old DataAccessAuditLog of the mutation.
func withDataAccessAuditLog(node *DataAccessAuditLog) dataaccessauditlogOption {
	return func(m *DataAccessAuditLogMutation) {
		m.oldValue = func(context.Context) (*DataAccessAuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataAccessAuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataAccessAuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DataAccessAuditLog entities.
func (m *DataAccessAuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DataAccessAuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DataAccessAuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DataAccessAuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DataAccessAuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DataAccessAuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DataAccessAuditLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dataaccessauditlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DataAccessAuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dataaccessauditlog.FieldCreatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *DataAccessAuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DataAccessAuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DataAccessAuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DataAccessAuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DataAccessAuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[dataaccessauditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DataAccessAuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, dataaccessauditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *DataAccessAuditLogMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DataAccessAuditLogMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *DataAccessAuditLogMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *DataAccessAuditLogMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *DataAccessAuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[dataaccessauditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DataAccessAuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, dataaccessauditlog.FieldUserID)
}

// SetUsername sets the "username" field.
func (m *DataAccessAuditLogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *DataAccessAuditLogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *DataAccessAuditLogMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[dataaccessauditlog.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *DataAccessAuditLogMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, dataaccessauditlog.FieldUsername)
}

// SetIPAddress sets the "ip_address" field.
func (m *DataAccessAuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *DataAccessAuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *DataAccessAuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[dataaccessauditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *DataAccessAuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, dataaccessauditlog.FieldIPAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *DataAccessAuditLogMutation) SetGeoLocation(al *auditpb.GeoLocation) {
	m.geo_location = &al
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *DataAccessAuditLogMutation) GeoLocation() (r *auditpb.GeoLocation, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldGeoLocation(ctx context.Context) (v *auditpb.GeoLocation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *DataAccessAuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[dataaccessauditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *DataAccessAuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, dataaccessauditlog.FieldGeoLocation)
}

// SetDeviceInfo sets the "device_info" field.
func (m *DataAccessAuditLogMutation) SetDeviceInfo(ai *auditpb.DeviceInfo) {
	m.device_info = &ai
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *DataAccessAuditLogMutation) DeviceInfo() (r *auditpb.DeviceInfo, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldDeviceInfo(ctx context.Context) (v *auditpb.DeviceInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *DataAccessAuditLogMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[dataaccessauditlog.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *DataAccessAuditLogMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, dataaccessauditlog.FieldDeviceInfo)
}

// SetRequestID sets the "request_id" field.
func (m *DataAccessAuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *DataAccessAuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *DataAccessAuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[dataaccessauditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *DataAccessAuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, dataaccessauditlog.FieldRequestID)
}

// SetTraceID sets the "trace_id" field.
func (m *DataAccessAuditLogMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *DataAccessAuditLogMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldTraceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *DataAccessAuditLogMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[dataaccessauditlog.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *DataAccessAuditLogMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, dataaccessauditlog.FieldTraceID)
}

// SetDataSource sets the "data_source" field.
func (m *DataAccessAuditLogMutation) SetDataSource(s string) {
	m.data_source = &s
}

// DataSource returns the value of the "data_source" field in the mutation.
func (m *DataAccessAuditLogMutation) DataSource() (r string, exists bool) {
	v := m.data_source
	if v == nil {
		return
	}
	return *v, true
}

// OldDataSource returns the old "data_source" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldDataSource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataSource: %w", err)
	}
	return oldValue.DataSource, nil
}

// ClearDataSource clears the value of the "data_source" field.
func (m *DataAccessAuditLogMutation) ClearDataSource() {
	m.data_source = nil
	m.clearedFields[dataaccessauditlog.FieldDataSource] = struct{}{}
}

// DataSourceCleared returns if the "data_source" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) DataSourceCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldDataSource]
	return ok
}

// ResetDataSource resets all changes to the "data_source" field.
func (m *DataAccessAuditLogMutation) ResetDataSource() {
	m.data_source = nil
	delete(m.clearedFields, dataaccessauditlog.FieldDataSource)
}

// SetTableName sets the "table_name" field.
func (m *DataAccessAuditLogMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *DataAccessAuditLogMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldTableName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ClearTableName clears the value of the "table_name" field.
func (m *DataAccessAuditLogMutation) ClearTableName() {
	m.table_name = nil
	m.clearedFields[dataaccessauditlog.FieldTableName] = struct{}{}
}

// TableNameCleared returns if the "table_name" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) TableNameCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldTableName]
	return ok
}

// ResetTableName resets all changes to the "table_name" field.
func (m *DataAccessAuditLogMutation) ResetTableName() {
	m.table_name = nil
	delete(m.clearedFields, dataaccessauditlog.FieldTableName)
}

// SetDataID sets the "data_id" field.
func (m *DataAccessAuditLogMutation) SetDataID(s string) {
	m.data_id = &s
}

// DataID returns the value of the "data_id" field in the mutation.
func (m *DataAccessAuditLogMutation) DataID() (r string, exists bool) {
	v := m.data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDataID returns the old "data_id" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldDataID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataID: %w", err)
	}
	return oldValue.DataID, nil
}

// ClearDataID clears the value of the "data_id" field.
func (m *DataAccessAuditLogMutation) ClearDataID() {
	m.data_id = nil
	m.clearedFields[dataaccessauditlog.FieldDataID] = struct{}{}
}

// DataIDCleared returns if the "data_id" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) DataIDCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldDataID]
	return ok
}

// ResetDataID resets all changes to the "data_id" field.
func (m *DataAccessAuditLogMutation) ResetDataID() {
	m.data_id = nil
	delete(m.clearedFields, dataaccessauditlog.FieldDataID)
}

// SetAccessType sets the "access_type" field.
func (m *DataAccessAuditLogMutation) SetAccessType(dt dataaccessauditlog.AccessType) {
	m.access_type = &dt
}

// AccessType returns the value of the "access_type" field in the mutation.
func (m *DataAccessAuditLogMutation) AccessType() (r dataaccessauditlog.AccessType, exists bool) {
	v := m.access_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessType returns the old "access_type" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldAccessType(ctx context.Context) (v *dataaccessauditlog.AccessType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessType: %w", err)
	}
	return oldValue.AccessType, nil
}

// ClearAccessType clears the value of the "access_type" field.
func (m *DataAccessAuditLogMutation) ClearAccessType() {
	m.access_type = nil
	m.clearedFields[dataaccessauditlog.FieldAccessType] = struct{}{}
}

// AccessTypeCleared returns if the "access_type" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) AccessTypeCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldAccessType]
	return ok
}

// ResetAccessType resets all changes to the "access_type" field.
func (m *DataAccessAuditLogMutation) ResetAccessType() {
	m.access_type = nil
	delete(m.clearedFields, dataaccessauditlog.FieldAccessType)
}

// SetSQLDigest sets the "sql_digest" field.
func (m *DataAccessAuditLogMutation) SetSQLDigest(s string) {
	m.sql_digest = &s
}

// SQLDigest returns the value of the "sql_digest" field in the mutation.
func (m *DataAccessAuditLogMutation) SQLDigest() (r string, exists bool) {
	v := m.sql_digest
	if v == nil {
		return
	}
	return *v, true
}

// OldSQLDigest returns the old "sql_digest" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldSQLDigest(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSQLDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSQLDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSQLDigest: %w", err)
	}
	return oldValue.SQLDigest, nil
}

// ClearSQLDigest clears the value of the "sql_digest" field.
func (m *DataAccessAuditLogMutation) ClearSQLDigest() {
	m.sql_digest = nil
	m.clearedFields[dataaccessauditlog.FieldSQLDigest] = struct{}{}
}

// SQLDigestCleared returns if the "sql_digest" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) SQLDigestCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldSQLDigest]
	return ok
}

// ResetSQLDigest resets all changes to the "sql_digest" field.
func (m *DataAccessAuditLogMutation) ResetSQLDigest() {
	m.sql_digest = nil
	delete(m.clearedFields, dataaccessauditlog.FieldSQLDigest)
}

// SetSQLText sets the "sql_text" field.
func (m *DataAccessAuditLogMutation) SetSQLText(s string) {
	m.sql_text = &s
}

// SQLText returns the value of the "sql_text" field in the mutation.
func (m *DataAccessAuditLogMutation) SQLText() (r string, exists bool) {
	v := m.sql_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSQLText returns the old "sql_text" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldSQLText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSQLText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSQLText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSQLText: %w", err)
	}
	return oldValue.SQLText, nil
}

// ClearSQLText clears the value of the "sql_text" field.
func (m *DataAccessAuditLogMutation) ClearSQLText() {
	m.sql_text = nil
	m.clearedFields[dataaccessauditlog.FieldSQLText] = struct{}{}
}

// SQLTextCleared returns if the "sql_text" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) SQLTextCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldSQLText]
	return ok
}

// ResetSQLText resets all changes to the "sql_text" field.
func (m *DataAccessAuditLogMutation) ResetSQLText() {
	m.sql_text = nil
	delete(m.clearedFields, dataaccessauditlog.FieldSQLText)
}

// SetAffectedRows sets the "affected_rows" field.
func (m *DataAccessAuditLogMutation) SetAffectedRows(u uint32) {
	m.affected_rows = &u
	m.addaffected_rows = nil
}

// AffectedRows returns the value of the "affected_rows" field in the mutation.
func (m *DataAccessAuditLogMutation) AffectedRows() (r uint32, exists bool) {
	v := m.affected_rows
	if v == nil {
		return
	}
	return *v, true
}

// OldAffectedRows returns the old "affected_rows" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldAffectedRows(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffectedRows is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffectedRows requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffectedRows: %w", err)
	}
	return oldValue.AffectedRows, nil
}

// AddAffectedRows adds u to the "affected_rows" field.
func (m *DataAccessAuditLogMutation) AddAffectedRows(u int32) {
	if m.addaffected_rows != nil {
		*m.addaffected_rows += u
	} else {
		m.addaffected_rows = &u
	}
}

// AddedAffectedRows returns the value that was added to the "affected_rows" field in this mutation.
func (m *DataAccessAuditLogMutation) AddedAffectedRows() (r int32, exists bool) {
	v := m.addaffected_rows
	if v == nil {
		return
	}
	return *v, true
}

// ClearAffectedRows clears the value of the "affected_rows" field.
func (m *DataAccessAuditLogMutation) ClearAffectedRows() {
	m.affected_rows = nil
	m.addaffected_rows = nil
	m.clearedFields[dataaccessauditlog.FieldAffectedRows] = struct{}{}
}

// AffectedRowsCleared returns if the "affected_rows" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) AffectedRowsCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldAffectedRows]
	return ok
}

// ResetAffectedRows resets all changes to the "affected_rows" field.
func (m *DataAccessAuditLogMutation) ResetAffectedRows() {
	m.affected_rows = nil
	m.addaffected_rows = nil
	delete(m.clearedFields, dataaccessauditlog.FieldAffectedRows)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *DataAccessAuditLogMutation) SetLatencyMs(u uint32) {
	m.latency_ms = &u
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *DataAccessAuditLogMutation) LatencyMs() (r uint32, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldLatencyMs(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds u to the "latency_ms" field.
func (m *DataAccessAuditLogMutation) AddLatencyMs(u int32) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += u
	} else {
		m.addlatency_ms = &u
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *DataAccessAuditLogMutation) AddedLatencyMs() (r int32, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatencyMs clears the value of the "latency_ms" field.
func (m *DataAccessAuditLogMutation) ClearLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
	m.clearedFields[dataaccessauditlog.FieldLatencyMs] = struct{}{}
}

// LatencyMsCleared returns if the "latency_ms" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) LatencyMsCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldLatencyMs]
	return ok
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *DataAccessAuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
	delete(m.clearedFields, dataaccessauditlog.FieldLatencyMs)
}

// SetSuccess sets the "success" field.
func (m *DataAccessAuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *DataAccessAuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldSuccess(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ClearSuccess clears the value of the "success" field.
func (m *DataAccessAuditLogMutation) ClearSuccess() {
	m.success = nil
	m.clearedFields[dataaccessauditlog.FieldSuccess] = struct{}{}
}

// SuccessCleared returns if the "success" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) SuccessCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldSuccess]
	return ok
}

// ResetSuccess resets all changes to the "success" field.
func (m *DataAccessAuditLogMutation) ResetSuccess() {
	m.success = nil
	delete(m.clearedFields, dataaccessauditlog.FieldSuccess)
}

// SetSensitiveLevel sets the "sensitive_level" field.
func (m *DataAccessAuditLogMutation) SetSensitiveLevel(dl dataaccessauditlog.SensitiveLevel) {
	m.sensitive_level = &dl
}

// SensitiveLevel returns the value of the "sensitive_level" field in the mutation.
func (m *DataAccessAuditLogMutation) SensitiveLevel() (r dataaccessauditlog.SensitiveLevel, exists bool) {
	v := m.sensitive_level
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitiveLevel returns the old "sensitive_level" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldSensitiveLevel(ctx context.Context) (v *dataaccessauditlog.SensitiveLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitiveLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitiveLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitiveLevel: %w", err)
	}
	return oldValue.SensitiveLevel, nil
}

// ClearSensitiveLevel clears the value of the "sensitive_level" field.
func (m *DataAccessAuditLogMutation) ClearSensitiveLevel() {
	m.sensitive_level = nil
	m.clearedFields[dataaccessauditlog.FieldSensitiveLevel] = struct{}{}
}

// SensitiveLevelCleared returns if the "sensitive_level" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) SensitiveLevelCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldSensitiveLevel]
	return ok
}

// ResetSensitiveLevel resets all changes to the "sensitive_level" field.
func (m *DataAccessAuditLogMutation) ResetSensitiveLevel() {
	m.sensitive_level = nil
	delete(m.clearedFields, dataaccessauditlog.FieldSensitiveLevel)
}

// SetDataMasked sets the "data_masked" field.
func (m *DataAccessAuditLogMutation) SetDataMasked(b bool) {
	m.data_masked = &b
}

// DataMasked returns the value of the "data_masked" field in the mutation.
func (m *DataAccessAuditLogMutation) DataMasked() (r bool, exists bool) {
	v := m.data_masked
	if v == nil {
		return
	}
	return *v, true
}

// OldDataMasked returns the old "data_masked" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldDataMasked(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataMasked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataMasked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataMasked: %w", err)
	}
	return oldValue.DataMasked, nil
}

// ClearDataMasked clears the value of the "data_masked" field.
func (m *DataAccessAuditLogMutation) ClearDataMasked() {
	m.data_masked = nil
	m.clearedFields[dataaccessauditlog.FieldDataMasked] = struct{}{}
}

// DataMaskedCleared returns if the "data_masked" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) DataMaskedCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldDataMasked]
	return ok
}

// ResetDataMasked resets all changes to the "data_masked" field.
func (m *DataAccessAuditLogMutation) ResetDataMasked() {
	m.data_masked = nil
	delete(m.clearedFields, dataaccessauditlog.FieldDataMasked)
}

// SetMaskingRules sets the "masking_rules" field.
func (m *DataAccessAuditLogMutation) SetMaskingRules(s string) {
	m.masking_rules = &s
}

// MaskingRules returns the value of the "masking_rules" field in the mutation.
func (m *DataAccessAuditLogMutation) MaskingRules() (r string, exists bool) {
	v := m.masking_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldMaskingRules returns the old "masking_rules" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldMaskingRules(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaskingRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaskingRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaskingRules: %w", err)
	}
	return oldValue.MaskingRules, nil
}

// ClearMaskingRules clears the value of the "masking_rules" field.
func (m *DataAccessAuditLogMutation) ClearMaskingRules() {
	m.masking_rules = nil
	m.clearedFields[dataaccessauditlog.FieldMaskingRules] = struct{}{}
}

// MaskingRulesCleared returns if the "masking_rules" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) MaskingRulesCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldMaskingRules]
	return ok
}

// ResetMaskingRules resets all changes to the "masking_rules" field.
func (m *DataAccessAuditLogMutation) ResetMaskingRules() {
	m.masking_rules = nil
	delete(m.clearedFields, dataaccessauditlog.FieldMaskingRules)
}

// SetBusinessPurpose sets the "business_purpose" field.
func (m *DataAccessAuditLogMutation) SetBusinessPurpose(s string) {
	m.business_purpose = &s
}

// BusinessPurpose returns the value of the "business_purpose" field in the mutation.
func (m *DataAccessAuditLogMutation) BusinessPurpose() (r string, exists bool) {
	v := m.business_purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessPurpose returns the old "business_purpose" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldBusinessPurpose(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessPurpose: %w", err)
	}
	return oldValue.BusinessPurpose, nil
}

// ClearBusinessPurpose clears the value of the "business_purpose" field.
func (m *DataAccessAuditLogMutation) ClearBusinessPurpose() {
	m.business_purpose = nil
	m.clearedFields[dataaccessauditlog.FieldBusinessPurpose] = struct{}{}
}

// BusinessPurposeCleared returns if the "business_purpose" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) BusinessPurposeCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldBusinessPurpose]
	return ok
}

// ResetBusinessPurpose resets all changes to the "business_purpose" field.
func (m *DataAccessAuditLogMutation) ResetBusinessPurpose() {
	m.business_purpose = nil
	delete(m.clearedFields, dataaccessauditlog.FieldBusinessPurpose)
}

// SetDataCategory sets the "data_category" field.
func (m *DataAccessAuditLogMutation) SetDataCategory(s string) {
	m.data_category = &s
}

// DataCategory returns the value of the "data_category" field in the mutation.
func (m *DataAccessAuditLogMutation) DataCategory() (r string, exists bool) {
	v := m.data_category
	if v == nil {
		return
	}
	return *v, true
}

// OldDataCategory returns the old "data_category" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldDataCategory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataCategory: %w", err)
	}
	return oldValue.DataCategory, nil
}

// ClearDataCategory clears the value of the "data_category" field.
func (m *DataAccessAuditLogMutation) ClearDataCategory() {
	m.data_category = nil
	m.clearedFields[dataaccessauditlog.FieldDataCategory] = struct{}{}
}

// DataCategoryCleared returns if the "data_category" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) DataCategoryCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldDataCategory]
	return ok
}

// ResetDataCategory resets all changes to the "data_category" field.
func (m *DataAccessAuditLogMutation) ResetDataCategory() {
	m.data_category = nil
	delete(m.clearedFields, dataaccessauditlog.FieldDataCategory)
}

// SetDbUser sets the "db_user" field.
func (m *DataAccessAuditLogMutation) SetDbUser(s string) {
	m.db_user = &s
}

// DbUser returns the value of the "db_user" field in the mutation.
func (m *DataAccessAuditLogMutation) DbUser() (r string, exists bool) {
	v := m.db_user
	if v == nil {
		return
	}
	return *v, true
}

// OldDbUser returns the old "db_user" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldDbUser(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbUser: %w", err)
	}
	return oldValue.DbUser, nil
}

// ClearDbUser clears the value of the "db_user" field.
func (m *DataAccessAuditLogMutation) ClearDbUser() {
	m.db_user = nil
	m.clearedFields[dataaccessauditlog.FieldDbUser] = struct{}{}
}

// DbUserCleared returns if the "db_user" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) DbUserCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldDbUser]
	return ok
}

// ResetDbUser resets all changes to the "db_user" field.
func (m *DataAccessAuditLogMutation) ResetDbUser() {
	m.db_user = nil
	delete(m.clearedFields, dataaccessauditlog.FieldDbUser)
}

// SetLogHash sets the "log_hash" field.
func (m *DataAccessAuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *DataAccessAuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldLogHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *DataAccessAuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[dataaccessauditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *DataAccessAuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, dataaccessauditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *DataAccessAuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *DataAccessAuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the DataAccessAuditLog entity.
// If the DataAccessAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataAccessAuditLogMutation) OldSignature(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *DataAccessAuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[dataaccessauditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *DataAccessAuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[dataaccessauditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *DataAccessAuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, dataaccessauditlog.FieldSignature)
}

// Where appends a list predicates to the DataAccessAuditLogMutation builder.
func (m *DataAccessAuditLogMutation) Where(ps ...predicate.DataAccessAuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DataAccessAuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DataAccessAuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DataAccessAuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DataAccessAuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DataAccessAuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DataAccessAuditLog).
func (m *DataAccessAuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DataAccessAuditLogMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, dataaccessauditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, dataaccessauditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, dataaccessauditlog.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, dataaccessauditlog.FieldUsername)
	}
	if m.ip_address != nil {
		fields = append(fields, dataaccessauditlog.FieldIPAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, dataaccessauditlog.FieldGeoLocation)
	}
	if m.device_info != nil {
		fields = append(fields, dataaccessauditlog.FieldDeviceInfo)
	}
	if m.request_id != nil {
		fields = append(fields, dataaccessauditlog.FieldRequestID)
	}
	if m.trace_id != nil {
		fields = append(fields, dataaccessauditlog.FieldTraceID)
	}
	if m.data_source != nil {
		fields = append(fields, dataaccessauditlog.FieldDataSource)
	}
	if m.table_name != nil {
		fields = append(fields, dataaccessauditlog.FieldTableName)
	}
	if m.data_id != nil {
		fields = append(fields, dataaccessauditlog.FieldDataID)
	}
	if m.access_type != nil {
		fields = append(fields, dataaccessauditlog.FieldAccessType)
	}
	if m.sql_digest != nil {
		fields = append(fields, dataaccessauditlog.FieldSQLDigest)
	}
	if m.sql_text != nil {
		fields = append(fields, dataaccessauditlog.FieldSQLText)
	}
	if m.affected_rows != nil {
		fields = append(fields, dataaccessauditlog.FieldAffectedRows)
	}
	if m.latency_ms != nil {
		fields = append(fields, dataaccessauditlog.FieldLatencyMs)
	}
	if m.success != nil {
		fields = append(fields, dataaccessauditlog.FieldSuccess)
	}
	if m.sensitive_level != nil {
		fields = append(fields, dataaccessauditlog.FieldSensitiveLevel)
	}
	if m.data_masked != nil {
		fields = append(fields, dataaccessauditlog.FieldDataMasked)
	}
	if m.masking_rules != nil {
		fields = append(fields, dataaccessauditlog.FieldMaskingRules)
	}
	if m.business_purpose != nil {
		fields = append(fields, dataaccessauditlog.FieldBusinessPurpose)
	}
	if m.data_category != nil {
		fields = append(fields, dataaccessauditlog.FieldDataCategory)
	}
	if m.db_user != nil {
		fields = append(fields, dataaccessauditlog.FieldDbUser)
	}
	if m.log_hash != nil {
		fields = append(fields, dataaccessauditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, dataaccessauditlog.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DataAccessAuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dataaccessauditlog.FieldCreatedAt:
		return m.CreatedAt()
	case dataaccessauditlog.FieldTenantID:
		return m.TenantID()
	case dataaccessauditlog.FieldUserID:
		return m.UserID()
	case dataaccessauditlog.FieldUsername:
		return m.Username()
	case dataaccessauditlog.FieldIPAddress:
		return m.IPAddress()
	case dataaccessauditlog.FieldGeoLocation:
		return m.GeoLocation()
	case dataaccessauditlog.FieldDeviceInfo:
		return m.DeviceInfo()
	case dataaccessauditlog.FieldRequestID:
		return m.RequestID()
	case dataaccessauditlog.FieldTraceID:
		return m.TraceID()
	case dataaccessauditlog.FieldDataSource:
		return m.DataSource()
	case dataaccessauditlog.FieldTableName:
		return m.TableName()
	case dataaccessauditlog.FieldDataID:
		return m.DataID()
	case dataaccessauditlog.FieldAccessType:
		return m.AccessType()
	case dataaccessauditlog.FieldSQLDigest:
		return m.SQLDigest()
	case dataaccessauditlog.FieldSQLText:
		return m.SQLText()
	case dataaccessauditlog.FieldAffectedRows:
		return m.AffectedRows()
	case dataaccessauditlog.FieldLatencyMs:
		return m.LatencyMs()
	case dataaccessauditlog.FieldSuccess:
		return m.Success()
	case dataaccessauditlog.FieldSensitiveLevel:
		return m.SensitiveLevel()
	case dataaccessauditlog.FieldDataMasked:
		return m.DataMasked()
	case dataaccessauditlog.FieldMaskingRules:
		return m.MaskingRules()
	case dataaccessauditlog.FieldBusinessPurpose:
		return m.BusinessPurpose()
	case dataaccessauditlog.FieldDataCategory:
		return m.DataCategory()
	case dataaccessauditlog.FieldDbUser:
		return m.DbUser()
	case dataaccessauditlog.FieldLogHash:
		return m.LogHash()
	case dataaccessauditlog.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DataAccessAuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dataaccessauditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dataaccessauditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case dataaccessauditlog.FieldUserID:
		return m.OldUserID(ctx)
	case dataaccessauditlog.FieldUsername:
		return m.OldUsername(ctx)
	case dataaccessauditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case dataaccessauditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case dataaccessauditlog.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case dataaccessauditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case dataaccessauditlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case dataaccessauditlog.FieldDataSource:
		return m.OldDataSource(ctx)
	case dataaccessauditlog.FieldTableName:
		return m.OldTableName(ctx)
	case dataaccessauditlog.FieldDataID:
		return m.OldDataID(ctx)
	case dataaccessauditlog.FieldAccessType:
		return m.OldAccessType(ctx)
	case dataaccessauditlog.FieldSQLDigest:
		return m.OldSQLDigest(ctx)
	case dataaccessauditlog.FieldSQLText:
		return m.OldSQLText(ctx)
	case dataaccessauditlog.FieldAffectedRows:
		return m.OldAffectedRows(ctx)
	case dataaccessauditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case dataaccessauditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case dataaccessauditlog.FieldSensitiveLevel:
		return m.OldSensitiveLevel(ctx)
	case dataaccessauditlog.FieldDataMasked:
		return m.OldDataMasked(ctx)
	case dataaccessauditlog.FieldMaskingRules:
		return m.OldMaskingRules(ctx)
	case dataaccessauditlog.FieldBusinessPurpose:
		return m.OldBusinessPurpose(ctx)
	case dataaccessauditlog.FieldDataCategory:
		return m.OldDataCategory(ctx)
	case dataaccessauditlog.FieldDbUser:
		return m.OldDbUser(ctx)
	case dataaccessauditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case dataaccessauditlog.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown DataAccessAuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataAccessAuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dataaccessauditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dataaccessauditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dataaccessauditlog.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case dataaccessauditlog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case dataaccessauditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case dataaccessauditlog.FieldGeoLocation:
		v, ok := value.(*auditpb.GeoLocation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case dataaccessauditlog.FieldDeviceInfo:
		v, ok := value.(*auditpb.DeviceInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case dataaccessauditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case dataaccessauditlog.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case dataaccessauditlog.FieldDataSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataSource(v)
		return nil
	case dataaccessauditlog.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case dataaccessauditlog.FieldDataID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataID(v)
		return nil
	case dataaccessauditlog.FieldAccessType:
		v, ok := value.(dataaccessauditlog.AccessType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessType(v)
		return nil
	case dataaccessauditlog.FieldSQLDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSQLDigest(v)
		return nil
	case dataaccessauditlog.FieldSQLText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSQLText(v)
		return nil
	case dataaccessauditlog.FieldAffectedRows:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffectedRows(v)
		return nil
	case dataaccessauditlog.FieldLatencyMs:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case dataaccessauditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case dataaccessauditlog.FieldSensitiveLevel:
		v, ok := value.(dataaccessauditlog.SensitiveLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitiveLevel(v)
		return nil
	case dataaccessauditlog.FieldDataMasked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataMasked(v)
		return nil
	case dataaccessauditlog.FieldMaskingRules:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaskingRules(v)
		return nil
	case dataaccessauditlog.FieldBusinessPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessPurpose(v)
		return nil
	case dataaccessauditlog.FieldDataCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataCategory(v)
		return nil
	case dataaccessauditlog.FieldDbUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbUser(v)
		return nil
	case dataaccessauditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case dataaccessauditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown DataAccessAuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DataAccessAuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, dataaccessauditlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, dataaccessauditlog.FieldUserID)
	}
	if m.addaffected_rows != nil {
		fields = append(fields, dataaccessauditlog.FieldAffectedRows)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, dataaccessauditlog.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DataAccessAuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dataaccessauditlog.FieldTenantID:
		return m.AddedTenantID()
	case dataaccessauditlog.FieldUserID:
		return m.AddedUserID()
	case dataaccessauditlog.FieldAffectedRows:
		return m.AddedAffectedRows()
	case dataaccessauditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataAccessAuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dataaccessauditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case dataaccessauditlog.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case dataaccessauditlog.FieldAffectedRows:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAffectedRows(v)
		return nil
	case dataaccessauditlog.FieldLatencyMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown DataAccessAuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DataAccessAuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dataaccessauditlog.FieldCreatedAt) {
		fields = append(fields, dataaccessauditlog.FieldCreatedAt)
	}
	if m.FieldCleared(dataaccessauditlog.FieldTenantID) {
		fields = append(fields, dataaccessauditlog.FieldTenantID)
	}
	if m.FieldCleared(dataaccessauditlog.FieldUserID) {
		fields = append(fields, dataaccessauditlog.FieldUserID)
	}
	if m.FieldCleared(dataaccessauditlog.FieldUsername) {
		fields = append(fields, dataaccessauditlog.FieldUsername)
	}
	if m.FieldCleared(dataaccessauditlog.FieldIPAddress) {
		fields = append(fields, dataaccessauditlog.FieldIPAddress)
	}
	if m.FieldCleared(dataaccessauditlog.FieldGeoLocation) {
		fields = append(fields, dataaccessauditlog.FieldGeoLocation)
	}
	if m.FieldCleared(dataaccessauditlog.FieldDeviceInfo) {
		fields = append(fields, dataaccessauditlog.FieldDeviceInfo)
	}
	if m.FieldCleared(dataaccessauditlog.FieldRequestID) {
		fields = append(fields, dataaccessauditlog.FieldRequestID)
	}
	if m.FieldCleared(dataaccessauditlog.FieldTraceID) {
		fields = append(fields, dataaccessauditlog.FieldTraceID)
	}
	if m.FieldCleared(dataaccessauditlog.FieldDataSource) {
		fields = append(fields, dataaccessauditlog.FieldDataSource)
	}
	if m.FieldCleared(dataaccessauditlog.FieldTableName) {
		fields = append(fields, dataaccessauditlog.FieldTableName)
	}
	if m.FieldCleared(dataaccessauditlog.FieldDataID) {
		fields = append(fields, dataaccessauditlog.FieldDataID)
	}
	if m.FieldCleared(dataaccessauditlog.FieldAccessType) {
		fields = append(fields, dataaccessauditlog.FieldAccessType)
	}
	if m.FieldCleared(dataaccessauditlog.FieldSQLDigest) {
		fields = append(fields, dataaccessauditlog.FieldSQLDigest)
	}
	if m.FieldCleared(dataaccessauditlog.FieldSQLText) {
		fields = append(fields, dataaccessauditlog.FieldSQLText)
	}
	if m.FieldCleared(dataaccessauditlog.FieldAffectedRows) {
		fields = append(fields, dataaccessauditlog.FieldAffectedRows)
	}
	if m.FieldCleared(dataaccessauditlog.FieldLatencyMs) {
		fields = append(fields, dataaccessauditlog.FieldLatencyMs)
	}
	if m.FieldCleared(dataaccessauditlog.FieldSuccess) {
		fields = append(fields, dataaccessauditlog.FieldSuccess)
	}
	if m.FieldCleared(dataaccessauditlog.FieldSensitiveLevel) {
		fields = append(fields, dataaccessauditlog.FieldSensitiveLevel)
	}
	if m.FieldCleared(dataaccessauditlog.FieldDataMasked) {
		fields = append(fields, dataaccessauditlog.FieldDataMasked)
	}
	if m.FieldCleared(dataaccessauditlog.FieldMaskingRules) {
		fields = append(fields, dataaccessauditlog.FieldMaskingRules)
	}
	if m.FieldCleared(dataaccessauditlog.FieldBusinessPurpose) {
		fields = append(fields, dataaccessauditlog.FieldBusinessPurpose)
	}
	if m.FieldCleared(dataaccessauditlog.FieldDataCategory) {
		fields = append(fields, dataaccessauditlog.FieldDataCategory)
	}
	if m.FieldCleared(dataaccessauditlog.FieldDbUser) {
		fields = append(fields, dataaccessauditlog.FieldDbUser)
	}
	if m.FieldCleared(dataaccessauditlog.FieldLogHash) {
		fields = append(fields, dataaccessauditlog.FieldLogHash)
	}
	if m.FieldCleared(dataaccessauditlog.FieldSignature) {
		fields = append(fields, dataaccessauditlog.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DataAccessAuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataAccessAuditLogMutation) ClearField(name string) error {
	switch name {
	case dataaccessauditlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dataaccessauditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case dataaccessauditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case dataaccessauditlog.FieldUsername:
		m.ClearUsername()
		return nil
	case dataaccessauditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case dataaccessauditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case dataaccessauditlog.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case dataaccessauditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case dataaccessauditlog.FieldTraceID:
		m.ClearTraceID()
		return nil
	case dataaccessauditlog.FieldDataSource:
		m.ClearDataSource()
		return nil
	case dataaccessauditlog.FieldTableName:
		m.ClearTableName()
		return nil
	case dataaccessauditlog.FieldDataID:
		m.ClearDataID()
		return nil
	case dataaccessauditlog.FieldAccessType:
		m.ClearAccessType()
		return nil
	case dataaccessauditlog.FieldSQLDigest:
		m.ClearSQLDigest()
		return nil
	case dataaccessauditlog.FieldSQLText:
		m.ClearSQLText()
		return nil
	case dataaccessauditlog.FieldAffectedRows:
		m.ClearAffectedRows()
		return nil
	case dataaccessauditlog.FieldLatencyMs:
		m.ClearLatencyMs()
		return nil
	case dataaccessauditlog.FieldSuccess:
		m.ClearSuccess()
		return nil
	case dataaccessauditlog.FieldSensitiveLevel:
		m.ClearSensitiveLevel()
		return nil
	case dataaccessauditlog.FieldDataMasked:
		m.ClearDataMasked()
		return nil
	case dataaccessauditlog.FieldMaskingRules:
		m.ClearMaskingRules()
		return nil
	case dataaccessauditlog.FieldBusinessPurpose:
		m.ClearBusinessPurpose()
		return nil
	case dataaccessauditlog.FieldDataCategory:
		m.ClearDataCategory()
		return nil
	case dataaccessauditlog.FieldDbUser:
		m.ClearDbUser()
		return nil
	case dataaccessauditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case dataaccessauditlog.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown DataAccessAuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DataAccessAuditLogMutation) ResetField(name string) error {
	switch name {
	case dataaccessauditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dataaccessauditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dataaccessauditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case dataaccessauditlog.FieldUsername:
		m.ResetUsername()
		return nil
	case dataaccessauditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case dataaccessauditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case dataaccessauditlog.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case dataaccessauditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case dataaccessauditlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case dataaccessauditlog.FieldDataSource:
		m.ResetDataSource()
		return nil
	case dataaccessauditlog.FieldTableName:
		m.ResetTableName()
		return nil
	case dataaccessauditlog.FieldDataID:
		m.ResetDataID()
		return nil
	case dataaccessauditlog.FieldAccessType:
		m.ResetAccessType()
		return nil
	case dataaccessauditlog.FieldSQLDigest:
		m.ResetSQLDigest()
		return nil
	case dataaccessauditlog.FieldSQLText:
		m.ResetSQLText()
		return nil
	case dataaccessauditlog.FieldAffectedRows:
		m.ResetAffectedRows()
		return nil
	case dataaccessauditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case dataaccessauditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case dataaccessauditlog.FieldSensitiveLevel:
		m.ResetSensitiveLevel()
		return nil
	case dataaccessauditlog.FieldDataMasked:
		m.ResetDataMasked()
		return nil
	case dataaccessauditlog.FieldMaskingRules:
		m.ResetMaskingRules()
		return nil
	case dataaccessauditlog.FieldBusinessPurpose:
		m.ResetBusinessPurpose()
		return nil
	case dataaccessauditlog.FieldDataCategory:
		m.ResetDataCategory()
		return nil
	case dataaccessauditlog.FieldDbUser:
		m.ResetDbUser()
		return nil
	case dataaccessauditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case dataaccessauditlog.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown DataAccessAuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DataAccessAuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DataAccessAuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DataAccessAuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DataAccessAuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DataAccessAuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DataAccessAuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DataAccessAuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DataAccessAuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DataAccessAuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DataAccessAuditLog edge %s", name)
}

// DictEntryMutation represents an operation that mutates the DictEntry nodes in the graph.
type DictEntryMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	sort_order       *uint32
	addsort_order    *int32
	is_enabled       *bool
	tenant_id        *uint32
	addtenant_id     *int32
	entry_value      *string
	numeric_value    *int32
	addnumeric_value *int32
	clearedFields    map[string]struct{}
	dict_type        *uint32
	cleareddict_type bool
	i18ns            map[uint32]struct{}
	removedi18ns     map[uint32]struct{}
	clearedi18ns     bool
	done             bool
	oldValue         func(context.Context) (*DictEntry, error)
	predicates       []predicate.DictEntry
}

var _ ent.Mutation = (*DictEntryMutation)(nil)

// dictentryOption allows management of the mutation configuration using functional options.
type dictentryOption func(*DictEntryMutation)

// newDictEntryMutation creates new mutation for the DictEntry entity.
func newDictEntryMutation(c config, op Op, opts ...dictentryOption) *DictEntryMutation {
	m := &DictEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictEntryID sets the ID field of the mutation.
func withDictEntryID(id uint32) dictentryOption {
	return func(m *DictEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *DictEntry
		)
		m.oldValue = func(ctx context.Context) (*DictEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictEntry sets the old DictEntry of the mutation.
func withDictEntry(node *DictEntry) dictentryOption {
	return func(m *DictEntryMutation) {
		m.oldValue = func(context.Context) (*DictEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictEntry entities.
func (m *DictEntryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictEntryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictEntryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictEntryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictentry.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictEntryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictEntryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictentry.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictEntryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictEntryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictentry.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictEntryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictEntryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictentry.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DictEntryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DictEntryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DictEntryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dictentry.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DictEntryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DictEntryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dictentry.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DictEntryMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DictEntryMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *DictEntryMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DictEntryMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DictEntryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[dictentry.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DictEntryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DictEntryMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, dictentry.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DictEntryMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DictEntryMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *DictEntryMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DictEntryMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DictEntryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[dictentry.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DictEntryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DictEntryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, dictentry.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DictEntryMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DictEntryMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *DictEntryMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *DictEntryMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DictEntryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[dictentry.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DictEntryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DictEntryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, dictentry.FieldDeletedBy)
}

// SetSortOrder sets the "sort_order" field.
func (m *DictEntryMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *DictEntryMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *DictEntryMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *DictEntryMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *DictEntryMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[dictentry.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *DictEntryMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *DictEntryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, dictentry.FieldSortOrder)
}

// SetIsEnabled sets the "is_enabled" field.
func (m *DictEntryMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *DictEntryMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldIsEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ClearIsEnabled clears the value of the "is_enabled" field.
func (m *DictEntryMutation) ClearIsEnabled() {
	m.is_enabled = nil
	m.clearedFields[dictentry.FieldIsEnabled] = struct{}{}
}

// IsEnabledCleared returns if the "is_enabled" field was cleared in this mutation.
func (m *DictEntryMutation) IsEnabledCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldIsEnabled]
	return ok
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *DictEntryMutation) ResetIsEnabled() {
	m.is_enabled = nil
	delete(m.clearedFields, dictentry.FieldIsEnabled)
}

// SetTenantID sets the "tenant_id" field.
func (m *DictEntryMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DictEntryMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DictEntryMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DictEntryMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DictEntryMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[dictentry.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DictEntryMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DictEntryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, dictentry.FieldTenantID)
}

// SetEntryValue sets the "entry_value" field.
func (m *DictEntryMutation) SetEntryValue(s string) {
	m.entry_value = &s
}

// EntryValue returns the value of the "entry_value" field in the mutation.
func (m *DictEntryMutation) EntryValue() (r string, exists bool) {
	v := m.entry_value
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryValue returns the old "entry_value" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldEntryValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryValue: %w", err)
	}
	return oldValue.EntryValue, nil
}

// ResetEntryValue resets all changes to the "entry_value" field.
func (m *DictEntryMutation) ResetEntryValue() {
	m.entry_value = nil
}

// SetNumericValue sets the "numeric_value" field.
func (m *DictEntryMutation) SetNumericValue(i int32) {
	m.numeric_value = &i
	m.addnumeric_value = nil
}

// NumericValue returns the value of the "numeric_value" field in the mutation.
func (m *DictEntryMutation) NumericValue() (r int32, exists bool) {
	v := m.numeric_value
	if v == nil {
		return
	}
	return *v, true
}

// OldNumericValue returns the old "numeric_value" field's value of the DictEntry entity.
// If the DictEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryMutation) OldNumericValue(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumericValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumericValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumericValue: %w", err)
	}
	return oldValue.NumericValue, nil
}

// AddNumericValue adds i to the "numeric_value" field.
func (m *DictEntryMutation) AddNumericValue(i int32) {
	if m.addnumeric_value != nil {
		*m.addnumeric_value += i
	} else {
		m.addnumeric_value = &i
	}
}

// AddedNumericValue returns the value that was added to the "numeric_value" field in this mutation.
func (m *DictEntryMutation) AddedNumericValue() (r int32, exists bool) {
	v := m.addnumeric_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumericValue clears the value of the "numeric_value" field.
func (m *DictEntryMutation) ClearNumericValue() {
	m.numeric_value = nil
	m.addnumeric_value = nil
	m.clearedFields[dictentry.FieldNumericValue] = struct{}{}
}

// NumericValueCleared returns if the "numeric_value" field was cleared in this mutation.
func (m *DictEntryMutation) NumericValueCleared() bool {
	_, ok := m.clearedFields[dictentry.FieldNumericValue]
	return ok
}

// ResetNumericValue resets all changes to the "numeric_value" field.
func (m *DictEntryMutation) ResetNumericValue() {
	m.numeric_value = nil
	m.addnumeric_value = nil
	delete(m.clearedFields, dictentry.FieldNumericValue)
}

// SetDictTypeID sets the "dict_type" edge to the DictType entity by id.
func (m *DictEntryMutation) SetDictTypeID(id uint32) {
	m.dict_type = &id
}

// ClearDictType clears the "dict_type" edge to the DictType entity.
func (m *DictEntryMutation) ClearDictType() {
	m.cleareddict_type = true
}

// DictTypeCleared reports if the "dict_type" edge to the DictType entity was cleared.
func (m *DictEntryMutation) DictTypeCleared() bool {
	return m.cleareddict_type
}

// DictTypeID returns the "dict_type" edge ID in the mutation.
func (m *DictEntryMutation) DictTypeID() (id uint32, exists bool) {
	if m.dict_type != nil {
		return *m.dict_type, true
	}
	return
}

// DictTypeIDs returns the "dict_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictTypeID instead. It exists only for internal usage by the builders.
func (m *DictEntryMutation) DictTypeIDs() (ids []uint32) {
	if id := m.dict_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictType resets all changes to the "dict_type" edge.
func (m *DictEntryMutation) ResetDictType() {
	m.dict_type = nil
	m.cleareddict_type = false
}

// AddI18nIDs adds the "i18ns" edge to the DictEntryI18n entity by ids.
func (m *DictEntryMutation) AddI18nIDs(ids ...uint32) {
	if m.i18ns == nil {
		m.i18ns = make(map[uint32]struct{})
	}
	for i := range ids {
		m.i18ns[ids[i]] = struct{}{}
	}
}

// ClearI18ns clears the "i18ns" edge to the DictEntryI18n entity.
func (m *DictEntryMutation) ClearI18ns() {
	m.clearedi18ns = true
}

// I18nsCleared reports if the "i18ns" edge to the DictEntryI18n entity was cleared.
func (m *DictEntryMutation) I18nsCleared() bool {
	return m.clearedi18ns
}

// RemoveI18nIDs removes the "i18ns" edge to the DictEntryI18n entity by IDs.
func (m *DictEntryMutation) RemoveI18nIDs(ids ...uint32) {
	if m.removedi18ns == nil {
		m.removedi18ns = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.i18ns, ids[i])
		m.removedi18ns[ids[i]] = struct{}{}
	}
}

// RemovedI18ns returns the removed IDs of the "i18ns" edge to the DictEntryI18n entity.
func (m *DictEntryMutation) RemovedI18nsIDs() (ids []uint32) {
	for id := range m.removedi18ns {
		ids = append(ids, id)
	}
	return
}

// I18nsIDs returns the "i18ns" edge IDs in the mutation.
func (m *DictEntryMutation) I18nsIDs() (ids []uint32) {
	for id := range m.i18ns {
		ids = append(ids, id)
	}
	return
}

// ResetI18ns resets all changes to the "i18ns" edge.
func (m *DictEntryMutation) ResetI18ns() {
	m.i18ns = nil
	m.clearedi18ns = false
	m.removedi18ns = nil
}

// Where appends a list predicates to the DictEntryMutation builder.
func (m *DictEntryMutation) Where(ps ...predicate.DictEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictEntry).
func (m *DictEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictEntryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, dictentry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictentry.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dictentry.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dictentry.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, dictentry.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, dictentry.FieldDeletedBy)
	}
	if m.sort_order != nil {
		fields = append(fields, dictentry.FieldSortOrder)
	}
	if m.is_enabled != nil {
		fields = append(fields, dictentry.FieldIsEnabled)
	}
	if m.tenant_id != nil {
		fields = append(fields, dictentry.FieldTenantID)
	}
	if m.entry_value != nil {
		fields = append(fields, dictentry.FieldEntryValue)
	}
	if m.numeric_value != nil {
		fields = append(fields, dictentry.FieldNumericValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictentry.FieldCreatedAt:
		return m.CreatedAt()
	case dictentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictentry.FieldDeletedAt:
		return m.DeletedAt()
	case dictentry.FieldCreatedBy:
		return m.CreatedBy()
	case dictentry.FieldUpdatedBy:
		return m.UpdatedBy()
	case dictentry.FieldDeletedBy:
		return m.DeletedBy()
	case dictentry.FieldSortOrder:
		return m.SortOrder()
	case dictentry.FieldIsEnabled:
		return m.IsEnabled()
	case dictentry.FieldTenantID:
		return m.TenantID()
	case dictentry.FieldEntryValue:
		return m.EntryValue()
	case dictentry.FieldNumericValue:
		return m.NumericValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictentry.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dictentry.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dictentry.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case dictentry.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case dictentry.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case dictentry.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case dictentry.FieldTenantID:
		return m.OldTenantID(ctx)
	case dictentry.FieldEntryValue:
		return m.OldEntryValue(ctx)
	case dictentry.FieldNumericValue:
		return m.OldNumericValue(ctx)
	}
	return nil, fmt.Errorf("unknown DictEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictentry.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dictentry.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dictentry.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case dictentry.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case dictentry.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case dictentry.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case dictentry.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dictentry.FieldEntryValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryValue(v)
		return nil
	case dictentry.FieldNumericValue:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumericValue(v)
		return nil
	}
	return fmt.Errorf("unknown DictEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictEntryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, dictentry.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, dictentry.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, dictentry.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, dictentry.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, dictentry.FieldTenantID)
	}
	if m.addnumeric_value != nil {
		fields = append(fields, dictentry.FieldNumericValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictentry.FieldCreatedBy:
		return m.AddedCreatedBy()
	case dictentry.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case dictentry.FieldDeletedBy:
		return m.AddedDeletedBy()
	case dictentry.FieldSortOrder:
		return m.AddedSortOrder()
	case dictentry.FieldTenantID:
		return m.AddedTenantID()
	case dictentry.FieldNumericValue:
		return m.AddedNumericValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictentry.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case dictentry.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case dictentry.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case dictentry.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case dictentry.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case dictentry.FieldNumericValue:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumericValue(v)
		return nil
	}
	return fmt.Errorf("unknown DictEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictentry.FieldCreatedAt) {
		fields = append(fields, dictentry.FieldCreatedAt)
	}
	if m.FieldCleared(dictentry.FieldUpdatedAt) {
		fields = append(fields, dictentry.FieldUpdatedAt)
	}
	if m.FieldCleared(dictentry.FieldDeletedAt) {
		fields = append(fields, dictentry.FieldDeletedAt)
	}
	if m.FieldCleared(dictentry.FieldCreatedBy) {
		fields = append(fields, dictentry.FieldCreatedBy)
	}
	if m.FieldCleared(dictentry.FieldUpdatedBy) {
		fields = append(fields, dictentry.FieldUpdatedBy)
	}
	if m.FieldCleared(dictentry.FieldDeletedBy) {
		fields = append(fields, dictentry.FieldDeletedBy)
	}
	if m.FieldCleared(dictentry.FieldSortOrder) {
		fields = append(fields, dictentry.FieldSortOrder)
	}
	if m.FieldCleared(dictentry.FieldIsEnabled) {
		fields = append(fields, dictentry.FieldIsEnabled)
	}
	if m.FieldCleared(dictentry.FieldTenantID) {
		fields = append(fields, dictentry.FieldTenantID)
	}
	if m.FieldCleared(dictentry.FieldNumericValue) {
		fields = append(fields, dictentry.FieldNumericValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictEntryMutation) ClearField(name string) error {
	switch name {
	case dictentry.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictentry.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictentry.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dictentry.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case dictentry.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case dictentry.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case dictentry.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case dictentry.FieldIsEnabled:
		m.ClearIsEnabled()
		return nil
	case dictentry.FieldTenantID:
		m.ClearTenantID()
		return nil
	case dictentry.FieldNumericValue:
		m.ClearNumericValue()
		return nil
	}
	return fmt.Errorf("unknown DictEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictEntryMutation) ResetField(name string) error {
	switch name {
	case dictentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictentry.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dictentry.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dictentry.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case dictentry.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case dictentry.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case dictentry.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case dictentry.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dictentry.FieldEntryValue:
		m.ResetEntryValue()
		return nil
	case dictentry.FieldNumericValue:
		m.ResetNumericValue()
		return nil
	}
	return fmt.Errorf("unknown DictEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.dict_type != nil {
		edges = append(edges, dictentry.EdgeDictType)
	}
	if m.i18ns != nil {
		edges = append(edges, dictentry.EdgeI18ns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictentry.EdgeDictType:
		if id := m.dict_type; id != nil {
			return []ent.Value{*id}
		}
	case dictentry.EdgeI18ns:
		ids := make([]ent.Value, 0, len(m.i18ns))
		for id := range m.i18ns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedi18ns != nil {
		edges = append(edges, dictentry.EdgeI18ns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictentry.EdgeI18ns:
		ids := make([]ent.Value, 0, len(m.removedi18ns))
		for id := range m.removedi18ns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddict_type {
		edges = append(edges, dictentry.EdgeDictType)
	}
	if m.clearedi18ns {
		edges = append(edges, dictentry.EdgeI18ns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictentry.EdgeDictType:
		return m.cleareddict_type
	case dictentry.EdgeI18ns:
		return m.clearedi18ns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictEntryMutation) ClearEdge(name string) error {
	switch name {
	case dictentry.EdgeDictType:
		m.ClearDictType()
		return nil
	}
	return fmt.Errorf("unknown DictEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictEntryMutation) ResetEdge(name string) error {
	switch name {
	case dictentry.EdgeDictType:
		m.ResetDictType()
		return nil
	case dictentry.EdgeI18ns:
		m.ResetI18ns()
		return nil
	}
	return fmt.Errorf("unknown DictEntry edge %s", name)
}

// DictEntryI18nMutation represents an operation that mutates the DictEntryI18n nodes in the graph.
type DictEntryI18nMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	created_by        *uint32
	addcreated_by     *int32
	updated_by        *uint32
	addupdated_by     *int32
	deleted_by        *uint32
	adddeleted_by     *int32
	description       *string
	sort_order        *uint32
	addsort_order     *int32
	tenant_id         *uint32
	addtenant_id      *int32
	language_code     *string
	entry_label       *string
	clearedFields     map[string]struct{}
	dict_entry        *uint32
	cleareddict_entry bool
	done              bool
	oldValue          func(context.Context) (*DictEntryI18n, error)
	predicates        []predicate.DictEntryI18n
}

var _ ent.Mutation = (*DictEntryI18nMutation)(nil)

// dictentryi18nOption allows management of the mutation configuration using functional options.
type dictentryi18nOption func(*DictEntryI18nMutation)

// newDictEntryI18nMutation creates new mutation for the DictEntryI18n entity.
func newDictEntryI18nMutation(c config, op Op, opts ...dictentryi18nOption) *DictEntryI18nMutation {
	m := &DictEntryI18nMutation{
		config:        c,
		op:            op,
		typ:           TypeDictEntryI18n,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictEntryI18nID sets the ID field of the mutation.
func withDictEntryI18nID(id uint32) dictentryi18nOption {
	return func(m *DictEntryI18nMutation) {
		var (
			err   error
			once  sync.Once
			value *DictEntryI18n
		)
		m.oldValue = func(ctx context.Context) (*DictEntryI18n, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictEntryI18n.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictEntryI18n sets the old DictEntryI18n of the mutation.
func withDictEntryI18n(node *DictEntryI18n) dictentryi18nOption {
	return func(m *DictEntryI18nMutation) {
		m.oldValue = func(context.Context) (*DictEntryI18n, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictEntryI18nMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictEntryI18nMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictEntryI18n entities.
func (m *DictEntryI18nMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictEntryI18nMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictEntryI18nMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictEntryI18n.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictEntryI18nMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictEntryI18nMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictEntryI18nMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictentryi18n.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictEntryI18nMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictEntryI18nMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictentryi18n.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictEntryI18nMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictEntryI18nMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictEntryI18nMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictentryi18n.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictEntryI18nMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictEntryI18nMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictentryi18n.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DictEntryI18nMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DictEntryI18nMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DictEntryI18nMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dictentryi18n.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DictEntryI18nMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DictEntryI18nMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dictentryi18n.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DictEntryI18nMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DictEntryI18nMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *DictEntryI18nMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DictEntryI18nMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DictEntryI18nMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[dictentryi18n.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DictEntryI18nMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DictEntryI18nMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, dictentryi18n.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DictEntryI18nMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DictEntryI18nMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *DictEntryI18nMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DictEntryI18nMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DictEntryI18nMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[dictentryi18n.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DictEntryI18nMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DictEntryI18nMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, dictentryi18n.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DictEntryI18nMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DictEntryI18nMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *DictEntryI18nMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *DictEntryI18nMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DictEntryI18nMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[dictentryi18n.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DictEntryI18nMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DictEntryI18nMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, dictentryi18n.FieldDeletedBy)
}

// SetDescription sets the "description" field.
func (m *DictEntryI18nMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictEntryI18nMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DictEntryI18nMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[dictentryi18n.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DictEntryI18nMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DictEntryI18nMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, dictentryi18n.FieldDescription)
}

// SetSortOrder sets the "sort_order" field.
func (m *DictEntryI18nMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *DictEntryI18nMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *DictEntryI18nMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *DictEntryI18nMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *DictEntryI18nMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[dictentryi18n.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *DictEntryI18nMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *DictEntryI18nMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, dictentryi18n.FieldSortOrder)
}

// SetTenantID sets the "tenant_id" field.
func (m *DictEntryI18nMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DictEntryI18nMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DictEntryI18nMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DictEntryI18nMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DictEntryI18nMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[dictentryi18n.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DictEntryI18nMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DictEntryI18nMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, dictentryi18n.FieldTenantID)
}

// SetLanguageCode sets the "language_code" field.
func (m *DictEntryI18nMutation) SetLanguageCode(s string) {
	m.language_code = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *DictEntryI18nMutation) LanguageCode() (r string, exists bool) {
	v := m.language_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldLanguageCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ClearLanguageCode clears the value of the "language_code" field.
func (m *DictEntryI18nMutation) ClearLanguageCode() {
	m.language_code = nil
	m.clearedFields[dictentryi18n.FieldLanguageCode] = struct{}{}
}

// LanguageCodeCleared returns if the "language_code" field was cleared in this mutation.
func (m *DictEntryI18nMutation) LanguageCodeCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldLanguageCode]
	return ok
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *DictEntryI18nMutation) ResetLanguageCode() {
	m.language_code = nil
	delete(m.clearedFields, dictentryi18n.FieldLanguageCode)
}

// SetEntryLabel sets the "entry_label" field.
func (m *DictEntryI18nMutation) SetEntryLabel(s string) {
	m.entry_label = &s
}

// EntryLabel returns the value of the "entry_label" field in the mutation.
func (m *DictEntryI18nMutation) EntryLabel() (r string, exists bool) {
	v := m.entry_label
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryLabel returns the old "entry_label" field's value of the DictEntryI18n entity.
// If the DictEntryI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictEntryI18nMutation) OldEntryLabel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryLabel: %w", err)
	}
	return oldValue.EntryLabel, nil
}

// ClearEntryLabel clears the value of the "entry_label" field.
func (m *DictEntryI18nMutation) ClearEntryLabel() {
	m.entry_label = nil
	m.clearedFields[dictentryi18n.FieldEntryLabel] = struct{}{}
}

// EntryLabelCleared returns if the "entry_label" field was cleared in this mutation.
func (m *DictEntryI18nMutation) EntryLabelCleared() bool {
	_, ok := m.clearedFields[dictentryi18n.FieldEntryLabel]
	return ok
}

// ResetEntryLabel resets all changes to the "entry_label" field.
func (m *DictEntryI18nMutation) ResetEntryLabel() {
	m.entry_label = nil
	delete(m.clearedFields, dictentryi18n.FieldEntryLabel)
}

// SetDictEntryID sets the "dict_entry" edge to the DictEntry entity by id.
func (m *DictEntryI18nMutation) SetDictEntryID(id uint32) {
	m.dict_entry = &id
}

// ClearDictEntry clears the "dict_entry" edge to the DictEntry entity.
func (m *DictEntryI18nMutation) ClearDictEntry() {
	m.cleareddict_entry = true
}

// DictEntryCleared reports if the "dict_entry" edge to the DictEntry entity was cleared.
func (m *DictEntryI18nMutation) DictEntryCleared() bool {
	return m.cleareddict_entry
}

// DictEntryID returns the "dict_entry" edge ID in the mutation.
func (m *DictEntryI18nMutation) DictEntryID() (id uint32, exists bool) {
	if m.dict_entry != nil {
		return *m.dict_entry, true
	}
	return
}

// DictEntryIDs returns the "dict_entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictEntryID instead. It exists only for internal usage by the builders.
func (m *DictEntryI18nMutation) DictEntryIDs() (ids []uint32) {
	if id := m.dict_entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictEntry resets all changes to the "dict_entry" edge.
func (m *DictEntryI18nMutation) ResetDictEntry() {
	m.dict_entry = nil
	m.cleareddict_entry = false
}

// Where appends a list predicates to the DictEntryI18nMutation builder.
func (m *DictEntryI18nMutation) Where(ps ...predicate.DictEntryI18n) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictEntryI18nMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictEntryI18nMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictEntryI18n, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictEntryI18nMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictEntryI18nMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictEntryI18n).
func (m *DictEntryI18nMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictEntryI18nMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, dictentryi18n.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictentryi18n.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dictentryi18n.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dictentryi18n.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, dictentryi18n.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, dictentryi18n.FieldDeletedBy)
	}
	if m.description != nil {
		fields = append(fields, dictentryi18n.FieldDescription)
	}
	if m.sort_order != nil {
		fields = append(fields, dictentryi18n.FieldSortOrder)
	}
	if m.tenant_id != nil {
		fields = append(fields, dictentryi18n.FieldTenantID)
	}
	if m.language_code != nil {
		fields = append(fields, dictentryi18n.FieldLanguageCode)
	}
	if m.entry_label != nil {
		fields = append(fields, dictentryi18n.FieldEntryLabel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictEntryI18nMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictentryi18n.FieldCreatedAt:
		return m.CreatedAt()
	case dictentryi18n.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictentryi18n.FieldDeletedAt:
		return m.DeletedAt()
	case dictentryi18n.FieldCreatedBy:
		return m.CreatedBy()
	case dictentryi18n.FieldUpdatedBy:
		return m.UpdatedBy()
	case dictentryi18n.FieldDeletedBy:
		return m.DeletedBy()
	case dictentryi18n.FieldDescription:
		return m.Description()
	case dictentryi18n.FieldSortOrder:
		return m.SortOrder()
	case dictentryi18n.FieldTenantID:
		return m.TenantID()
	case dictentryi18n.FieldLanguageCode:
		return m.LanguageCode()
	case dictentryi18n.FieldEntryLabel:
		return m.EntryLabel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictEntryI18nMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictentryi18n.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictentryi18n.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictentryi18n.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dictentryi18n.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dictentryi18n.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case dictentryi18n.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case dictentryi18n.FieldDescription:
		return m.OldDescription(ctx)
	case dictentryi18n.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case dictentryi18n.FieldTenantID:
		return m.OldTenantID(ctx)
	case dictentryi18n.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case dictentryi18n.FieldEntryLabel:
		return m.OldEntryLabel(ctx)
	}
	return nil, fmt.Errorf("unknown DictEntryI18n field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictEntryI18nMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictentryi18n.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictentryi18n.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictentryi18n.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dictentryi18n.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dictentryi18n.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case dictentryi18n.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case dictentryi18n.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dictentryi18n.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case dictentryi18n.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dictentryi18n.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case dictentryi18n.FieldEntryLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryLabel(v)
		return nil
	}
	return fmt.Errorf("unknown DictEntryI18n field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictEntryI18nMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, dictentryi18n.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, dictentryi18n.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, dictentryi18n.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, dictentryi18n.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, dictentryi18n.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictEntryI18nMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictentryi18n.FieldCreatedBy:
		return m.AddedCreatedBy()
	case dictentryi18n.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case dictentryi18n.FieldDeletedBy:
		return m.AddedDeletedBy()
	case dictentryi18n.FieldSortOrder:
		return m.AddedSortOrder()
	case dictentryi18n.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictEntryI18nMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictentryi18n.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case dictentryi18n.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case dictentryi18n.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case dictentryi18n.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case dictentryi18n.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DictEntryI18n numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictEntryI18nMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictentryi18n.FieldCreatedAt) {
		fields = append(fields, dictentryi18n.FieldCreatedAt)
	}
	if m.FieldCleared(dictentryi18n.FieldUpdatedAt) {
		fields = append(fields, dictentryi18n.FieldUpdatedAt)
	}
	if m.FieldCleared(dictentryi18n.FieldDeletedAt) {
		fields = append(fields, dictentryi18n.FieldDeletedAt)
	}
	if m.FieldCleared(dictentryi18n.FieldCreatedBy) {
		fields = append(fields, dictentryi18n.FieldCreatedBy)
	}
	if m.FieldCleared(dictentryi18n.FieldUpdatedBy) {
		fields = append(fields, dictentryi18n.FieldUpdatedBy)
	}
	if m.FieldCleared(dictentryi18n.FieldDeletedBy) {
		fields = append(fields, dictentryi18n.FieldDeletedBy)
	}
	if m.FieldCleared(dictentryi18n.FieldDescription) {
		fields = append(fields, dictentryi18n.FieldDescription)
	}
	if m.FieldCleared(dictentryi18n.FieldSortOrder) {
		fields = append(fields, dictentryi18n.FieldSortOrder)
	}
	if m.FieldCleared(dictentryi18n.FieldTenantID) {
		fields = append(fields, dictentryi18n.FieldTenantID)
	}
	if m.FieldCleared(dictentryi18n.FieldLanguageCode) {
		fields = append(fields, dictentryi18n.FieldLanguageCode)
	}
	if m.FieldCleared(dictentryi18n.FieldEntryLabel) {
		fields = append(fields, dictentryi18n.FieldEntryLabel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictEntryI18nMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictEntryI18nMutation) ClearField(name string) error {
	switch name {
	case dictentryi18n.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictentryi18n.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictentryi18n.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dictentryi18n.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case dictentryi18n.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case dictentryi18n.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case dictentryi18n.FieldDescription:
		m.ClearDescription()
		return nil
	case dictentryi18n.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case dictentryi18n.FieldTenantID:
		m.ClearTenantID()
		return nil
	case dictentryi18n.FieldLanguageCode:
		m.ClearLanguageCode()
		return nil
	case dictentryi18n.FieldEntryLabel:
		m.ClearEntryLabel()
		return nil
	}
	return fmt.Errorf("unknown DictEntryI18n nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictEntryI18nMutation) ResetField(name string) error {
	switch name {
	case dictentryi18n.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictentryi18n.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictentryi18n.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dictentryi18n.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dictentryi18n.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case dictentryi18n.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case dictentryi18n.FieldDescription:
		m.ResetDescription()
		return nil
	case dictentryi18n.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case dictentryi18n.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dictentryi18n.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case dictentryi18n.FieldEntryLabel:
		m.ResetEntryLabel()
		return nil
	}
	return fmt.Errorf("unknown DictEntryI18n field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictEntryI18nMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dict_entry != nil {
		edges = append(edges, dictentryi18n.EdgeDictEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictEntryI18nMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictentryi18n.EdgeDictEntry:
		if id := m.dict_entry; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictEntryI18nMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictEntryI18nMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictEntryI18nMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddict_entry {
		edges = append(edges, dictentryi18n.EdgeDictEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictEntryI18nMutation) EdgeCleared(name string) bool {
	switch name {
	case dictentryi18n.EdgeDictEntry:
		return m.cleareddict_entry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictEntryI18nMutation) ClearEdge(name string) error {
	switch name {
	case dictentryi18n.EdgeDictEntry:
		m.ClearDictEntry()
		return nil
	}
	return fmt.Errorf("unknown DictEntryI18n unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictEntryI18nMutation) ResetEdge(name string) error {
	switch name {
	case dictentryi18n.EdgeDictEntry:
		m.ResetDictEntry()
		return nil
	}
	return fmt.Errorf("unknown DictEntryI18n edge %s", name)
}

// DictTypeMutation represents an operation that mutates the DictType nodes in the graph.
type DictTypeMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	created_by     *uint32
	addcreated_by  *int32
	updated_by     *uint32
	addupdated_by  *int32
	deleted_by     *uint32
	adddeleted_by  *int32
	is_enabled     *bool
	sort_order     *uint32
	addsort_order  *int32
	tenant_id      *uint32
	addtenant_id   *int32
	type_code      *string
	clearedFields  map[string]struct{}
	entries        map[uint32]struct{}
	removedentries map[uint32]struct{}
	clearedentries bool
	i18ns          map[uint32]struct{}
	removedi18ns   map[uint32]struct{}
	clearedi18ns   bool
	done           bool
	oldValue       func(context.Context) (*DictType, error)
	predicates     []predicate.DictType
}

var _ ent.Mutation = (*DictTypeMutation)(nil)

// dicttypeOption allows management of the mutation configuration using functional options.
type dicttypeOption func(*DictTypeMutation)

// newDictTypeMutation creates new mutation for the DictType entity.
func newDictTypeMutation(c config, op Op, opts ...dicttypeOption) *DictTypeMutation {
	m := &DictTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDictType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictTypeID sets the ID field of the mutation.
func withDictTypeID(id uint32) dicttypeOption {
	return func(m *DictTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DictType
		)
		m.oldValue = func(ctx context.Context) (*DictType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictType sets the old DictType of the mutation.
func withDictType(node *DictType) dicttypeOption {
	return func(m *DictTypeMutation) {
		m.oldValue = func(context.Context) (*DictType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictType entities.
func (m *DictTypeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictTypeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictTypeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictTypeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dicttype.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictTypeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictTypeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dicttype.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictTypeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dicttype.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictTypeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dicttype.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DictTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DictTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DictTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dicttype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DictTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DictTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dicttype.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DictTypeMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DictTypeMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *DictTypeMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DictTypeMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DictTypeMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[dicttype.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DictTypeMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DictTypeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, dicttype.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DictTypeMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DictTypeMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *DictTypeMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DictTypeMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DictTypeMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[dicttype.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DictTypeMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DictTypeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, dicttype.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DictTypeMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DictTypeMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *DictTypeMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *DictTypeMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DictTypeMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[dicttype.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DictTypeMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DictTypeMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, dicttype.FieldDeletedBy)
}

// SetIsEnabled sets the "is_enabled" field.
func (m *DictTypeMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *DictTypeMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldIsEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ClearIsEnabled clears the value of the "is_enabled" field.
func (m *DictTypeMutation) ClearIsEnabled() {
	m.is_enabled = nil
	m.clearedFields[dicttype.FieldIsEnabled] = struct{}{}
}

// IsEnabledCleared returns if the "is_enabled" field was cleared in this mutation.
func (m *DictTypeMutation) IsEnabledCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldIsEnabled]
	return ok
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *DictTypeMutation) ResetIsEnabled() {
	m.is_enabled = nil
	delete(m.clearedFields, dicttype.FieldIsEnabled)
}

// SetSortOrder sets the "sort_order" field.
func (m *DictTypeMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *DictTypeMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *DictTypeMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *DictTypeMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *DictTypeMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[dicttype.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *DictTypeMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *DictTypeMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, dicttype.FieldSortOrder)
}

// SetTenantID sets the "tenant_id" field.
func (m *DictTypeMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DictTypeMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DictTypeMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DictTypeMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DictTypeMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[dicttype.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DictTypeMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DictTypeMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, dicttype.FieldTenantID)
}

// SetTypeCode sets the "type_code" field.
func (m *DictTypeMutation) SetTypeCode(s string) {
	m.type_code = &s
}

// TypeCode returns the value of the "type_code" field in the mutation.
func (m *DictTypeMutation) TypeCode() (r string, exists bool) {
	v := m.type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "type_code" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldTypeCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ClearTypeCode clears the value of the "type_code" field.
func (m *DictTypeMutation) ClearTypeCode() {
	m.type_code = nil
	m.clearedFields[dicttype.FieldTypeCode] = struct{}{}
}

// TypeCodeCleared returns if the "type_code" field was cleared in this mutation.
func (m *DictTypeMutation) TypeCodeCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldTypeCode]
	return ok
}

// ResetTypeCode resets all changes to the "type_code" field.
func (m *DictTypeMutation) ResetTypeCode() {
	m.type_code = nil
	delete(m.clearedFields, dicttype.FieldTypeCode)
}

// AddEntryIDs adds the "entries" edge to the DictEntry entity by ids.
func (m *DictTypeMutation) AddEntryIDs(ids ...uint32) {
	if m.entries == nil {
		m.entries = make(map[uint32]struct{})
	}
	for i := range ids {
		m.entries[ids[i]] = struct{}{}
	}
}

// ClearEntries clears the "entries" edge to the DictEntry entity.
func (m *DictTypeMutation) ClearEntries() {
	m.clearedentries = true
}

// EntriesCleared reports if the "entries" edge to the DictEntry entity was cleared.
func (m *DictTypeMutation) EntriesCleared() bool {
	return m.clearedentries
}

// RemoveEntryIDs removes the "entries" edge to the DictEntry entity by IDs.
func (m *DictTypeMutation) RemoveEntryIDs(ids ...uint32) {
	if m.removedentries == nil {
		m.removedentries = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.entries, ids[i])
		m.removedentries[ids[i]] = struct{}{}
	}
}

// RemovedEntries returns the removed IDs of the "entries" edge to the DictEntry entity.
func (m *DictTypeMutation) RemovedEntriesIDs() (ids []uint32) {
	for id := range m.removedentries {
		ids = append(ids, id)
	}
	return
}

// EntriesIDs returns the "entries" edge IDs in the mutation.
func (m *DictTypeMutation) EntriesIDs() (ids []uint32) {
	for id := range m.entries {
		ids = append(ids, id)
	}
	return
}

// ResetEntries resets all changes to the "entries" edge.
func (m *DictTypeMutation) ResetEntries() {
	m.entries = nil
	m.clearedentries = false
	m.removedentries = nil
}

// AddI18nIDs adds the "i18ns" edge to the DictTypeI18n entity by ids.
func (m *DictTypeMutation) AddI18nIDs(ids ...uint32) {
	if m.i18ns == nil {
		m.i18ns = make(map[uint32]struct{})
	}
	for i := range ids {
		m.i18ns[ids[i]] = struct{}{}
	}
}

// ClearI18ns clears the "i18ns" edge to the DictTypeI18n entity.
func (m *DictTypeMutation) ClearI18ns() {
	m.clearedi18ns = true
}

// I18nsCleared reports if the "i18ns" edge to the DictTypeI18n entity was cleared.
func (m *DictTypeMutation) I18nsCleared() bool {
	return m.clearedi18ns
}

// RemoveI18nIDs removes the "i18ns" edge to the DictTypeI18n entity by IDs.
func (m *DictTypeMutation) RemoveI18nIDs(ids ...uint32) {
	if m.removedi18ns == nil {
		m.removedi18ns = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.i18ns, ids[i])
		m.removedi18ns[ids[i]] = struct{}{}
	}
}

// RemovedI18ns returns the removed IDs of the "i18ns" edge to the DictTypeI18n entity.
func (m *DictTypeMutation) RemovedI18nsIDs() (ids []uint32) {
	for id := range m.removedi18ns {
		ids = append(ids, id)
	}
	return
}

// I18nsIDs returns the "i18ns" edge IDs in the mutation.
func (m *DictTypeMutation) I18nsIDs() (ids []uint32) {
	for id := range m.i18ns {
		ids = append(ids, id)
	}
	return
}

// ResetI18ns resets all changes to the "i18ns" edge.
func (m *DictTypeMutation) ResetI18ns() {
	m.i18ns = nil
	m.clearedi18ns = false
	m.removedi18ns = nil
}

// Where appends a list predicates to the DictTypeMutation builder.
func (m *DictTypeMutation) Where(ps ...predicate.DictType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictType).
func (m *DictTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictTypeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, dicttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dicttype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dicttype.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dicttype.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, dicttype.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, dicttype.FieldDeletedBy)
	}
	if m.is_enabled != nil {
		fields = append(fields, dicttype.FieldIsEnabled)
	}
	if m.sort_order != nil {
		fields = append(fields, dicttype.FieldSortOrder)
	}
	if m.tenant_id != nil {
		fields = append(fields, dicttype.FieldTenantID)
	}
	if m.type_code != nil {
		fields = append(fields, dicttype.FieldTypeCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dicttype.FieldCreatedAt:
		return m.CreatedAt()
	case dicttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case dicttype.FieldDeletedAt:
		return m.DeletedAt()
	case dicttype.FieldCreatedBy:
		return m.CreatedBy()
	case dicttype.FieldUpdatedBy:
		return m.UpdatedBy()
	case dicttype.FieldDeletedBy:
		return m.DeletedBy()
	case dicttype.FieldIsEnabled:
		return m.IsEnabled()
	case dicttype.FieldSortOrder:
		return m.SortOrder()
	case dicttype.FieldTenantID:
		return m.TenantID()
	case dicttype.FieldTypeCode:
		return m.TypeCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dicttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dicttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dicttype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dicttype.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dicttype.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case dicttype.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case dicttype.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case dicttype.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case dicttype.FieldTenantID:
		return m.OldTenantID(ctx)
	case dicttype.FieldTypeCode:
		return m.OldTypeCode(ctx)
	}
	return nil, fmt.Errorf("unknown DictType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dicttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dicttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dicttype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dicttype.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dicttype.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case dicttype.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case dicttype.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case dicttype.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case dicttype.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dicttype.FieldTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	}
	return fmt.Errorf("unknown DictType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictTypeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, dicttype.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, dicttype.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, dicttype.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, dicttype.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, dicttype.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dicttype.FieldCreatedBy:
		return m.AddedCreatedBy()
	case dicttype.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case dicttype.FieldDeletedBy:
		return m.AddedDeletedBy()
	case dicttype.FieldSortOrder:
		return m.AddedSortOrder()
	case dicttype.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dicttype.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case dicttype.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case dicttype.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case dicttype.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case dicttype.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DictType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dicttype.FieldCreatedAt) {
		fields = append(fields, dicttype.FieldCreatedAt)
	}
	if m.FieldCleared(dicttype.FieldUpdatedAt) {
		fields = append(fields, dicttype.FieldUpdatedAt)
	}
	if m.FieldCleared(dicttype.FieldDeletedAt) {
		fields = append(fields, dicttype.FieldDeletedAt)
	}
	if m.FieldCleared(dicttype.FieldCreatedBy) {
		fields = append(fields, dicttype.FieldCreatedBy)
	}
	if m.FieldCleared(dicttype.FieldUpdatedBy) {
		fields = append(fields, dicttype.FieldUpdatedBy)
	}
	if m.FieldCleared(dicttype.FieldDeletedBy) {
		fields = append(fields, dicttype.FieldDeletedBy)
	}
	if m.FieldCleared(dicttype.FieldIsEnabled) {
		fields = append(fields, dicttype.FieldIsEnabled)
	}
	if m.FieldCleared(dicttype.FieldSortOrder) {
		fields = append(fields, dicttype.FieldSortOrder)
	}
	if m.FieldCleared(dicttype.FieldTenantID) {
		fields = append(fields, dicttype.FieldTenantID)
	}
	if m.FieldCleared(dicttype.FieldTypeCode) {
		fields = append(fields, dicttype.FieldTypeCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictTypeMutation) ClearField(name string) error {
	switch name {
	case dicttype.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dicttype.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dicttype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dicttype.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case dicttype.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case dicttype.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case dicttype.FieldIsEnabled:
		m.ClearIsEnabled()
		return nil
	case dicttype.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case dicttype.FieldTenantID:
		m.ClearTenantID()
		return nil
	case dicttype.FieldTypeCode:
		m.ClearTypeCode()
		return nil
	}
	return fmt.Errorf("unknown DictType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictTypeMutation) ResetField(name string) error {
	switch name {
	case dicttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dicttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dicttype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dicttype.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dicttype.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case dicttype.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case dicttype.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case dicttype.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case dicttype.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dicttype.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	}
	return fmt.Errorf("unknown DictType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.entries != nil {
		edges = append(edges, dicttype.EdgeEntries)
	}
	if m.i18ns != nil {
		edges = append(edges, dicttype.EdgeI18ns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dicttype.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.entries))
		for id := range m.entries {
			ids = append(ids, id)
		}
		return ids
	case dicttype.EdgeI18ns:
		ids := make([]ent.Value, 0, len(m.i18ns))
		for id := range m.i18ns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentries != nil {
		edges = append(edges, dicttype.EdgeEntries)
	}
	if m.removedi18ns != nil {
		edges = append(edges, dicttype.EdgeI18ns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dicttype.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.removedentries))
		for id := range m.removedentries {
			ids = append(ids, id)
		}
		return ids
	case dicttype.EdgeI18ns:
		ids := make([]ent.Value, 0, len(m.removedi18ns))
		for id := range m.removedi18ns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedentries {
		edges = append(edges, dicttype.EdgeEntries)
	}
	if m.clearedi18ns {
		edges = append(edges, dicttype.EdgeI18ns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case dicttype.EdgeEntries:
		return m.clearedentries
	case dicttype.EdgeI18ns:
		return m.clearedi18ns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DictType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictTypeMutation) ResetEdge(name string) error {
	switch name {
	case dicttype.EdgeEntries:
		m.ResetEntries()
		return nil
	case dicttype.EdgeI18ns:
		m.ResetI18ns()
		return nil
	}
	return fmt.Errorf("unknown DictType edge %s", name)
}

// DictTypeI18nMutation represents an operation that mutates the DictTypeI18n nodes in the graph.
type DictTypeI18nMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	description      *string
	tenant_id        *uint32
	addtenant_id     *int32
	language_code    *string
	type_name        *string
	clearedFields    map[string]struct{}
	dict_type        *uint32
	cleareddict_type bool
	done             bool
	oldValue         func(context.Context) (*DictTypeI18n, error)
	predicates       []predicate.DictTypeI18n
}

var _ ent.Mutation = (*DictTypeI18nMutation)(nil)

// dicttypei18nOption allows management of the mutation configuration using functional options.
type dicttypei18nOption func(*DictTypeI18nMutation)

// newDictTypeI18nMutation creates new mutation for the DictTypeI18n entity.
func newDictTypeI18nMutation(c config, op Op, opts ...dicttypei18nOption) *DictTypeI18nMutation {
	m := &DictTypeI18nMutation{
		config:        c,
		op:            op,
		typ:           TypeDictTypeI18n,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictTypeI18nID sets the ID field of the mutation.
func withDictTypeI18nID(id uint32) dicttypei18nOption {
	return func(m *DictTypeI18nMutation) {
		var (
			err   error
			once  sync.Once
			value *DictTypeI18n
		)
		m.oldValue = func(ctx context.Context) (*DictTypeI18n, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictTypeI18n.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictTypeI18n sets the old DictTypeI18n of the mutation.
func withDictTypeI18n(node *DictTypeI18n) dicttypei18nOption {
	return func(m *DictTypeI18nMutation) {
		m.oldValue = func(context.Context) (*DictTypeI18n, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictTypeI18nMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictTypeI18nMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictTypeI18n entities.
func (m *DictTypeI18nMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictTypeI18nMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictTypeI18nMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictTypeI18n.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictTypeI18nMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictTypeI18nMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictTypeI18nMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dicttypei18n.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictTypeI18nMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictTypeI18nMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dicttypei18n.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictTypeI18nMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictTypeI18nMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictTypeI18nMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dicttypei18n.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictTypeI18nMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictTypeI18nMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dicttypei18n.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DictTypeI18nMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DictTypeI18nMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DictTypeI18nMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dicttypei18n.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DictTypeI18nMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DictTypeI18nMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dicttypei18n.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DictTypeI18nMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DictTypeI18nMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *DictTypeI18nMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DictTypeI18nMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DictTypeI18nMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[dicttypei18n.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DictTypeI18nMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DictTypeI18nMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, dicttypei18n.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DictTypeI18nMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DictTypeI18nMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *DictTypeI18nMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DictTypeI18nMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DictTypeI18nMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[dicttypei18n.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DictTypeI18nMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DictTypeI18nMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, dicttypei18n.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DictTypeI18nMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DictTypeI18nMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *DictTypeI18nMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *DictTypeI18nMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DictTypeI18nMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[dicttypei18n.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DictTypeI18nMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DictTypeI18nMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, dicttypei18n.FieldDeletedBy)
}

// SetDescription sets the "description" field.
func (m *DictTypeI18nMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictTypeI18nMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DictTypeI18nMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[dicttypei18n.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DictTypeI18nMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DictTypeI18nMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, dicttypei18n.FieldDescription)
}

// SetTenantID sets the "tenant_id" field.
func (m *DictTypeI18nMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DictTypeI18nMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DictTypeI18nMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DictTypeI18nMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DictTypeI18nMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[dicttypei18n.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DictTypeI18nMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DictTypeI18nMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, dicttypei18n.FieldTenantID)
}

// SetLanguageCode sets the "language_code" field.
func (m *DictTypeI18nMutation) SetLanguageCode(s string) {
	m.language_code = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *DictTypeI18nMutation) LanguageCode() (r string, exists bool) {
	v := m.language_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldLanguageCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ClearLanguageCode clears the value of the "language_code" field.
func (m *DictTypeI18nMutation) ClearLanguageCode() {
	m.language_code = nil
	m.clearedFields[dicttypei18n.FieldLanguageCode] = struct{}{}
}

// LanguageCodeCleared returns if the "language_code" field was cleared in this mutation.
func (m *DictTypeI18nMutation) LanguageCodeCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldLanguageCode]
	return ok
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *DictTypeI18nMutation) ResetLanguageCode() {
	m.language_code = nil
	delete(m.clearedFields, dicttypei18n.FieldLanguageCode)
}

// SetTypeName sets the "type_name" field.
func (m *DictTypeI18nMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *DictTypeI18nMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the DictTypeI18n entity.
// If the DictTypeI18n object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeI18nMutation) OldTypeName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ClearTypeName clears the value of the "type_name" field.
func (m *DictTypeI18nMutation) ClearTypeName() {
	m.type_name = nil
	m.clearedFields[dicttypei18n.FieldTypeName] = struct{}{}
}

// TypeNameCleared returns if the "type_name" field was cleared in this mutation.
func (m *DictTypeI18nMutation) TypeNameCleared() bool {
	_, ok := m.clearedFields[dicttypei18n.FieldTypeName]
	return ok
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *DictTypeI18nMutation) ResetTypeName() {
	m.type_name = nil
	delete(m.clearedFields, dicttypei18n.FieldTypeName)
}

// SetDictTypeID sets the "dict_type" edge to the DictType entity by id.
func (m *DictTypeI18nMutation) SetDictTypeID(id uint32) {
	m.dict_type = &id
}

// ClearDictType clears the "dict_type" edge to the DictType entity.
func (m *DictTypeI18nMutation) ClearDictType() {
	m.cleareddict_type = true
}

// DictTypeCleared reports if the "dict_type" edge to the DictType entity was cleared.
func (m *DictTypeI18nMutation) DictTypeCleared() bool {
	return m.cleareddict_type
}

// DictTypeID returns the "dict_type" edge ID in the mutation.
func (m *DictTypeI18nMutation) DictTypeID() (id uint32, exists bool) {
	if m.dict_type != nil {
		return *m.dict_type, true
	}
	return
}

// DictTypeIDs returns the "dict_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictTypeID instead. It exists only for internal usage by the builders.
func (m *DictTypeI18nMutation) DictTypeIDs() (ids []uint32) {
	if id := m.dict_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictType resets all changes to the "dict_type" edge.
func (m *DictTypeI18nMutation) ResetDictType() {
	m.dict_type = nil
	m.cleareddict_type = false
}

// Where appends a list predicates to the DictTypeI18nMutation builder.
func (m *DictTypeI18nMutation) Where(ps ...predicate.DictTypeI18n) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictTypeI18nMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictTypeI18nMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictTypeI18n, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictTypeI18nMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictTypeI18nMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictTypeI18n).
func (m *DictTypeI18nMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictTypeI18nMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, dicttypei18n.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dicttypei18n.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dicttypei18n.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dicttypei18n.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, dicttypei18n.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, dicttypei18n.FieldDeletedBy)
	}
	if m.description != nil {
		fields = append(fields, dicttypei18n.FieldDescription)
	}
	if m.tenant_id != nil {
		fields = append(fields, dicttypei18n.FieldTenantID)
	}
	if m.language_code != nil {
		fields = append(fields, dicttypei18n.FieldLanguageCode)
	}
	if m.type_name != nil {
		fields = append(fields, dicttypei18n.FieldTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictTypeI18nMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dicttypei18n.FieldCreatedAt:
		return m.CreatedAt()
	case dicttypei18n.FieldUpdatedAt:
		return m.UpdatedAt()
	case dicttypei18n.FieldDeletedAt:
		return m.DeletedAt()
	case dicttypei18n.FieldCreatedBy:
		return m.CreatedBy()
	case dicttypei18n.FieldUpdatedBy:
		return m.UpdatedBy()
	case dicttypei18n.FieldDeletedBy:
		return m.DeletedBy()
	case dicttypei18n.FieldDescription:
		return m.Description()
	case dicttypei18n.FieldTenantID:
		return m.TenantID()
	case dicttypei18n.FieldLanguageCode:
		return m.LanguageCode()
	case dicttypei18n.FieldTypeName:
		return m.TypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictTypeI18nMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dicttypei18n.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dicttypei18n.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dicttypei18n.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dicttypei18n.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dicttypei18n.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case dicttypei18n.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case dicttypei18n.FieldDescription:
		return m.OldDescription(ctx)
	case dicttypei18n.FieldTenantID:
		return m.OldTenantID(ctx)
	case dicttypei18n.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case dicttypei18n.FieldTypeName:
		return m.OldTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown DictTypeI18n field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictTypeI18nMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dicttypei18n.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dicttypei18n.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dicttypei18n.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dicttypei18n.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dicttypei18n.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case dicttypei18n.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case dicttypei18n.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dicttypei18n.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dicttypei18n.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case dicttypei18n.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown DictTypeI18n field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictTypeI18nMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, dicttypei18n.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, dicttypei18n.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, dicttypei18n.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, dicttypei18n.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictTypeI18nMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dicttypei18n.FieldCreatedBy:
		return m.AddedCreatedBy()
	case dicttypei18n.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case dicttypei18n.FieldDeletedBy:
		return m.AddedDeletedBy()
	case dicttypei18n.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictTypeI18nMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dicttypei18n.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case dicttypei18n.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case dicttypei18n.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case dicttypei18n.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DictTypeI18n numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictTypeI18nMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dicttypei18n.FieldCreatedAt) {
		fields = append(fields, dicttypei18n.FieldCreatedAt)
	}
	if m.FieldCleared(dicttypei18n.FieldUpdatedAt) {
		fields = append(fields, dicttypei18n.FieldUpdatedAt)
	}
	if m.FieldCleared(dicttypei18n.FieldDeletedAt) {
		fields = append(fields, dicttypei18n.FieldDeletedAt)
	}
	if m.FieldCleared(dicttypei18n.FieldCreatedBy) {
		fields = append(fields, dicttypei18n.FieldCreatedBy)
	}
	if m.FieldCleared(dicttypei18n.FieldUpdatedBy) {
		fields = append(fields, dicttypei18n.FieldUpdatedBy)
	}
	if m.FieldCleared(dicttypei18n.FieldDeletedBy) {
		fields = append(fields, dicttypei18n.FieldDeletedBy)
	}
	if m.FieldCleared(dicttypei18n.FieldDescription) {
		fields = append(fields, dicttypei18n.FieldDescription)
	}
	if m.FieldCleared(dicttypei18n.FieldTenantID) {
		fields = append(fields, dicttypei18n.FieldTenantID)
	}
	if m.FieldCleared(dicttypei18n.FieldLanguageCode) {
		fields = append(fields, dicttypei18n.FieldLanguageCode)
	}
	if m.FieldCleared(dicttypei18n.FieldTypeName) {
		fields = append(fields, dicttypei18n.FieldTypeName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictTypeI18nMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictTypeI18nMutation) ClearField(name string) error {
	switch name {
	case dicttypei18n.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dicttypei18n.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dicttypei18n.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dicttypei18n.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case dicttypei18n.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case dicttypei18n.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case dicttypei18n.FieldDescription:
		m.ClearDescription()
		return nil
	case dicttypei18n.FieldTenantID:
		m.ClearTenantID()
		return nil
	case dicttypei18n.FieldLanguageCode:
		m.ClearLanguageCode()
		return nil
	case dicttypei18n.FieldTypeName:
		m.ClearTypeName()
		return nil
	}
	return fmt.Errorf("unknown DictTypeI18n nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictTypeI18nMutation) ResetField(name string) error {
	switch name {
	case dicttypei18n.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dicttypei18n.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dicttypei18n.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dicttypei18n.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dicttypei18n.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case dicttypei18n.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case dicttypei18n.FieldDescription:
		m.ResetDescription()
		return nil
	case dicttypei18n.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dicttypei18n.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case dicttypei18n.FieldTypeName:
		m.ResetTypeName()
		return nil
	}
	return fmt.Errorf("unknown DictTypeI18n field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictTypeI18nMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dict_type != nil {
		edges = append(edges, dicttypei18n.EdgeDictType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictTypeI18nMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dicttypei18n.EdgeDictType:
		if id := m.dict_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictTypeI18nMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictTypeI18nMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictTypeI18nMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddict_type {
		edges = append(edges, dicttypei18n.EdgeDictType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictTypeI18nMutation) EdgeCleared(name string) bool {
	switch name {
	case dicttypei18n.EdgeDictType:
		return m.cleareddict_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictTypeI18nMutation) ClearEdge(name string) error {
	switch name {
	case dicttypei18n.EdgeDictType:
		m.ClearDictType()
		return nil
	}
	return fmt.Errorf("unknown DictTypeI18n unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictTypeI18nMutation) ResetEdge(name string) error {
	switch name {
	case dicttypei18n.EdgeDictType:
		m.ResetDictType()
		return nil
	}
	return fmt.Errorf("unknown DictTypeI18n edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	created_by     *uint32
	addcreated_by  *int32
	updated_by     *uint32
	addupdated_by  *int32
	deleted_by     *uint32
	adddeleted_by  *int32
	remark         *string
	tenant_id      *uint32
	addtenant_id   *int32
	provider       *file.Provider
	bucket_name    *string
	file_directory *string
	file_guid      *string
	save_file_name *string
	file_name      *string
	extension      *string
	size           *uint64
	addsize        *int64
	size_format    *string
	link_url       *string
	content_hash   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uint32) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FileMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[file.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FileMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, file.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[file.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, file.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FileMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FileMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *FileMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FileMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FileMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[file.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FileMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[file.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, file.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FileMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FileMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *FileMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FileMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FileMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[file.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[file.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FileMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, file.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FileMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FileMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *FileMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FileMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FileMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[file.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FileMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FileMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, file.FieldDeletedBy)
}

// SetRemark sets the "remark" field.
func (m *FileMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *FileMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *FileMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[file.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *FileMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[file.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *FileMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, file.FieldRemark)
}

// SetTenantID sets the "tenant_id" field.
func (m *FileMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FileMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *FileMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *FileMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *FileMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[file.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *FileMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[file.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FileMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, file.FieldTenantID)
}

// SetProvider sets the "provider" field.
func (m *FileMutation) SetProvider(f file.Provider) {
	m.provider = &f
}

// Provider returns the value of the "provider" field in the mutation.
func (m *FileMutation) Provider() (r file.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldProvider(ctx context.Context) (v *file.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *FileMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[file.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *FileMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[file.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *FileMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, file.FieldProvider)
}

// SetBucketName sets the "bucket_name" field.
func (m *FileMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *FileMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldBucketName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ClearBucketName clears the value of the "bucket_name" field.
func (m *FileMutation) ClearBucketName() {
	m.bucket_name = nil
	m.clearedFields[file.FieldBucketName] = struct{}{}
}

// BucketNameCleared returns if the "bucket_name" field was cleared in this mutation.
func (m *FileMutation) BucketNameCleared() bool {
	_, ok := m.clearedFields[file.FieldBucketName]
	return ok
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *FileMutation) ResetBucketName() {
	m.bucket_name = nil
	delete(m.clearedFields, file.FieldBucketName)
}

// SetFileDirectory sets the "file_directory" field.
func (m *FileMutation) SetFileDirectory(s string) {
	m.file_directory = &s
}

// FileDirectory returns the value of the "file_directory" field in the mutation.
func (m *FileMutation) FileDirectory() (r string, exists bool) {
	v := m.file_directory
	if v == nil {
		return
	}
	return *v, true
}

// OldFileDirectory returns the old "file_directory" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileDirectory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileDirectory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileDirectory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileDirectory: %w", err)
	}
	return oldValue.FileDirectory, nil
}

// ClearFileDirectory clears the value of the "file_directory" field.
func (m *FileMutation) ClearFileDirectory() {
	m.file_directory = nil
	m.clearedFields[file.FieldFileDirectory] = struct{}{}
}

// FileDirectoryCleared returns if the "file_directory" field was cleared in this mutation.
func (m *FileMutation) FileDirectoryCleared() bool {
	_, ok := m.clearedFields[file.FieldFileDirectory]
	return ok
}

// ResetFileDirectory resets all changes to the "file_directory" field.
func (m *FileMutation) ResetFileDirectory() {
	m.file_directory = nil
	delete(m.clearedFields, file.FieldFileDirectory)
}

// SetFileGUID sets the "file_guid" field.
func (m *FileMutation) SetFileGUID(s string) {
	m.file_guid = &s
}

// FileGUID returns the value of the "file_guid" field in the mutation.
func (m *FileMutation) FileGUID() (r string, exists bool) {
	v := m.file_guid
	if v == nil {
		return
	}
	return *v, true
}

// OldFileGUID returns the old "file_guid" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileGUID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileGUID: %w", err)
	}
	return oldValue.FileGUID, nil
}

// ClearFileGUID clears the value of the "file_guid" field.
func (m *FileMutation) ClearFileGUID() {
	m.file_guid = nil
	m.clearedFields[file.FieldFileGUID] = struct{}{}
}

// FileGUIDCleared returns if the "file_guid" field was cleared in this mutation.
func (m *FileMutation) FileGUIDCleared() bool {
	_, ok := m.clearedFields[file.FieldFileGUID]
	return ok
}

// ResetFileGUID resets all changes to the "file_guid" field.
func (m *FileMutation) ResetFileGUID() {
	m.file_guid = nil
	delete(m.clearedFields, file.FieldFileGUID)
}

// SetSaveFileName sets the "save_file_name" field.
func (m *FileMutation) SetSaveFileName(s string) {
	m.save_file_name = &s
}

// SaveFileName returns the value of the "save_file_name" field in the mutation.
func (m *FileMutation) SaveFileName() (r string, exists bool) {
	v := m.save_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSaveFileName returns the old "save_file_name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSaveFileName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaveFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaveFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaveFileName: %w", err)
	}
	return oldValue.SaveFileName, nil
}

// ClearSaveFileName clears the value of the "save_file_name" field.
func (m *FileMutation) ClearSaveFileName() {
	m.save_file_name = nil
	m.clearedFields[file.FieldSaveFileName] = struct{}{}
}

// SaveFileNameCleared returns if the "save_file_name" field was cleared in this mutation.
func (m *FileMutation) SaveFileNameCleared() bool {
	_, ok := m.clearedFields[file.FieldSaveFileName]
	return ok
}

// ResetSaveFileName resets all changes to the "save_file_name" field.
func (m *FileMutation) ResetSaveFileName() {
	m.save_file_name = nil
	delete(m.clearedFields, file.FieldSaveFileName)
}

// SetFileName sets the "file_name" field.
func (m *FileMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *FileMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ClearFileName clears the value of the "file_name" field.
func (m *FileMutation) ClearFileName() {
	m.file_name = nil
	m.clearedFields[file.FieldFileName] = struct{}{}
}

// FileNameCleared returns if the "file_name" field was cleared in this mutation.
func (m *FileMutation) FileNameCleared() bool {
	_, ok := m.clearedFields[file.FieldFileName]
	return ok
}

// ResetFileName resets all changes to the "file_name" field.
func (m *FileMutation) ResetFileName() {
	m.file_name = nil
	delete(m.clearedFields, file.FieldFileName)
}

// SetExtension sets the "extension" field.
func (m *FileMutation) SetExtension(s string) {
	m.extension = &s
}

// Extension returns the value of the "extension" field in the mutation.
func (m *FileMutation) Extension() (r string, exists bool) {
	v := m.extension
	if v == nil {
		return
	}
	return *v, true
}

// OldExtension returns the old "extension" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExtension(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtension: %w", err)
	}
	return oldValue.Extension, nil
}

// ClearExtension clears the value of the "extension" field.
func (m *FileMutation) ClearExtension() {
	m.extension = nil
	m.clearedFields[file.FieldExtension] = struct{}{}
}

// ExtensionCleared returns if the "extension" field was cleared in this mutation.
func (m *FileMutation) ExtensionCleared() bool {
	_, ok := m.clearedFields[file.FieldExtension]
	return ok
}

// ResetExtension resets all changes to the "extension" field.
func (m *FileMutation) ResetExtension() {
	m.extension = nil
	delete(m.clearedFields, file.FieldExtension)
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *FileMutation) AddSize(u int64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *FileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[file.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *FileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[file.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, file.FieldSize)
}

// SetSizeFormat sets the "size_format" field.
func (m *FileMutation) SetSizeFormat(s string) {
	m.size_format = &s
}

// SizeFormat returns the value of the "size_format" field in the mutation.
func (m *FileMutation) SizeFormat() (r string, exists bool) {
	v := m.size_format
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeFormat returns the old "size_format" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSizeFormat(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeFormat: %w", err)
	}
	return oldValue.SizeFormat, nil
}

// ClearSizeFormat clears the value of the "size_format" field.
func (m *FileMutation) ClearSizeFormat() {
	m.size_format = nil
	m.clearedFields[file.FieldSizeFormat] = struct{}{}
}

// SizeFormatCleared returns if the "size_format" field was cleared in this mutation.
func (m *FileMutation) SizeFormatCleared() bool {
	_, ok := m.clearedFields[file.FieldSizeFormat]
	return ok
}

// ResetSizeFormat resets all changes to the "size_format" field.
func (m *FileMutation) ResetSizeFormat() {
	m.size_format = nil
	delete(m.clearedFields, file.FieldSizeFormat)
}

// SetLinkURL sets the "link_url" field.
func (m *FileMutation) SetLinkURL(s string) {
	m.link_url = &s
}

// LinkURL returns the value of the "link_url" field in the mutation.
func (m *FileMutation) LinkURL() (r string, exists bool) {
	v := m.link_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkURL returns the old "link_url" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldLinkURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkURL: %w", err)
	}
	return oldValue.LinkURL, nil
}

// ClearLinkURL clears the value of the "link_url" field.
func (m *FileMutation) ClearLinkURL() {
	m.link_url = nil
	m.clearedFields[file.FieldLinkURL] = struct{}{}
}

// LinkURLCleared returns if the "link_url" field was cleared in this mutation.
func (m *FileMutation) LinkURLCleared() bool {
	_, ok := m.clearedFields[file.FieldLinkURL]
	return ok
}

// ResetLinkURL resets all changes to the "link_url" field.
func (m *FileMutation) ResetLinkURL() {
	m.link_url = nil
	delete(m.clearedFields, file.FieldLinkURL)
}

// SetContentHash sets the "content_hash" field.
func (m *FileMutation) SetContentHash(s string) {
	m.content_hash = &s
}

// ContentHash returns the value of the "content_hash" field in the mutation.
func (m *FileMutation) ContentHash() (r string, exists bool) {
	v := m.content_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHash returns the old "content_hash" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContentHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHash: %w", err)
	}
	return oldValue.ContentHash, nil
}

// ClearContentHash clears the value of the "content_hash" field.
func (m *FileMutation) ClearContentHash() {
	m.content_hash = nil
	m.clearedFields[file.FieldContentHash] = struct{}{}
}

// ContentHashCleared returns if the "content_hash" field was cleared in this mutation.
func (m *FileMutation) ContentHashCleared() bool {
	_, ok := m.clearedFields[file.FieldContentHash]
	return ok
}

// ResetContentHash resets all changes to the "content_hash" field.
func (m *FileMutation) ResetContentHash() {
	m.content_hash = nil
	delete(m.clearedFields, file.FieldContentHash)
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, file.FieldDeletedBy)
	}
	if m.remark != nil {
		fields = append(fields, file.FieldRemark)
	}
	if m.tenant_id != nil {
		fields = append(fields, file.FieldTenantID)
	}
	if m.provider != nil {
		fields = append(fields, file.FieldProvider)
	}
	if m.bucket_name != nil {
		fields = append(fields, file.FieldBucketName)
	}
	if m.file_directory != nil {
		fields = append(fields, file.FieldFileDirectory)
	}
	if m.file_guid != nil {
		fields = append(fields, file.FieldFileGUID)
	}
	if m.save_file_name != nil {
		fields = append(fields, file.FieldSaveFileName)
	}
	if m.file_name != nil {
		fields = append(fields, file.FieldFileName)
	}
	if m.extension != nil {
		fields = append(fields, file.FieldExtension)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.size_format != nil {
		fields = append(fields, file.FieldSizeFormat)
	}
	if m.link_url != nil {
		fields = append(fields, file.FieldLinkURL)
	}
	if m.content_hash != nil {
		fields = append(fields, file.FieldContentHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldCreatedBy:
		return m.CreatedBy()
	case file.FieldUpdatedBy:
		return m.UpdatedBy()
	case file.FieldDeletedBy:
		return m.DeletedBy()
	case file.FieldRemark:
		return m.Remark()
	case file.FieldTenantID:
		return m.TenantID()
	case file.FieldProvider:
		return m.Provider()
	case file.FieldBucketName:
		return m.BucketName()
	case file.FieldFileDirectory:
		return m.FileDirectory()
	case file.FieldFileGUID:
		return m.FileGUID()
	case file.FieldSaveFileName:
		return m.SaveFileName()
	case file.FieldFileName:
		return m.FileName()
	case file.FieldExtension:
		return m.Extension()
	case file.FieldSize:
		return m.Size()
	case file.FieldSizeFormat:
		return m.SizeFormat()
	case file.FieldLinkURL:
		return m.LinkURL()
	case file.FieldContentHash:
		return m.ContentHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case file.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case file.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case file.FieldRemark:
		return m.OldRemark(ctx)
	case file.FieldTenantID:
		return m.OldTenantID(ctx)
	case file.FieldProvider:
		return m.OldProvider(ctx)
	case file.FieldBucketName:
		return m.OldBucketName(ctx)
	case file.FieldFileDirectory:
		return m.OldFileDirectory(ctx)
	case file.FieldFileGUID:
		return m.OldFileGUID(ctx)
	case file.FieldSaveFileName:
		return m.OldSaveFileName(ctx)
	case file.FieldFileName:
		return m.OldFileName(ctx)
	case file.FieldExtension:
		return m.OldExtension(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldSizeFormat:
		return m.OldSizeFormat(ctx)
	case file.FieldLinkURL:
		return m.OldLinkURL(ctx)
	case file.FieldContentHash:
		return m.OldContentHash(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case file.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case file.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case file.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case file.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case file.FieldProvider:
		v, ok := value.(file.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case file.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case file.FieldFileDirectory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileDirectory(v)
		return nil
	case file.FieldFileGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileGUID(v)
		return nil
	case file.FieldSaveFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaveFileName(v)
		return nil
	case file.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case file.FieldExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtension(v)
		return nil
	case file.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldSizeFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeFormat(v)
		return nil
	case file.FieldLinkURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkURL(v)
		return nil
	case file.FieldContentHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHash(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, file.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, file.FieldTenantID)
	}
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedBy:
		return m.AddedCreatedBy()
	case file.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case file.FieldDeletedBy:
		return m.AddedDeletedBy()
	case file.FieldTenantID:
		return m.AddedTenantID()
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case file.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case file.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case file.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldCreatedAt) {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.FieldCleared(file.FieldUpdatedAt) {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.FieldCleared(file.FieldCreatedBy) {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.FieldCleared(file.FieldUpdatedBy) {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.FieldCleared(file.FieldDeletedBy) {
		fields = append(fields, file.FieldDeletedBy)
	}
	if m.FieldCleared(file.FieldRemark) {
		fields = append(fields, file.FieldRemark)
	}
	if m.FieldCleared(file.FieldTenantID) {
		fields = append(fields, file.FieldTenantID)
	}
	if m.FieldCleared(file.FieldProvider) {
		fields = append(fields, file.FieldProvider)
	}
	if m.FieldCleared(file.FieldBucketName) {
		fields = append(fields, file.FieldBucketName)
	}
	if m.FieldCleared(file.FieldFileDirectory) {
		fields = append(fields, file.FieldFileDirectory)
	}
	if m.FieldCleared(file.FieldFileGUID) {
		fields = append(fields, file.FieldFileGUID)
	}
	if m.FieldCleared(file.FieldSaveFileName) {
		fields = append(fields, file.FieldSaveFileName)
	}
	if m.FieldCleared(file.FieldFileName) {
		fields = append(fields, file.FieldFileName)
	}
	if m.FieldCleared(file.FieldExtension) {
		fields = append(fields, file.FieldExtension)
	}
	if m.FieldCleared(file.FieldSize) {
		fields = append(fields, file.FieldSize)
	}
	if m.FieldCleared(file.FieldSizeFormat) {
		fields = append(fields, file.FieldSizeFormat)
	}
	if m.FieldCleared(file.FieldLinkURL) {
		fields = append(fields, file.FieldLinkURL)
	}
	if m.FieldCleared(file.FieldContentHash) {
		fields = append(fields, file.FieldContentHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case file.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case file.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case file.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case file.FieldRemark:
		m.ClearRemark()
		return nil
	case file.FieldTenantID:
		m.ClearTenantID()
		return nil
	case file.FieldProvider:
		m.ClearProvider()
		return nil
	case file.FieldBucketName:
		m.ClearBucketName()
		return nil
	case file.FieldFileDirectory:
		m.ClearFileDirectory()
		return nil
	case file.FieldFileGUID:
		m.ClearFileGUID()
		return nil
	case file.FieldSaveFileName:
		m.ClearSaveFileName()
		return nil
	case file.FieldFileName:
		m.ClearFileName()
		return nil
	case file.FieldExtension:
		m.ClearExtension()
		return nil
	case file.FieldSize:
		m.ClearSize()
		return nil
	case file.FieldSizeFormat:
		m.ClearSizeFormat()
		return nil
	case file.FieldLinkURL:
		m.ClearLinkURL()
		return nil
	case file.FieldContentHash:
		m.ClearContentHash()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case file.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case file.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case file.FieldRemark:
		m.ResetRemark()
		return nil
	case file.FieldTenantID:
		m.ResetTenantID()
		return nil
	case file.FieldProvider:
		m.ResetProvider()
		return nil
	case file.FieldBucketName:
		m.ResetBucketName()
		return nil
	case file.FieldFileDirectory:
		m.ResetFileDirectory()
		return nil
	case file.FieldFileGUID:
		m.ResetFileGUID()
		return nil
	case file.FieldSaveFileName:
		m.ResetSaveFileName()
		return nil
	case file.FieldFileName:
		m.ResetFileName()
		return nil
	case file.FieldExtension:
		m.ResetExtension()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldSizeFormat:
		m.ResetSizeFormat()
		return nil
	case file.FieldLinkURL:
		m.ResetLinkURL()
		return nil
	case file.FieldContentHash:
		m.ResetContentHash()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown File edge %s", name)
}

// InternalMessageMutation represents an operation that mutates the InternalMessage nodes in the graph.
type InternalMessageMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	created_by     *uint32
	addcreated_by  *int32
	updated_by     *uint32
	addupdated_by  *int32
	deleted_by     *uint32
	adddeleted_by  *int32
	tenant_id      *uint32
	addtenant_id   *int32
	title          *string
	content        *string
	sender_id      *uint32
	addsender_id   *int32
	category_id    *uint32
	addcategory_id *int32
	status         *internalmessage.Status
	_type          *internalmessage.Type
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*InternalMessage, error)
	predicates     []predicate.InternalMessage
}

var _ ent.Mutation = (*InternalMessageMutation)(nil)

// internalmessageOption allows management of the mutation configuration using functional options.
type internalmessageOption func(*InternalMessageMutation)

// newInternalMessageMutation creates new mutation for the InternalMessage entity.
func newInternalMessageMutation(c config, op Op, opts ...internalmessageOption) *InternalMessageMutation {
	m := &InternalMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeInternalMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternalMessageID sets the ID field of the mutation.
func withInternalMessageID(id uint32) internalmessageOption {
	return func(m *InternalMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *InternalMessage
		)
		m.oldValue = func(ctx context.Context) (*InternalMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternalMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternalMessage sets the old InternalMessage of the mutation.
func withInternalMessage(node *InternalMessage) internalmessageOption {
	return func(m *InternalMessageMutation) {
		m.oldValue = func(context.Context) (*InternalMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternalMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternalMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternalMessage entities.
func (m *InternalMessageMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternalMessageMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternalMessageMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternalMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternalMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternalMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InternalMessageMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[internalmessage.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InternalMessageMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternalMessageMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, internalmessage.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InternalMessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InternalMessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InternalMessageMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[internalmessage.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InternalMessageMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InternalMessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, internalmessage.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InternalMessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InternalMessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InternalMessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[internalmessage.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InternalMessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InternalMessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, internalmessage.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *InternalMessageMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InternalMessageMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *InternalMessageMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InternalMessageMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *InternalMessageMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[internalmessage.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *InternalMessageMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InternalMessageMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, internalmessage.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InternalMessageMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InternalMessageMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *InternalMessageMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InternalMessageMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *InternalMessageMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[internalmessage.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *InternalMessageMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InternalMessageMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, internalmessage.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *InternalMessageMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *InternalMessageMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *InternalMessageMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *InternalMessageMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *InternalMessageMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[internalmessage.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *InternalMessageMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *InternalMessageMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, internalmessage.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *InternalMessageMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *InternalMessageMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *InternalMessageMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *InternalMessageMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *InternalMessageMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[internalmessage.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *InternalMessageMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *InternalMessageMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, internalmessage.FieldTenantID)
}

// SetTitle sets the "title" field.
func (m *InternalMessageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *InternalMessageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *InternalMessageMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[internalmessage.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *InternalMessageMutation) TitleCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *InternalMessageMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, internalmessage.FieldTitle)
}

// SetContent sets the "content" field.
func (m *InternalMessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *InternalMessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *InternalMessageMutation) ClearContent() {
	m.content = nil
	m.clearedFields[internalmessage.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *InternalMessageMutation) ContentCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *InternalMessageMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, internalmessage.FieldContent)
}

// SetSenderID sets the "sender_id" field.
func (m *InternalMessageMutation) SetSenderID(u uint32) {
	m.sender_id = &u
	m.addsender_id = nil
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *InternalMessageMutation) SenderID() (r uint32, exists bool) {
	v := m.sender_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldSenderID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// AddSenderID adds u to the "sender_id" field.
func (m *InternalMessageMutation) AddSenderID(u int32) {
	if m.addsender_id != nil {
		*m.addsender_id += u
	} else {
		m.addsender_id = &u
	}
}

// AddedSenderID returns the value that was added to the "sender_id" field in this mutation.
func (m *InternalMessageMutation) AddedSenderID() (r int32, exists bool) {
	v := m.addsender_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *InternalMessageMutation) ResetSenderID() {
	m.sender_id = nil
	m.addsender_id = nil
}

// SetCategoryID sets the "category_id" field.
func (m *InternalMessageMutation) SetCategoryID(u uint32) {
	m.category_id = &u
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *InternalMessageMutation) CategoryID() (r uint32, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldCategoryID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds u to the "category_id" field.
func (m *InternalMessageMutation) AddCategoryID(u int32) {
	if m.addcategory_id != nil {
		*m.addcategory_id += u
	} else {
		m.addcategory_id = &u
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *InternalMessageMutation) AddedCategoryID() (r int32, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *InternalMessageMutation) ClearCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	m.clearedFields[internalmessage.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *InternalMessageMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *InternalMessageMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	delete(m.clearedFields, internalmessage.FieldCategoryID)
}

// SetStatus sets the "status" field.
func (m *InternalMessageMutation) SetStatus(i internalmessage.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InternalMessageMutation) Status() (r internalmessage.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldStatus(ctx context.Context) (v *internalmessage.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *InternalMessageMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[internalmessage.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *InternalMessageMutation) StatusCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *InternalMessageMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, internalmessage.FieldStatus)
}

// SetType sets the "type" field.
func (m *InternalMessageMutation) SetType(i internalmessage.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *InternalMessageMutation) GetType() (r internalmessage.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the InternalMessage entity.
// If the InternalMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageMutation) OldType(ctx context.Context) (v *internalmessage.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *InternalMessageMutation) ClearType() {
	m._type = nil
	m.clearedFields[internalmessage.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *InternalMessageMutation) TypeCleared() bool {
	_, ok := m.clearedFields[internalmessage.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *InternalMessageMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, internalmessage.FieldType)
}

// Where appends a list predicates to the InternalMessageMutation builder.
func (m *InternalMessageMutation) Where(ps ...predicate.InternalMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternalMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternalMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternalMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternalMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternalMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternalMessage).
func (m *InternalMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternalMessageMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, internalmessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, internalmessage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, internalmessage.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, internalmessage.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, internalmessage.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, internalmessage.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, internalmessage.FieldTenantID)
	}
	if m.title != nil {
		fields = append(fields, internalmessage.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, internalmessage.FieldContent)
	}
	if m.sender_id != nil {
		fields = append(fields, internalmessage.FieldSenderID)
	}
	if m.category_id != nil {
		fields = append(fields, internalmessage.FieldCategoryID)
	}
	if m.status != nil {
		fields = append(fields, internalmessage.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, internalmessage.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternalMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internalmessage.FieldCreatedAt:
		return m.CreatedAt()
	case internalmessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case internalmessage.FieldDeletedAt:
		return m.DeletedAt()
	case internalmessage.FieldCreatedBy:
		return m.CreatedBy()
	case internalmessage.FieldUpdatedBy:
		return m.UpdatedBy()
	case internalmessage.FieldDeletedBy:
		return m.DeletedBy()
	case internalmessage.FieldTenantID:
		return m.TenantID()
	case internalmessage.FieldTitle:
		return m.Title()
	case internalmessage.FieldContent:
		return m.Content()
	case internalmessage.FieldSenderID:
		return m.SenderID()
	case internalmessage.FieldCategoryID:
		return m.CategoryID()
	case internalmessage.FieldStatus:
		return m.Status()
	case internalmessage.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternalMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internalmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internalmessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case internalmessage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case internalmessage.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case internalmessage.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case internalmessage.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case internalmessage.FieldTenantID:
		return m.OldTenantID(ctx)
	case internalmessage.FieldTitle:
		return m.OldTitle(ctx)
	case internalmessage.FieldContent:
		return m.OldContent(ctx)
	case internalmessage.FieldSenderID:
		return m.OldSenderID(ctx)
	case internalmessage.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case internalmessage.FieldStatus:
		return m.OldStatus(ctx)
	case internalmessage.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown InternalMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internalmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internalmessage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case internalmessage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case internalmessage.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case internalmessage.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case internalmessage.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case internalmessage.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case internalmessage.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case internalmessage.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case internalmessage.FieldSenderID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case internalmessage.FieldCategoryID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case internalmessage.FieldStatus:
		v, ok := value.(internalmessage.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case internalmessage.FieldType:
		v, ok := value.(internalmessage.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown InternalMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternalMessageMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, internalmessage.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, internalmessage.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, internalmessage.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, internalmessage.FieldTenantID)
	}
	if m.addsender_id != nil {
		fields = append(fields, internalmessage.FieldSenderID)
	}
	if m.addcategory_id != nil {
		fields = append(fields, internalmessage.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternalMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case internalmessage.FieldCreatedBy:
		return m.AddedCreatedBy()
	case internalmessage.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case internalmessage.FieldDeletedBy:
		return m.AddedDeletedBy()
	case internalmessage.FieldTenantID:
		return m.AddedTenantID()
	case internalmessage.FieldSenderID:
		return m.AddedSenderID()
	case internalmessage.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case internalmessage.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case internalmessage.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case internalmessage.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case internalmessage.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case internalmessage.FieldSenderID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSenderID(v)
		return nil
	case internalmessage.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown InternalMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternalMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internalmessage.FieldCreatedAt) {
		fields = append(fields, internalmessage.FieldCreatedAt)
	}
	if m.FieldCleared(internalmessage.FieldUpdatedAt) {
		fields = append(fields, internalmessage.FieldUpdatedAt)
	}
	if m.FieldCleared(internalmessage.FieldDeletedAt) {
		fields = append(fields, internalmessage.FieldDeletedAt)
	}
	if m.FieldCleared(internalmessage.FieldCreatedBy) {
		fields = append(fields, internalmessage.FieldCreatedBy)
	}
	if m.FieldCleared(internalmessage.FieldUpdatedBy) {
		fields = append(fields, internalmessage.FieldUpdatedBy)
	}
	if m.FieldCleared(internalmessage.FieldDeletedBy) {
		fields = append(fields, internalmessage.FieldDeletedBy)
	}
	if m.FieldCleared(internalmessage.FieldTenantID) {
		fields = append(fields, internalmessage.FieldTenantID)
	}
	if m.FieldCleared(internalmessage.FieldTitle) {
		fields = append(fields, internalmessage.FieldTitle)
	}
	if m.FieldCleared(internalmessage.FieldContent) {
		fields = append(fields, internalmessage.FieldContent)
	}
	if m.FieldCleared(internalmessage.FieldCategoryID) {
		fields = append(fields, internalmessage.FieldCategoryID)
	}
	if m.FieldCleared(internalmessage.FieldStatus) {
		fields = append(fields, internalmessage.FieldStatus)
	}
	if m.FieldCleared(internalmessage.FieldType) {
		fields = append(fields, internalmessage.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternalMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternalMessageMutation) ClearField(name string) error {
	switch name {
	case internalmessage.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case internalmessage.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case internalmessage.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case internalmessage.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case internalmessage.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case internalmessage.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case internalmessage.FieldTenantID:
		m.ClearTenantID()
		return nil
	case internalmessage.FieldTitle:
		m.ClearTitle()
		return nil
	case internalmessage.FieldContent:
		m.ClearContent()
		return nil
	case internalmessage.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case internalmessage.FieldStatus:
		m.ClearStatus()
		return nil
	case internalmessage.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown InternalMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternalMessageMutation) ResetField(name string) error {
	switch name {
	case internalmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internalmessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case internalmessage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case internalmessage.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case internalmessage.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case internalmessage.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case internalmessage.FieldTenantID:
		m.ResetTenantID()
		return nil
	case internalmessage.FieldTitle:
		m.ResetTitle()
		return nil
	case internalmessage.FieldContent:
		m.ResetContent()
		return nil
	case internalmessage.FieldSenderID:
		m.ResetSenderID()
		return nil
	case internalmessage.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case internalmessage.FieldStatus:
		m.ResetStatus()
		return nil
	case internalmessage.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown InternalMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternalMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternalMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternalMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternalMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternalMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternalMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternalMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternalMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternalMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternalMessage edge %s", name)
}

// InternalMessageCategoryMutation represents an operation that mutates the InternalMessageCategory nodes in the graph.
type InternalMessageCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	updated_by    *uint32
	addupdated_by *int32
	deleted_by    *uint32
	adddeleted_by *int32
	is_enabled    *bool
	sort_order    *uint32
	addsort_order *int32
	remark        *string
	tenant_id     *uint32
	addtenant_id  *int32
	name          *string
	code          *string
	icon_url      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*InternalMessageCategory, error)
	predicates    []predicate.InternalMessageCategory
}

var _ ent.Mutation = (*InternalMessageCategoryMutation)(nil)

// internalmessagecategoryOption allows management of the mutation configuration using functional options.
type internalmessagecategoryOption func(*InternalMessageCategoryMutation)

// newInternalMessageCategoryMutation creates new mutation for the InternalMessageCategory entity.
func newInternalMessageCategoryMutation(c config, op Op, opts ...internalmessagecategoryOption) *InternalMessageCategoryMutation {
	m := &InternalMessageCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeInternalMessageCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternalMessageCategoryID sets the ID field of the mutation.
func withInternalMessageCategoryID(id uint32) internalmessagecategoryOption {
	return func(m *InternalMessageCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *InternalMessageCategory
		)
		m.oldValue = func(ctx context.Context) (*InternalMessageCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternalMessageCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternalMessageCategory sets the old InternalMessageCategory of the mutation.
func withInternalMessageCategory(node *InternalMessageCategory) internalmessagecategoryOption {
	return func(m *InternalMessageCategoryMutation) {
		m.oldValue = func(context.Context) (*InternalMessageCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternalMessageCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternalMessageCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternalMessageCategory entities.
func (m *InternalMessageCategoryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternalMessageCategoryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternalMessageCategoryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternalMessageCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternalMessageCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternalMessageCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InternalMessageCategoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[internalmessagecategory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternalMessageCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, internalmessagecategory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InternalMessageCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InternalMessageCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InternalMessageCategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[internalmessagecategory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InternalMessageCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, internalmessagecategory.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InternalMessageCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InternalMessageCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InternalMessageCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[internalmessagecategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InternalMessageCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, internalmessagecategory.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *InternalMessageCategoryMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InternalMessageCategoryMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *InternalMessageCategoryMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *InternalMessageCategoryMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *InternalMessageCategoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[internalmessagecategory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InternalMessageCategoryMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, internalmessagecategory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InternalMessageCategoryMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InternalMessageCategoryMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *InternalMessageCategoryMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *InternalMessageCategoryMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *InternalMessageCategoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[internalmessagecategory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InternalMessageCategoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, internalmessagecategory.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *InternalMessageCategoryMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *InternalMessageCategoryMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *InternalMessageCategoryMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *InternalMessageCategoryMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *InternalMessageCategoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[internalmessagecategory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *InternalMessageCategoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, internalmessagecategory.FieldDeletedBy)
}

// SetIsEnabled sets the "is_enabled" field.
func (m *InternalMessageCategoryMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *InternalMessageCategoryMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldIsEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ClearIsEnabled clears the value of the "is_enabled" field.
func (m *InternalMessageCategoryMutation) ClearIsEnabled() {
	m.is_enabled = nil
	m.clearedFields[internalmessagecategory.FieldIsEnabled] = struct{}{}
}

// IsEnabledCleared returns if the "is_enabled" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) IsEnabledCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldIsEnabled]
	return ok
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *InternalMessageCategoryMutation) ResetIsEnabled() {
	m.is_enabled = nil
	delete(m.clearedFields, internalmessagecategory.FieldIsEnabled)
}

// SetSortOrder sets the "sort_order" field.
func (m *InternalMessageCategoryMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *InternalMessageCategoryMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *InternalMessageCategoryMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *InternalMessageCategoryMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *InternalMessageCategoryMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[internalmessagecategory.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *InternalMessageCategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, internalmessagecategory.FieldSortOrder)
}

// SetRemark sets the "remark" field.
func (m *InternalMessageCategoryMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *InternalMessageCategoryMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *InternalMessageCategoryMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[internalmessagecategory.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *InternalMessageCategoryMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, internalmessagecategory.FieldRemark)
}

// SetTenantID sets the "tenant_id" field.
func (m *InternalMessageCategoryMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *InternalMessageCategoryMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *InternalMessageCategoryMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *InternalMessageCategoryMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *InternalMessageCategoryMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[internalmessagecategory.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *InternalMessageCategoryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, internalmessagecategory.FieldTenantID)
}

// SetName sets the "name" field.
func (m *InternalMessageCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InternalMessageCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *InternalMessageCategoryMutation) ClearName() {
	m.name = nil
	m.clearedFields[internalmessagecategory.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) NameCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *InternalMessageCategoryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, internalmessagecategory.FieldName)
}

// SetCode sets the "code" field.
func (m *InternalMessageCategoryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *InternalMessageCategoryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *InternalMessageCategoryMutation) ClearCode() {
	m.code = nil
	m.clearedFields[internalmessagecategory.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) CodeCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *InternalMessageCategoryMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, internalmessagecategory.FieldCode)
}

// SetIconURL sets the "icon_url" field.
func (m *InternalMessageCategoryMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *InternalMessageCategoryMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the InternalMessageCategory entity.
// If the InternalMessageCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageCategoryMutation) OldIconURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *InternalMessageCategoryMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[internalmessagecategory.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *InternalMessageCategoryMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[internalmessagecategory.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *InternalMessageCategoryMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, internalmessagecategory.FieldIconURL)
}

// Where appends a list predicates to the InternalMessageCategoryMutation builder.
func (m *InternalMessageCategoryMutation) Where(ps ...predicate.InternalMessageCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternalMessageCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternalMessageCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternalMessageCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternalMessageCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternalMessageCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternalMessageCategory).
func (m *InternalMessageCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternalMessageCategoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, internalmessagecategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, internalmessagecategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, internalmessagecategory.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, internalmessagecategory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, internalmessagecategory.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, internalmessagecategory.FieldDeletedBy)
	}
	if m.is_enabled != nil {
		fields = append(fields, internalmessagecategory.FieldIsEnabled)
	}
	if m.sort_order != nil {
		fields = append(fields, internalmessagecategory.FieldSortOrder)
	}
	if m.remark != nil {
		fields = append(fields, internalmessagecategory.FieldRemark)
	}
	if m.tenant_id != nil {
		fields = append(fields, internalmessagecategory.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, internalmessagecategory.FieldName)
	}
	if m.code != nil {
		fields = append(fields, internalmessagecategory.FieldCode)
	}
	if m.icon_url != nil {
		fields = append(fields, internalmessagecategory.FieldIconURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternalMessageCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internalmessagecategory.FieldCreatedAt:
		return m.CreatedAt()
	case internalmessagecategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case internalmessagecategory.FieldDeletedAt:
		return m.DeletedAt()
	case internalmessagecategory.FieldCreatedBy:
		return m.CreatedBy()
	case internalmessagecategory.FieldUpdatedBy:
		return m.UpdatedBy()
	case internalmessagecategory.FieldDeletedBy:
		return m.DeletedBy()
	case internalmessagecategory.FieldIsEnabled:
		return m.IsEnabled()
	case internalmessagecategory.FieldSortOrder:
		return m.SortOrder()
	case internalmessagecategory.FieldRemark:
		return m.Remark()
	case internalmessagecategory.FieldTenantID:
		return m.TenantID()
	case internalmessagecategory.FieldName:
		return m.Name()
	case internalmessagecategory.FieldCode:
		return m.Code()
	case internalmessagecategory.FieldIconURL:
		return m.IconURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternalMessageCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internalmessagecategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internalmessagecategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case internalmessagecategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case internalmessagecategory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case internalmessagecategory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case internalmessagecategory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case internalmessagecategory.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case internalmessagecategory.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case internalmessagecategory.FieldRemark:
		return m.OldRemark(ctx)
	case internalmessagecategory.FieldTenantID:
		return m.OldTenantID(ctx)
	case internalmessagecategory.FieldName:
		return m.OldName(ctx)
	case internalmessagecategory.FieldCode:
		return m.OldCode(ctx)
	case internalmessagecategory.FieldIconURL:
		return m.OldIconURL(ctx)
	}
	return nil, fmt.Errorf("unknown InternalMessageCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalMessageCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internalmessagecategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internalmessagecategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case internalmessagecategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case internalmessagecategory.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case internalmessagecategory.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case internalmessagecategory.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case internalmessagecategory.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case internalmessagecategory.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case internalmessagecategory.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case internalmessagecategory.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case internalmessagecategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case internalmessagecategory.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case internalmessagecategory.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	}
	return fmt.Errorf("unknown InternalMessageCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternalMessageCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, internalmessagecategory.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, internalmessagecategory.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, internalmessagecategory.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, internalmessagecategory.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, internalmessagecategory.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternalMessageCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case internalmessagecategory.FieldCreatedBy:
		return m.AddedCreatedBy()
	case internalmessagecategory.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case internalmessagecategory.FieldDeletedBy:
		return m.AddedDeletedBy()
	case internalmessagecategory.FieldSortOrder:
		return m.AddedSortOrder()
	case internalmessagecategory.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalMessageCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case internalmessagecategory.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case internalmessagecategory.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case internalmessagecategory.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case internalmessagecategory.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case internalmessagecategory.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown InternalMessageCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternalMessageCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internalmessagecategory.FieldCreatedAt) {
		fields = append(fields, internalmessagecategory.FieldCreatedAt)
	}
	if m.FieldCleared(internalmessagecategory.FieldUpdatedAt) {
		fields = append(fields, internalmessagecategory.FieldUpdatedAt)
	}
	if m.FieldCleared(internalmessagecategory.FieldDeletedAt) {
		fields = append(fields, internalmessagecategory.FieldDeletedAt)
	}
	if m.FieldCleared(internalmessagecategory.FieldCreatedBy) {
		fields = append(fields, internalmessagecategory.FieldCreatedBy)
	}
	if m.FieldCleared(internalmessagecategory.FieldUpdatedBy) {
		fields = append(fields, internalmessagecategory.FieldUpdatedBy)
	}
	if m.FieldCleared(internalmessagecategory.FieldDeletedBy) {
		fields = append(fields, internalmessagecategory.FieldDeletedBy)
	}
	if m.FieldCleared(internalmessagecategory.FieldIsEnabled) {
		fields = append(fields, internalmessagecategory.FieldIsEnabled)
	}
	if m.FieldCleared(internalmessagecategory.FieldSortOrder) {
		fields = append(fields, internalmessagecategory.FieldSortOrder)
	}
	if m.FieldCleared(internalmessagecategory.FieldRemark) {
		fields = append(fields, internalmessagecategory.FieldRemark)
	}
	if m.FieldCleared(internalmessagecategory.FieldTenantID) {
		fields = append(fields, internalmessagecategory.FieldTenantID)
	}
	if m.FieldCleared(internalmessagecategory.FieldName) {
		fields = append(fields, internalmessagecategory.FieldName)
	}
	if m.FieldCleared(internalmessagecategory.FieldCode) {
		fields = append(fields, internalmessagecategory.FieldCode)
	}
	if m.FieldCleared(internalmessagecategory.FieldIconURL) {
		fields = append(fields, internalmessagecategory.FieldIconURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternalMessageCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternalMessageCategoryMutation) ClearField(name string) error {
	switch name {
	case internalmessagecategory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case internalmessagecategory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case internalmessagecategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case internalmessagecategory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case internalmessagecategory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case internalmessagecategory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case internalmessagecategory.FieldIsEnabled:
		m.ClearIsEnabled()
		return nil
	case internalmessagecategory.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case internalmessagecategory.FieldRemark:
		m.ClearRemark()
		return nil
	case internalmessagecategory.FieldTenantID:
		m.ClearTenantID()
		return nil
	case internalmessagecategory.FieldName:
		m.ClearName()
		return nil
	case internalmessagecategory.FieldCode:
		m.ClearCode()
		return nil
	case internalmessagecategory.FieldIconURL:
		m.ClearIconURL()
		return nil
	}
	return fmt.Errorf("unknown InternalMessageCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternalMessageCategoryMutation) ResetField(name string) error {
	switch name {
	case internalmessagecategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internalmessagecategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case internalmessagecategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case internalmessagecategory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case internalmessagecategory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case internalmessagecategory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case internalmessagecategory.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case internalmessagecategory.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case internalmessagecategory.FieldRemark:
		m.ResetRemark()
		return nil
	case internalmessagecategory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case internalmessagecategory.FieldName:
		m.ResetName()
		return nil
	case internalmessagecategory.FieldCode:
		m.ResetCode()
		return nil
	case internalmessagecategory.FieldIconURL:
		m.ResetIconURL()
		return nil
	}
	return fmt.Errorf("unknown InternalMessageCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternalMessageCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternalMessageCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternalMessageCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternalMessageCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternalMessageCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternalMessageCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternalMessageCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternalMessageCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternalMessageCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternalMessageCategory edge %s", name)
}

// InternalMessageRecipientMutation represents an operation that mutates the InternalMessageRecipient nodes in the graph.
type InternalMessageRecipientMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	tenant_id            *uint32
	addtenant_id         *int32
	message_id           *uint32
	addmessage_id        *int32
	recipient_user_id    *uint32
	addrecipient_user_id *int32
	status               *internalmessagerecipient.Status
	received_at          *time.Time
	read_at              *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*InternalMessageRecipient, error)
	predicates           []predicate.InternalMessageRecipient
}

var _ ent.Mutation = (*InternalMessageRecipientMutation)(nil)

// internalmessagerecipientOption allows management of the mutation configuration using functional options.
type internalmessagerecipientOption func(*InternalMessageRecipientMutation)

// newInternalMessageRecipientMutation creates new mutation for the InternalMessageRecipient entity.
func newInternalMessageRecipientMutation(c config, op Op, opts ...internalmessagerecipientOption) *InternalMessageRecipientMutation {
	m := &InternalMessageRecipientMutation{
		config:        c,
		op:            op,
		typ:           TypeInternalMessageRecipient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternalMessageRecipientID sets the ID field of the mutation.
func withInternalMessageRecipientID(id uint32) internalmessagerecipientOption {
	return func(m *InternalMessageRecipientMutation) {
		var (
			err   error
			once  sync.Once
			value *InternalMessageRecipient
		)
		m.oldValue = func(ctx context.Context) (*InternalMessageRecipient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternalMessageRecipient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternalMessageRecipient sets the old InternalMessageRecipient of the mutation.
func withInternalMessageRecipient(node *InternalMessageRecipient) internalmessagerecipientOption {
	return func(m *InternalMessageRecipientMutation) {
		m.oldValue = func(context.Context) (*InternalMessageRecipient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternalMessageRecipientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternalMessageRecipientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternalMessageRecipient entities.
func (m *InternalMessageRecipientMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternalMessageRecipientMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternalMessageRecipientMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternalMessageRecipient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternalMessageRecipientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternalMessageRecipientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InternalMessageRecipientMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[internalmessagerecipient.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternalMessageRecipientMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, internalmessagerecipient.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InternalMessageRecipientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InternalMessageRecipientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InternalMessageRecipientMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[internalmessagerecipient.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InternalMessageRecipientMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, internalmessagerecipient.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InternalMessageRecipientMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InternalMessageRecipientMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InternalMessageRecipientMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[internalmessagerecipient.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InternalMessageRecipientMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, internalmessagerecipient.FieldDeletedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *InternalMessageRecipientMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *InternalMessageRecipientMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *InternalMessageRecipientMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *InternalMessageRecipientMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *InternalMessageRecipientMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[internalmessagerecipient.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *InternalMessageRecipientMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, internalmessagerecipient.FieldTenantID)
}

// SetMessageID sets the "message_id" field.
func (m *InternalMessageRecipientMutation) SetMessageID(u uint32) {
	m.message_id = &u
	m.addmessage_id = nil
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *InternalMessageRecipientMutation) MessageID() (r uint32, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldMessageID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// AddMessageID adds u to the "message_id" field.
func (m *InternalMessageRecipientMutation) AddMessageID(u int32) {
	if m.addmessage_id != nil {
		*m.addmessage_id += u
	} else {
		m.addmessage_id = &u
	}
}

// AddedMessageID returns the value that was added to the "message_id" field in this mutation.
func (m *InternalMessageRecipientMutation) AddedMessageID() (r int32, exists bool) {
	v := m.addmessage_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMessageID clears the value of the "message_id" field.
func (m *InternalMessageRecipientMutation) ClearMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
	m.clearedFields[internalmessagerecipient.FieldMessageID] = struct{}{}
}

// MessageIDCleared returns if the "message_id" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) MessageIDCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldMessageID]
	return ok
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *InternalMessageRecipientMutation) ResetMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
	delete(m.clearedFields, internalmessagerecipient.FieldMessageID)
}

// SetRecipientUserID sets the "recipient_user_id" field.
func (m *InternalMessageRecipientMutation) SetRecipientUserID(u uint32) {
	m.recipient_user_id = &u
	m.addrecipient_user_id = nil
}

// RecipientUserID returns the value of the "recipient_user_id" field in the mutation.
func (m *InternalMessageRecipientMutation) RecipientUserID() (r uint32, exists bool) {
	v := m.recipient_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipientUserID returns the old "recipient_user_id" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldRecipientUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipientUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipientUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipientUserID: %w", err)
	}
	return oldValue.RecipientUserID, nil
}

// AddRecipientUserID adds u to the "recipient_user_id" field.
func (m *InternalMessageRecipientMutation) AddRecipientUserID(u int32) {
	if m.addrecipient_user_id != nil {
		*m.addrecipient_user_id += u
	} else {
		m.addrecipient_user_id = &u
	}
}

// AddedRecipientUserID returns the value that was added to the "recipient_user_id" field in this mutation.
func (m *InternalMessageRecipientMutation) AddedRecipientUserID() (r int32, exists bool) {
	v := m.addrecipient_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecipientUserID clears the value of the "recipient_user_id" field.
func (m *InternalMessageRecipientMutation) ClearRecipientUserID() {
	m.recipient_user_id = nil
	m.addrecipient_user_id = nil
	m.clearedFields[internalmessagerecipient.FieldRecipientUserID] = struct{}{}
}

// RecipientUserIDCleared returns if the "recipient_user_id" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) RecipientUserIDCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldRecipientUserID]
	return ok
}

// ResetRecipientUserID resets all changes to the "recipient_user_id" field.
func (m *InternalMessageRecipientMutation) ResetRecipientUserID() {
	m.recipient_user_id = nil
	m.addrecipient_user_id = nil
	delete(m.clearedFields, internalmessagerecipient.FieldRecipientUserID)
}

// SetStatus sets the "status" field.
func (m *InternalMessageRecipientMutation) SetStatus(i internalmessagerecipient.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InternalMessageRecipientMutation) Status() (r internalmessagerecipient.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldStatus(ctx context.Context) (v *internalmessagerecipient.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *InternalMessageRecipientMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[internalmessagerecipient.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) StatusCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *InternalMessageRecipientMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, internalmessagerecipient.FieldStatus)
}

// SetReceivedAt sets the "received_at" field.
func (m *InternalMessageRecipientMutation) SetReceivedAt(t time.Time) {
	m.received_at = &t
}

// ReceivedAt returns the value of the "received_at" field in the mutation.
func (m *InternalMessageRecipientMutation) ReceivedAt() (r time.Time, exists bool) {
	v := m.received_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedAt returns the old "received_at" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldReceivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedAt: %w", err)
	}
	return oldValue.ReceivedAt, nil
}

// ClearReceivedAt clears the value of the "received_at" field.
func (m *InternalMessageRecipientMutation) ClearReceivedAt() {
	m.received_at = nil
	m.clearedFields[internalmessagerecipient.FieldReceivedAt] = struct{}{}
}

// ReceivedAtCleared returns if the "received_at" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) ReceivedAtCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldReceivedAt]
	return ok
}

// ResetReceivedAt resets all changes to the "received_at" field.
func (m *InternalMessageRecipientMutation) ResetReceivedAt() {
	m.received_at = nil
	delete(m.clearedFields, internalmessagerecipient.FieldReceivedAt)
}

// SetReadAt sets the "read_at" field.
func (m *InternalMessageRecipientMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *InternalMessageRecipientMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the InternalMessageRecipient entity.
// If the InternalMessageRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalMessageRecipientMutation) OldReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *InternalMessageRecipientMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[internalmessagerecipient.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *InternalMessageRecipientMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[internalmessagerecipient.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *InternalMessageRecipientMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, internalmessagerecipient.FieldReadAt)
}

// Where appends a list predicates to the InternalMessageRecipientMutation builder.
func (m *InternalMessageRecipientMutation) Where(ps ...predicate.InternalMessageRecipient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternalMessageRecipientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternalMessageRecipientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternalMessageRecipient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternalMessageRecipientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternalMessageRecipientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternalMessageRecipient).
func (m *InternalMessageRecipientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternalMessageRecipientMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, internalmessagerecipient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, internalmessagerecipient.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, internalmessagerecipient.FieldDeletedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, internalmessagerecipient.FieldTenantID)
	}
	if m.message_id != nil {
		fields = append(fields, internalmessagerecipient.FieldMessageID)
	}
	if m.recipient_user_id != nil {
		fields = append(fields, internalmessagerecipient.FieldRecipientUserID)
	}
	if m.status != nil {
		fields = append(fields, internalmessagerecipient.FieldStatus)
	}
	if m.received_at != nil {
		fields = append(fields, internalmessagerecipient.FieldReceivedAt)
	}
	if m.read_at != nil {
		fields = append(fields, internalmessagerecipient.FieldReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternalMessageRecipientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internalmessagerecipient.FieldCreatedAt:
		return m.CreatedAt()
	case internalmessagerecipient.FieldUpdatedAt:
		return m.UpdatedAt()
	case internalmessagerecipient.FieldDeletedAt:
		return m.DeletedAt()
	case internalmessagerecipient.FieldTenantID:
		return m.TenantID()
	case internalmessagerecipient.FieldMessageID:
		return m.MessageID()
	case internalmessagerecipient.FieldRecipientUserID:
		return m.RecipientUserID()
	case internalmessagerecipient.FieldStatus:
		return m.Status()
	case internalmessagerecipient.FieldReceivedAt:
		return m.ReceivedAt()
	case internalmessagerecipient.FieldReadAt:
		return m.ReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternalMessageRecipientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internalmessagerecipient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internalmessagerecipient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case internalmessagerecipient.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case internalmessagerecipient.FieldTenantID:
		return m.OldTenantID(ctx)
	case internalmessagerecipient.FieldMessageID:
		return m.OldMessageID(ctx)
	case internalmessagerecipient.FieldRecipientUserID:
		return m.OldRecipientUserID(ctx)
	case internalmessagerecipient.FieldStatus:
		return m.OldStatus(ctx)
	case internalmessagerecipient.FieldReceivedAt:
		return m.OldReceivedAt(ctx)
	case internalmessagerecipient.FieldReadAt:
		return m.OldReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown InternalMessageRecipient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalMessageRecipientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internalmessagerecipient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internalmessagerecipient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case internalmessagerecipient.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case internalmessagerecipient.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case internalmessagerecipient.FieldMessageID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case internalmessagerecipient.FieldRecipientUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipientUserID(v)
		return nil
	case internalmessagerecipient.FieldStatus:
		v, ok := value.(internalmessagerecipient.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case internalmessagerecipient.FieldReceivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedAt(v)
		return nil
	case internalmessagerecipient.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown InternalMessageRecipient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternalMessageRecipientMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, internalmessagerecipient.FieldTenantID)
	}
	if m.addmessage_id != nil {
		fields = append(fields, internalmessagerecipient.FieldMessageID)
	}
	if m.addrecipient_user_id != nil {
		fields = append(fields, internalmessagerecipient.FieldRecipientUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternalMessageRecipientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case internalmessagerecipient.FieldTenantID:
		return m.AddedTenantID()
	case internalmessagerecipient.FieldMessageID:
		return m.AddedMessageID()
	case internalmessagerecipient.FieldRecipientUserID:
		return m.AddedRecipientUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalMessageRecipientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case internalmessagerecipient.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case internalmessagerecipient.FieldMessageID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageID(v)
		return nil
	case internalmessagerecipient.FieldRecipientUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecipientUserID(v)
		return nil
	}
	return fmt.Errorf("unknown InternalMessageRecipient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternalMessageRecipientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internalmessagerecipient.FieldCreatedAt) {
		fields = append(fields, internalmessagerecipient.FieldCreatedAt)
	}
	if m.FieldCleared(internalmessagerecipient.FieldUpdatedAt) {
		fields = append(fields, internalmessagerecipient.FieldUpdatedAt)
	}
	if m.FieldCleared(internalmessagerecipient.FieldDeletedAt) {
		fields = append(fields, internalmessagerecipient.FieldDeletedAt)
	}
	if m.FieldCleared(internalmessagerecipient.FieldTenantID) {
		fields = append(fields, internalmessagerecipient.FieldTenantID)
	}
	if m.FieldCleared(internalmessagerecipient.FieldMessageID) {
		fields = append(fields, internalmessagerecipient.FieldMessageID)
	}
	if m.FieldCleared(internalmessagerecipient.FieldRecipientUserID) {
		fields = append(fields, internalmessagerecipient.FieldRecipientUserID)
	}
	if m.FieldCleared(internalmessagerecipient.FieldStatus) {
		fields = append(fields, internalmessagerecipient.FieldStatus)
	}
	if m.FieldCleared(internalmessagerecipient.FieldReceivedAt) {
		fields = append(fields, internalmessagerecipient.FieldReceivedAt)
	}
	if m.FieldCleared(internalmessagerecipient.FieldReadAt) {
		fields = append(fields, internalmessagerecipient.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternalMessageRecipientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternalMessageRecipientMutation) ClearField(name string) error {
	switch name {
	case internalmessagerecipient.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case internalmessagerecipient.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case internalmessagerecipient.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case internalmessagerecipient.FieldTenantID:
		m.ClearTenantID()
		return nil
	case internalmessagerecipient.FieldMessageID:
		m.ClearMessageID()
		return nil
	case internalmessagerecipient.FieldRecipientUserID:
		m.ClearRecipientUserID()
		return nil
	case internalmessagerecipient.FieldStatus:
		m.ClearStatus()
		return nil
	case internalmessagerecipient.FieldReceivedAt:
		m.ClearReceivedAt()
		return nil
	case internalmessagerecipient.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown InternalMessageRecipient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternalMessageRecipientMutation) ResetField(name string) error {
	switch name {
	case internalmessagerecipient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internalmessagerecipient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case internalmessagerecipient.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case internalmessagerecipient.FieldTenantID:
		m.ResetTenantID()
		return nil
	case internalmessagerecipient.FieldMessageID:
		m.ResetMessageID()
		return nil
	case internalmessagerecipient.FieldRecipientUserID:
		m.ResetRecipientUserID()
		return nil
	case internalmessagerecipient.FieldStatus:
		m.ResetStatus()
		return nil
	case internalmessagerecipient.FieldReceivedAt:
		m.ResetReceivedAt()
		return nil
	case internalmessagerecipient.FieldReadAt:
		m.ResetReadAt()
		return nil
	}
	return fmt.Errorf("unknown InternalMessageRecipient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternalMessageRecipientMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternalMessageRecipientMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternalMessageRecipientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternalMessageRecipientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternalMessageRecipientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternalMessageRecipientMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternalMessageRecipientMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternalMessageRecipient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternalMessageRecipientMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternalMessageRecipient edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	updated_by    *uint32
	addupdated_by *int32
	deleted_by    *uint32
	adddeleted_by *int32
	sort_order    *uint32
	addsort_order *int32
	is_enabled    *bool
	language_code *string
	language_name *string
	native_name   *string
	is_default    *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Language, error)
	predicates    []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id uint32) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Language entities.
func (m *LanguageMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LanguageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LanguageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LanguageMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[language.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LanguageMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[language.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LanguageMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, language.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LanguageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LanguageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LanguageMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[language.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LanguageMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[language.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LanguageMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, language.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LanguageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LanguageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LanguageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[language.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LanguageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[language.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LanguageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, language.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *LanguageMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LanguageMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *LanguageMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LanguageMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *LanguageMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[language.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *LanguageMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[language.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LanguageMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, language.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LanguageMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LanguageMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *LanguageMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LanguageMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *LanguageMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[language.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *LanguageMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[language.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LanguageMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, language.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *LanguageMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *LanguageMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *LanguageMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *LanguageMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *LanguageMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[language.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *LanguageMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[language.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *LanguageMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, language.FieldDeletedBy)
}

// SetSortOrder sets the "sort_order" field.
func (m *LanguageMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *LanguageMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *LanguageMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *LanguageMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *LanguageMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[language.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *LanguageMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[language.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *LanguageMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, language.FieldSortOrder)
}

// SetIsEnabled sets the "is_enabled" field.
func (m *LanguageMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *LanguageMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldIsEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ClearIsEnabled clears the value of the "is_enabled" field.
func (m *LanguageMutation) ClearIsEnabled() {
	m.is_enabled = nil
	m.clearedFields[language.FieldIsEnabled] = struct{}{}
}

// IsEnabledCleared returns if the "is_enabled" field was cleared in this mutation.
func (m *LanguageMutation) IsEnabledCleared() bool {
	_, ok := m.clearedFields[language.FieldIsEnabled]
	return ok
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *LanguageMutation) ResetIsEnabled() {
	m.is_enabled = nil
	delete(m.clearedFields, language.FieldIsEnabled)
}

// SetLanguageCode sets the "language_code" field.
func (m *LanguageMutation) SetLanguageCode(s string) {
	m.language_code = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *LanguageMutation) LanguageCode() (r string, exists bool) {
	v := m.language_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ClearLanguageCode clears the value of the "language_code" field.
func (m *LanguageMutation) ClearLanguageCode() {
	m.language_code = nil
	m.clearedFields[language.FieldLanguageCode] = struct{}{}
}

// LanguageCodeCleared returns if the "language_code" field was cleared in this mutation.
func (m *LanguageMutation) LanguageCodeCleared() bool {
	_, ok := m.clearedFields[language.FieldLanguageCode]
	return ok
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *LanguageMutation) ResetLanguageCode() {
	m.language_code = nil
	delete(m.clearedFields, language.FieldLanguageCode)
}

// SetLanguageName sets the "language_name" field.
func (m *LanguageMutation) SetLanguageName(s string) {
	m.language_name = &s
}

// LanguageName returns the value of the "language_name" field in the mutation.
func (m *LanguageMutation) LanguageName() (r string, exists bool) {
	v := m.language_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageName returns the old "language_name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageName: %w", err)
	}
	return oldValue.LanguageName, nil
}

// ClearLanguageName clears the value of the "language_name" field.
func (m *LanguageMutation) ClearLanguageName() {
	m.language_name = nil
	m.clearedFields[language.FieldLanguageName] = struct{}{}
}

// LanguageNameCleared returns if the "language_name" field was cleared in this mutation.
func (m *LanguageMutation) LanguageNameCleared() bool {
	_, ok := m.clearedFields[language.FieldLanguageName]
	return ok
}

// ResetLanguageName resets all changes to the "language_name" field.
func (m *LanguageMutation) ResetLanguageName() {
	m.language_name = nil
	delete(m.clearedFields, language.FieldLanguageName)
}

// SetNativeName sets the "native_name" field.
func (m *LanguageMutation) SetNativeName(s string) {
	m.native_name = &s
}

// NativeName returns the value of the "native_name" field in the mutation.
func (m *LanguageMutation) NativeName() (r string, exists bool) {
	v := m.native_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNativeName returns the old "native_name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldNativeName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNativeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNativeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNativeName: %w", err)
	}
	return oldValue.NativeName, nil
}

// ClearNativeName clears the value of the "native_name" field.
func (m *LanguageMutation) ClearNativeName() {
	m.native_name = nil
	m.clearedFields[language.FieldNativeName] = struct{}{}
}

// NativeNameCleared returns if the "native_name" field was cleared in this mutation.
func (m *LanguageMutation) NativeNameCleared() bool {
	_, ok := m.clearedFields[language.FieldNativeName]
	return ok
}

// ResetNativeName resets all changes to the "native_name" field.
func (m *LanguageMutation) ResetNativeName() {
	m.native_name = nil
	delete(m.clearedFields, language.FieldNativeName)
}

// SetIsDefault sets the "is_default" field.
func (m *LanguageMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *LanguageMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldIsDefault(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *LanguageMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[language.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *LanguageMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[language.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *LanguageMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, language.FieldIsDefault)
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, language.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, language.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, language.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, language.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, language.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, language.FieldDeletedBy)
	}
	if m.sort_order != nil {
		fields = append(fields, language.FieldSortOrder)
	}
	if m.is_enabled != nil {
		fields = append(fields, language.FieldIsEnabled)
	}
	if m.language_code != nil {
		fields = append(fields, language.FieldLanguageCode)
	}
	if m.language_name != nil {
		fields = append(fields, language.FieldLanguageName)
	}
	if m.native_name != nil {
		fields = append(fields, language.FieldNativeName)
	}
	if m.is_default != nil {
		fields = append(fields, language.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldCreatedAt:
		return m.CreatedAt()
	case language.FieldUpdatedAt:
		return m.UpdatedAt()
	case language.FieldDeletedAt:
		return m.DeletedAt()
	case language.FieldCreatedBy:
		return m.CreatedBy()
	case language.FieldUpdatedBy:
		return m.UpdatedBy()
	case language.FieldDeletedBy:
		return m.DeletedBy()
	case language.FieldSortOrder:
		return m.SortOrder()
	case language.FieldIsEnabled:
		return m.IsEnabled()
	case language.FieldLanguageCode:
		return m.LanguageCode()
	case language.FieldLanguageName:
		return m.LanguageName()
	case language.FieldNativeName:
		return m.NativeName()
	case language.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case language.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case language.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case language.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case language.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case language.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case language.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case language.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case language.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case language.FieldLanguageName:
		return m.OldLanguageName(ctx)
	case language.FieldNativeName:
		return m.OldNativeName(ctx)
	case language.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case language.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case language.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case language.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case language.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case language.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case language.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case language.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case language.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case language.FieldLanguageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageName(v)
		return nil
	case language.FieldNativeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNativeName(v)
		return nil
	case language.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, language.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, language.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, language.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, language.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case language.FieldCreatedBy:
		return m.AddedCreatedBy()
	case language.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case language.FieldDeletedBy:
		return m.AddedDeletedBy()
	case language.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case language.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case language.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case language.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case language.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(language.FieldCreatedAt) {
		fields = append(fields, language.FieldCreatedAt)
	}
	if m.FieldCleared(language.FieldUpdatedAt) {
		fields = append(fields, language.FieldUpdatedAt)
	}
	if m.FieldCleared(language.FieldDeletedAt) {
		fields = append(fields, language.FieldDeletedAt)
	}
	if m.FieldCleared(language.FieldCreatedBy) {
		fields = append(fields, language.FieldCreatedBy)
	}
	if m.FieldCleared(language.FieldUpdatedBy) {
		fields = append(fields, language.FieldUpdatedBy)
	}
	if m.FieldCleared(language.FieldDeletedBy) {
		fields = append(fields, language.FieldDeletedBy)
	}
	if m.FieldCleared(language.FieldSortOrder) {
		fields = append(fields, language.FieldSortOrder)
	}
	if m.FieldCleared(language.FieldIsEnabled) {
		fields = append(fields, language.FieldIsEnabled)
	}
	if m.FieldCleared(language.FieldLanguageCode) {
		fields = append(fields, language.FieldLanguageCode)
	}
	if m.FieldCleared(language.FieldLanguageName) {
		fields = append(fields, language.FieldLanguageName)
	}
	if m.FieldCleared(language.FieldNativeName) {
		fields = append(fields, language.FieldNativeName)
	}
	if m.FieldCleared(language.FieldIsDefault) {
		fields = append(fields, language.FieldIsDefault)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	switch name {
	case language.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case language.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case language.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case language.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case language.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case language.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case language.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case language.FieldIsEnabled:
		m.ClearIsEnabled()
		return nil
	case language.FieldLanguageCode:
		m.ClearLanguageCode()
		return nil
	case language.FieldLanguageName:
		m.ClearLanguageName()
		return nil
	case language.FieldNativeName:
		m.ClearNativeName()
		return nil
	case language.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case language.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case language.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case language.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case language.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case language.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case language.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case language.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case language.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case language.FieldLanguageName:
		m.ResetLanguageName()
		return nil
	case language.FieldNativeName:
		m.ResetNativeName()
		return nil
	case language.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Language edge %s", name)
}

// LoginAuditLogMutation represents an operation that mutates the LoginAuditLog nodes in the graph.
type LoginAuditLogMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *time.Time
	tenant_id          *uint32
	addtenant_id       *int32
	user_id            *uint32
	adduser_id         *int32
	username           *string
	ip_address         *string
	geo_location       **auditpb.GeoLocation
	session_id         *string
	device_info        **auditpb.DeviceInfo
	request_id         *string
	trace_id           *string
	action_type        *loginauditlog.ActionType
	status             *loginauditlog.Status
	login_method       *loginauditlog.LoginMethod
	failure_reason     *string
	mfa_status         *string
	risk_score         *uint32
	addrisk_score      *int32
	risk_level         *loginauditlog.RiskLevel
	risk_factors       *[]string
	appendrisk_factors []string
	log_hash           *string
	signature          *[]byte
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*LoginAuditLog, error)
	predicates         []predicate.LoginAuditLog
}

var _ ent.Mutation = (*LoginAuditLogMutation)(nil)

// loginauditlogOption allows management of the mutation configuration using functional options.
type loginauditlogOption func(*LoginAuditLogMutation)

// newLoginAuditLogMutation creates new mutation for the LoginAuditLog entity.
func newLoginAuditLogMutation(c config, op Op, opts ...loginauditlogOption) *LoginAuditLogMutation {
	m := &LoginAuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginAuditLogID sets the ID field of the mutation.
func withLoginAuditLogID(id uint32) loginauditlogOption {
	return func(m *LoginAuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginAuditLog
		)
		m.oldValue = func(ctx context.Context) (*LoginAuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginAuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginAuditLog sets the old LoginAuditLog of the mutation.
func withLoginAuditLog(node *LoginAuditLog) loginauditlogOption {
	return func(m *LoginAuditLogMutation) {
		m.oldValue = func(context.Context) (*LoginAuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginAuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginAuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginAuditLog entities.
func (m *LoginAuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginAuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginAuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginAuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginAuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginAuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LoginAuditLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[loginauditlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LoginAuditLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginAuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, loginauditlog.FieldCreatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *LoginAuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LoginAuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *LoginAuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *LoginAuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LoginAuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[loginauditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LoginAuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LoginAuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, loginauditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *LoginAuditLogMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginAuditLogMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *LoginAuditLogMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *LoginAuditLogMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *LoginAuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[loginauditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *LoginAuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginAuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, loginauditlog.FieldUserID)
}

// SetUsername sets the "username" field.
func (m *LoginAuditLogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *LoginAuditLogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *LoginAuditLogMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[loginauditlog.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *LoginAuditLogMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *LoginAuditLogMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, loginauditlog.FieldUsername)
}

// SetIPAddress sets the "ip_address" field.
func (m *LoginAuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *LoginAuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *LoginAuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[loginauditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *LoginAuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *LoginAuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, loginauditlog.FieldIPAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *LoginAuditLogMutation) SetGeoLocation(al *auditpb.GeoLocation) {
	m.geo_location = &al
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *LoginAuditLogMutation) GeoLocation() (r *auditpb.GeoLocation, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldGeoLocation(ctx context.Context) (v *auditpb.GeoLocation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *LoginAuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[loginauditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *LoginAuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *LoginAuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, loginauditlog.FieldGeoLocation)
}

// SetSessionID sets the "session_id" field.
func (m *LoginAuditLogMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *LoginAuditLogMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldSessionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *LoginAuditLogMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[loginauditlog.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *LoginAuditLogMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *LoginAuditLogMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, loginauditlog.FieldSessionID)
}

// SetDeviceInfo sets the "device_info" field.
func (m *LoginAuditLogMutation) SetDeviceInfo(ai *auditpb.DeviceInfo) {
	m.device_info = &ai
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *LoginAuditLogMutation) DeviceInfo() (r *auditpb.DeviceInfo, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldDeviceInfo(ctx context.Context) (v *auditpb.DeviceInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *LoginAuditLogMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[loginauditlog.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *LoginAuditLogMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *LoginAuditLogMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, loginauditlog.FieldDeviceInfo)
}

// SetRequestID sets the "request_id" field.
func (m *LoginAuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *LoginAuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *LoginAuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[loginauditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *LoginAuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *LoginAuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, loginauditlog.FieldRequestID)
}

// SetTraceID sets the "trace_id" field.
func (m *LoginAuditLogMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *LoginAuditLogMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldTraceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *LoginAuditLogMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[loginauditlog.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *LoginAuditLogMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *LoginAuditLogMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, loginauditlog.FieldTraceID)
}

// SetActionType sets the "action_type" field.
func (m *LoginAuditLogMutation) SetActionType(lt loginauditlog.ActionType) {
	m.action_type = &lt
}

// ActionType returns the value of the "action_type" field in the mutation.
func (m *LoginAuditLogMutation) ActionType() (r loginauditlog.ActionType, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "action_type" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldActionType(ctx context.Context) (v *loginauditlog.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ClearActionType clears the value of the "action_type" field.
func (m *LoginAuditLogMutation) ClearActionType() {
	m.action_type = nil
	m.clearedFields[loginauditlog.FieldActionType] = struct{}{}
}

// ActionTypeCleared returns if the "action_type" field was cleared in this mutation.
func (m *LoginAuditLogMutation) ActionTypeCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldActionType]
	return ok
}

// ResetActionType resets all changes to the "action_type" field.
func (m *LoginAuditLogMutation) ResetActionType() {
	m.action_type = nil
	delete(m.clearedFields, loginauditlog.FieldActionType)
}

// SetStatus sets the "status" field.
func (m *LoginAuditLogMutation) SetStatus(l loginauditlog.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LoginAuditLogMutation) Status() (r loginauditlog.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldStatus(ctx context.Context) (v *loginauditlog.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *LoginAuditLogMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[loginauditlog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *LoginAuditLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *LoginAuditLogMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, loginauditlog.FieldStatus)
}

// SetLoginMethod sets the "login_method" field.
func (m *LoginAuditLogMutation) SetLoginMethod(lm loginauditlog.LoginMethod) {
	m.login_method = &lm
}

// LoginMethod returns the value of the "login_method" field in the mutation.
func (m *LoginAuditLogMutation) LoginMethod() (r loginauditlog.LoginMethod, exists bool) {
	v := m.login_method
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginMethod returns the old "login_method" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldLoginMethod(ctx context.Context) (v *loginauditlog.LoginMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginMethod: %w", err)
	}
	return oldValue.LoginMethod, nil
}

// ClearLoginMethod clears the value of the "login_method" field.
func (m *LoginAuditLogMutation) ClearLoginMethod() {
	m.login_method = nil
	m.clearedFields[loginauditlog.FieldLoginMethod] = struct{}{}
}

// LoginMethodCleared returns if the "login_method" field was cleared in this mutation.
func (m *LoginAuditLogMutation) LoginMethodCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldLoginMethod]
	return ok
}

// ResetLoginMethod resets all changes to the "login_method" field.
func (m *LoginAuditLogMutation) ResetLoginMethod() {
	m.login_method = nil
	delete(m.clearedFields, loginauditlog.FieldLoginMethod)
}

// SetFailureReason sets the "failure_reason" field.
func (m *LoginAuditLogMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *LoginAuditLogMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *LoginAuditLogMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[loginauditlog.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *LoginAuditLogMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *LoginAuditLogMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, loginauditlog.FieldFailureReason)
}

// SetMfaStatus sets the "mfa_status" field.
func (m *LoginAuditLogMutation) SetMfaStatus(s string) {
	m.mfa_status = &s
}

// MfaStatus returns the value of the "mfa_status" field in the mutation.
func (m *LoginAuditLogMutation) MfaStatus() (r string, exists bool) {
	v := m.mfa_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaStatus returns the old "mfa_status" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldMfaStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaStatus: %w", err)
	}
	return oldValue.MfaStatus, nil
}

// ClearMfaStatus clears the value of the "mfa_status" field.
func (m *LoginAuditLogMutation) ClearMfaStatus() {
	m.mfa_status = nil
	m.clearedFields[loginauditlog.FieldMfaStatus] = struct{}{}
}

// MfaStatusCleared returns if the "mfa_status" field was cleared in this mutation.
func (m *LoginAuditLogMutation) MfaStatusCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldMfaStatus]
	return ok
}

// ResetMfaStatus resets all changes to the "mfa_status" field.
func (m *LoginAuditLogMutation) ResetMfaStatus() {
	m.mfa_status = nil
	delete(m.clearedFields, loginauditlog.FieldMfaStatus)
}

// SetRiskScore sets the "risk_score" field.
func (m *LoginAuditLogMutation) SetRiskScore(u uint32) {
	m.risk_score = &u
	m.addrisk_score = nil
}

// RiskScore returns the value of the "risk_score" field in the mutation.
func (m *LoginAuditLogMutation) RiskScore() (r uint32, exists bool) {
	v := m.risk_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskScore returns the old "risk_score" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldRiskScore(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskScore: %w", err)
	}
	return oldValue.RiskScore, nil
}

// AddRiskScore adds u to the "risk_score" field.
func (m *LoginAuditLogMutation) AddRiskScore(u int32) {
	if m.addrisk_score != nil {
		*m.addrisk_score += u
	} else {
		m.addrisk_score = &u
	}
}

// AddedRiskScore returns the value that was added to the "risk_score" field in this mutation.
func (m *LoginAuditLogMutation) AddedRiskScore() (r int32, exists bool) {
	v := m.addrisk_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRiskScore clears the value of the "risk_score" field.
func (m *LoginAuditLogMutation) ClearRiskScore() {
	m.risk_score = nil
	m.addrisk_score = nil
	m.clearedFields[loginauditlog.FieldRiskScore] = struct{}{}
}

// RiskScoreCleared returns if the "risk_score" field was cleared in this mutation.
func (m *LoginAuditLogMutation) RiskScoreCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldRiskScore]
	return ok
}

// ResetRiskScore resets all changes to the "risk_score" field.
func (m *LoginAuditLogMutation) ResetRiskScore() {
	m.risk_score = nil
	m.addrisk_score = nil
	delete(m.clearedFields, loginauditlog.FieldRiskScore)
}

// SetRiskLevel sets the "risk_level" field.
func (m *LoginAuditLogMutation) SetRiskLevel(ll loginauditlog.RiskLevel) {
	m.risk_level = &ll
}

// RiskLevel returns the value of the "risk_level" field in the mutation.
func (m *LoginAuditLogMutation) RiskLevel() (r loginauditlog.RiskLevel, exists bool) {
	v := m.risk_level
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLevel returns the old "risk_level" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldRiskLevel(ctx context.Context) (v *loginauditlog.RiskLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLevel: %w", err)
	}
	return oldValue.RiskLevel, nil
}

// ClearRiskLevel clears the value of the "risk_level" field.
func (m *LoginAuditLogMutation) ClearRiskLevel() {
	m.risk_level = nil
	m.clearedFields[loginauditlog.FieldRiskLevel] = struct{}{}
}

// RiskLevelCleared returns if the "risk_level" field was cleared in this mutation.
func (m *LoginAuditLogMutation) RiskLevelCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldRiskLevel]
	return ok
}

// ResetRiskLevel resets all changes to the "risk_level" field.
func (m *LoginAuditLogMutation) ResetRiskLevel() {
	m.risk_level = nil
	delete(m.clearedFields, loginauditlog.FieldRiskLevel)
}

// SetRiskFactors sets the "risk_factors" field.
func (m *LoginAuditLogMutation) SetRiskFactors(s []string) {
	m.risk_factors = &s
	m.appendrisk_factors = nil
}

// RiskFactors returns the value of the "risk_factors" field in the mutation.
func (m *LoginAuditLogMutation) RiskFactors() (r []string, exists bool) {
	v := m.risk_factors
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskFactors returns the old "risk_factors" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldRiskFactors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskFactors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskFactors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskFactors: %w", err)
	}
	return oldValue.RiskFactors, nil
}

// AppendRiskFactors adds s to the "risk_factors" field.
func (m *LoginAuditLogMutation) AppendRiskFactors(s []string) {
	m.appendrisk_factors = append(m.appendrisk_factors, s...)
}

// AppendedRiskFactors returns the list of values that were appended to the "risk_factors" field in this mutation.
func (m *LoginAuditLogMutation) AppendedRiskFactors() ([]string, bool) {
	if len(m.appendrisk_factors) == 0 {
		return nil, false
	}
	return m.appendrisk_factors, true
}

// ClearRiskFactors clears the value of the "risk_factors" field.
func (m *LoginAuditLogMutation) ClearRiskFactors() {
	m.risk_factors = nil
	m.appendrisk_factors = nil
	m.clearedFields[loginauditlog.FieldRiskFactors] = struct{}{}
}

// RiskFactorsCleared returns if the "risk_factors" field was cleared in this mutation.
func (m *LoginAuditLogMutation) RiskFactorsCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldRiskFactors]
	return ok
}

// ResetRiskFactors resets all changes to the "risk_factors" field.
func (m *LoginAuditLogMutation) ResetRiskFactors() {
	m.risk_factors = nil
	m.appendrisk_factors = nil
	delete(m.clearedFields, loginauditlog.FieldRiskFactors)
}

// SetLogHash sets the "log_hash" field.
func (m *LoginAuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *LoginAuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldLogHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *LoginAuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[loginauditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *LoginAuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *LoginAuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, loginauditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *LoginAuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *LoginAuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the LoginAuditLog entity.
// If the LoginAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAuditLogMutation) OldSignature(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *LoginAuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[loginauditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *LoginAuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[loginauditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *LoginAuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, loginauditlog.FieldSignature)
}

// Where appends a list predicates to the LoginAuditLogMutation builder.
func (m *LoginAuditLogMutation) Where(ps ...predicate.LoginAuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginAuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginAuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginAuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginAuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginAuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginAuditLog).
func (m *LoginAuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginAuditLogMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, loginauditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, loginauditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, loginauditlog.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, loginauditlog.FieldUsername)
	}
	if m.ip_address != nil {
		fields = append(fields, loginauditlog.FieldIPAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, loginauditlog.FieldGeoLocation)
	}
	if m.session_id != nil {
		fields = append(fields, loginauditlog.FieldSessionID)
	}
	if m.device_info != nil {
		fields = append(fields, loginauditlog.FieldDeviceInfo)
	}
	if m.request_id != nil {
		fields = append(fields, loginauditlog.FieldRequestID)
	}
	if m.trace_id != nil {
		fields = append(fields, loginauditlog.FieldTraceID)
	}
	if m.action_type != nil {
		fields = append(fields, loginauditlog.FieldActionType)
	}
	if m.status != nil {
		fields = append(fields, loginauditlog.FieldStatus)
	}
	if m.login_method != nil {
		fields = append(fields, loginauditlog.FieldLoginMethod)
	}
	if m.failure_reason != nil {
		fields = append(fields, loginauditlog.FieldFailureReason)
	}
	if m.mfa_status != nil {
		fields = append(fields, loginauditlog.FieldMfaStatus)
	}
	if m.risk_score != nil {
		fields = append(fields, loginauditlog.FieldRiskScore)
	}
	if m.risk_level != nil {
		fields = append(fields, loginauditlog.FieldRiskLevel)
	}
	if m.risk_factors != nil {
		fields = append(fields, loginauditlog.FieldRiskFactors)
	}
	if m.log_hash != nil {
		fields = append(fields, loginauditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, loginauditlog.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginAuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginauditlog.FieldCreatedAt:
		return m.CreatedAt()
	case loginauditlog.FieldTenantID:
		return m.TenantID()
	case loginauditlog.FieldUserID:
		return m.UserID()
	case loginauditlog.FieldUsername:
		return m.Username()
	case loginauditlog.FieldIPAddress:
		return m.IPAddress()
	case loginauditlog.FieldGeoLocation:
		return m.GeoLocation()
	case loginauditlog.FieldSessionID:
		return m.SessionID()
	case loginauditlog.FieldDeviceInfo:
		return m.DeviceInfo()
	case loginauditlog.FieldRequestID:
		return m.RequestID()
	case loginauditlog.FieldTraceID:
		return m.TraceID()
	case loginauditlog.FieldActionType:
		return m.ActionType()
	case loginauditlog.FieldStatus:
		return m.Status()
	case loginauditlog.FieldLoginMethod:
		return m.LoginMethod()
	case loginauditlog.FieldFailureReason:
		return m.FailureReason()
	case loginauditlog.FieldMfaStatus:
		return m.MfaStatus()
	case loginauditlog.FieldRiskScore:
		return m.RiskScore()
	case loginauditlog.FieldRiskLevel:
		return m.RiskLevel()
	case loginauditlog.FieldRiskFactors:
		return m.RiskFactors()
	case loginauditlog.FieldLogHash:
		return m.LogHash()
	case loginauditlog.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginAuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginauditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginauditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case loginauditlog.FieldUserID:
		return m.OldUserID(ctx)
	case loginauditlog.FieldUsername:
		return m.OldUsername(ctx)
	case loginauditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case loginauditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case loginauditlog.FieldSessionID:
		return m.OldSessionID(ctx)
	case loginauditlog.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case loginauditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case loginauditlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case loginauditlog.FieldActionType:
		return m.OldActionType(ctx)
	case loginauditlog.FieldStatus:
		return m.OldStatus(ctx)
	case loginauditlog.FieldLoginMethod:
		return m.OldLoginMethod(ctx)
	case loginauditlog.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case loginauditlog.FieldMfaStatus:
		return m.OldMfaStatus(ctx)
	case loginauditlog.FieldRiskScore:
		return m.OldRiskScore(ctx)
	case loginauditlog.FieldRiskLevel:
		return m.OldRiskLevel(ctx)
	case loginauditlog.FieldRiskFactors:
		return m.OldRiskFactors(ctx)
	case loginauditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case loginauditlog.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown LoginAuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginauditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginauditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case loginauditlog.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case loginauditlog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case loginauditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case loginauditlog.FieldGeoLocation:
		v, ok := value.(*auditpb.GeoLocation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case loginauditlog.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case loginauditlog.FieldDeviceInfo:
		v, ok := value.(*auditpb.DeviceInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case loginauditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case loginauditlog.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case loginauditlog.FieldActionType:
		v, ok := value.(loginauditlog.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case loginauditlog.FieldStatus:
		v, ok := value.(loginauditlog.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case loginauditlog.FieldLoginMethod:
		v, ok := value.(loginauditlog.LoginMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginMethod(v)
		return nil
	case loginauditlog.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case loginauditlog.FieldMfaStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaStatus(v)
		return nil
	case loginauditlog.FieldRiskScore:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskScore(v)
		return nil
	case loginauditlog.FieldRiskLevel:
		v, ok := value.(loginauditlog.RiskLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLevel(v)
		return nil
	case loginauditlog.FieldRiskFactors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskFactors(v)
		return nil
	case loginauditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case loginauditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown LoginAuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginAuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, loginauditlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, loginauditlog.FieldUserID)
	}
	if m.addrisk_score != nil {
		fields = append(fields, loginauditlog.FieldRiskScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginAuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loginauditlog.FieldTenantID:
		return m.AddedTenantID()
	case loginauditlog.FieldUserID:
		return m.AddedUserID()
	case loginauditlog.FieldRiskScore:
		return m.AddedRiskScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loginauditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case loginauditlog.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case loginauditlog.FieldRiskScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRiskScore(v)
		return nil
	}
	return fmt.Errorf("unknown LoginAuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginAuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginauditlog.FieldCreatedAt) {
		fields = append(fields, loginauditlog.FieldCreatedAt)
	}
	if m.FieldCleared(loginauditlog.FieldTenantID) {
		fields = append(fields, loginauditlog.FieldTenantID)
	}
	if m.FieldCleared(loginauditlog.FieldUserID) {
		fields = append(fields, loginauditlog.FieldUserID)
	}
	if m.FieldCleared(loginauditlog.FieldUsername) {
		fields = append(fields, loginauditlog.FieldUsername)
	}
	if m.FieldCleared(loginauditlog.FieldIPAddress) {
		fields = append(fields, loginauditlog.FieldIPAddress)
	}
	if m.FieldCleared(loginauditlog.FieldGeoLocation) {
		fields = append(fields, loginauditlog.FieldGeoLocation)
	}
	if m.FieldCleared(loginauditlog.FieldSessionID) {
		fields = append(fields, loginauditlog.FieldSessionID)
	}
	if m.FieldCleared(loginauditlog.FieldDeviceInfo) {
		fields = append(fields, loginauditlog.FieldDeviceInfo)
	}
	if m.FieldCleared(loginauditlog.FieldRequestID) {
		fields = append(fields, loginauditlog.FieldRequestID)
	}
	if m.FieldCleared(loginauditlog.FieldTraceID) {
		fields = append(fields, loginauditlog.FieldTraceID)
	}
	if m.FieldCleared(loginauditlog.FieldActionType) {
		fields = append(fields, loginauditlog.FieldActionType)
	}
	if m.FieldCleared(loginauditlog.FieldStatus) {
		fields = append(fields, loginauditlog.FieldStatus)
	}
	if m.FieldCleared(loginauditlog.FieldLoginMethod) {
		fields = append(fields, loginauditlog.FieldLoginMethod)
	}
	if m.FieldCleared(loginauditlog.FieldFailureReason) {
		fields = append(fields, loginauditlog.FieldFailureReason)
	}
	if m.FieldCleared(loginauditlog.FieldMfaStatus) {
		fields = append(fields, loginauditlog.FieldMfaStatus)
	}
	if m.FieldCleared(loginauditlog.FieldRiskScore) {
		fields = append(fields, loginauditlog.FieldRiskScore)
	}
	if m.FieldCleared(loginauditlog.FieldRiskLevel) {
		fields = append(fields, loginauditlog.FieldRiskLevel)
	}
	if m.FieldCleared(loginauditlog.FieldRiskFactors) {
		fields = append(fields, loginauditlog.FieldRiskFactors)
	}
	if m.FieldCleared(loginauditlog.FieldLogHash) {
		fields = append(fields, loginauditlog.FieldLogHash)
	}
	if m.FieldCleared(loginauditlog.FieldSignature) {
		fields = append(fields, loginauditlog.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginAuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginAuditLogMutation) ClearField(name string) error {
	switch name {
	case loginauditlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case loginauditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case loginauditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case loginauditlog.FieldUsername:
		m.ClearUsername()
		return nil
	case loginauditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case loginauditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case loginauditlog.FieldSessionID:
		m.ClearSessionID()
		return nil
	case loginauditlog.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case loginauditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case loginauditlog.FieldTraceID:
		m.ClearTraceID()
		return nil
	case loginauditlog.FieldActionType:
		m.ClearActionType()
		return nil
	case loginauditlog.FieldStatus:
		m.ClearStatus()
		return nil
	case loginauditlog.FieldLoginMethod:
		m.ClearLoginMethod()
		return nil
	case loginauditlog.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case loginauditlog.FieldMfaStatus:
		m.ClearMfaStatus()
		return nil
	case loginauditlog.FieldRiskScore:
		m.ClearRiskScore()
		return nil
	case loginauditlog.FieldRiskLevel:
		m.ClearRiskLevel()
		return nil
	case loginauditlog.FieldRiskFactors:
		m.ClearRiskFactors()
		return nil
	case loginauditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case loginauditlog.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown LoginAuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginAuditLogMutation) ResetField(name string) error {
	switch name {
	case loginauditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginauditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case loginauditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case loginauditlog.FieldUsername:
		m.ResetUsername()
		return nil
	case loginauditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case loginauditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case loginauditlog.FieldSessionID:
		m.ResetSessionID()
		return nil
	case loginauditlog.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case loginauditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case loginauditlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case loginauditlog.FieldActionType:
		m.ResetActionType()
		return nil
	case loginauditlog.FieldStatus:
		m.ResetStatus()
		return nil
	case loginauditlog.FieldLoginMethod:
		m.ResetLoginMethod()
		return nil
	case loginauditlog.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case loginauditlog.FieldMfaStatus:
		m.ResetMfaStatus()
		return nil
	case loginauditlog.FieldRiskScore:
		m.ResetRiskScore()
		return nil
	case loginauditlog.FieldRiskLevel:
		m.ResetRiskLevel()
		return nil
	case loginauditlog.FieldRiskFactors:
		m.ResetRiskFactors()
		return nil
	case loginauditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case loginauditlog.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown LoginAuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginAuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginAuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginAuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginAuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginAuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginAuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginAuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginAuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginAuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginAuditLog edge %s", name)
}

// LoginPolicyMutation represents an operation that mutates the LoginPolicy nodes in the graph.
type LoginPolicyMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	updated_by    *uint32
	addupdated_by *int32
	deleted_by    *uint32
	adddeleted_by *int32
	tenant_id     *uint32
	addtenant_id  *int32
	target_id     *uint32
	addtarget_id  *int32
	value         *string
	reason        *string
	_type         *loginpolicy.Type
	method        *loginpolicy.Method
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LoginPolicy, error)
	predicates    []predicate.LoginPolicy
}

var _ ent.Mutation = (*LoginPolicyMutation)(nil)

// loginpolicyOption allows management of the mutation configuration using functional options.
type loginpolicyOption func(*LoginPolicyMutation)

// newLoginPolicyMutation creates new mutation for the LoginPolicy entity.
func newLoginPolicyMutation(c config, op Op, opts ...loginpolicyOption) *LoginPolicyMutation {
	m := &LoginPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginPolicyID sets the ID field of the mutation.
func withLoginPolicyID(id uint32) loginpolicyOption {
	return func(m *LoginPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginPolicy
		)
		m.oldValue = func(ctx context.Context) (*LoginPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginPolicy sets the old LoginPolicy of the mutation.
func withLoginPolicy(node *LoginPolicy) loginpolicyOption {
	return func(m *LoginPolicyMutation) {
		m.oldValue = func(context.Context) (*LoginPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginPolicy entities.
func (m *LoginPolicyMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginPolicyMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginPolicyMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LoginPolicyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[loginpolicy.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LoginPolicyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, loginpolicy.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LoginPolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[loginpolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LoginPolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, loginpolicy.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoginPolicyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoginPolicyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LoginPolicyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[loginpolicy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LoginPolicyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoginPolicyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, loginpolicy.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *LoginPolicyMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LoginPolicyMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *LoginPolicyMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *LoginPolicyMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *LoginPolicyMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[loginpolicy.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *LoginPolicyMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LoginPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, loginpolicy.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LoginPolicyMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LoginPolicyMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *LoginPolicyMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *LoginPolicyMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *LoginPolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[loginpolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *LoginPolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LoginPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, loginpolicy.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *LoginPolicyMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *LoginPolicyMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *LoginPolicyMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *LoginPolicyMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *LoginPolicyMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[loginpolicy.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *LoginPolicyMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *LoginPolicyMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, loginpolicy.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *LoginPolicyMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LoginPolicyMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *LoginPolicyMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *LoginPolicyMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LoginPolicyMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[loginpolicy.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LoginPolicyMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LoginPolicyMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, loginpolicy.FieldTenantID)
}

// SetTargetID sets the "target_id" field.
func (m *LoginPolicyMutation) SetTargetID(u uint32) {
	m.target_id = &u
	m.addtarget_id = nil
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *LoginPolicyMutation) TargetID() (r uint32, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldTargetID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// AddTargetID adds u to the "target_id" field.
func (m *LoginPolicyMutation) AddTargetID(u int32) {
	if m.addtarget_id != nil {
		*m.addtarget_id += u
	} else {
		m.addtarget_id = &u
	}
}

// AddedTargetID returns the value that was added to the "target_id" field in this mutation.
func (m *LoginPolicyMutation) AddedTargetID() (r int32, exists bool) {
	v := m.addtarget_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetID clears the value of the "target_id" field.
func (m *LoginPolicyMutation) ClearTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	m.clearedFields[loginpolicy.FieldTargetID] = struct{}{}
}

// TargetIDCleared returns if the "target_id" field was cleared in this mutation.
func (m *LoginPolicyMutation) TargetIDCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldTargetID]
	return ok
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *LoginPolicyMutation) ResetTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	delete(m.clearedFields, loginpolicy.FieldTargetID)
}

// SetValue sets the "value" field.
func (m *LoginPolicyMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *LoginPolicyMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *LoginPolicyMutation) ClearValue() {
	m.value = nil
	m.clearedFields[loginpolicy.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *LoginPolicyMutation) ValueCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *LoginPolicyMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, loginpolicy.FieldValue)
}

// SetReason sets the "reason" field.
func (m *LoginPolicyMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *LoginPolicyMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *LoginPolicyMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[loginpolicy.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *LoginPolicyMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *LoginPolicyMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, loginpolicy.FieldReason)
}

// SetType sets the "type" field.
func (m *LoginPolicyMutation) SetType(l loginpolicy.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LoginPolicyMutation) GetType() (r loginpolicy.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldType(ctx context.Context) (v *loginpolicy.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *LoginPolicyMutation) ClearType() {
	m._type = nil
	m.clearedFields[loginpolicy.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *LoginPolicyMutation) TypeCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *LoginPolicyMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, loginpolicy.FieldType)
}

// SetMethod sets the "method" field.
func (m *LoginPolicyMutation) SetMethod(l loginpolicy.Method) {
	m.method = &l
}

// Method returns the value of the "method" field in the mutation.
func (m *LoginPolicyMutation) Method() (r loginpolicy.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the LoginPolicy entity.
// If the LoginPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginPolicyMutation) OldMethod(ctx context.Context) (v *loginpolicy.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *LoginPolicyMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[loginpolicy.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *LoginPolicyMutation) MethodCleared() bool {
	_, ok := m.clearedFields[loginpolicy.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *LoginPolicyMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, loginpolicy.FieldMethod)
}

// Where appends a list predicates to the LoginPolicyMutation builder.
func (m *LoginPolicyMutation) Where(ps ...predicate.LoginPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginPolicy).
func (m *LoginPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginPolicyMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, loginpolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loginpolicy.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loginpolicy.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, loginpolicy.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, loginpolicy.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, loginpolicy.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, loginpolicy.FieldTenantID)
	}
	if m.target_id != nil {
		fields = append(fields, loginpolicy.FieldTargetID)
	}
	if m.value != nil {
		fields = append(fields, loginpolicy.FieldValue)
	}
	if m.reason != nil {
		fields = append(fields, loginpolicy.FieldReason)
	}
	if m._type != nil {
		fields = append(fields, loginpolicy.FieldType)
	}
	if m.method != nil {
		fields = append(fields, loginpolicy.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case loginpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case loginpolicy.FieldDeletedAt:
		return m.DeletedAt()
	case loginpolicy.FieldCreatedBy:
		return m.CreatedBy()
	case loginpolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case loginpolicy.FieldDeletedBy:
		return m.DeletedBy()
	case loginpolicy.FieldTenantID:
		return m.TenantID()
	case loginpolicy.FieldTargetID:
		return m.TargetID()
	case loginpolicy.FieldValue:
		return m.Value()
	case loginpolicy.FieldReason:
		return m.Reason()
	case loginpolicy.FieldType:
		return m.GetType()
	case loginpolicy.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loginpolicy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loginpolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case loginpolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case loginpolicy.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case loginpolicy.FieldTenantID:
		return m.OldTenantID(ctx)
	case loginpolicy.FieldTargetID:
		return m.OldTargetID(ctx)
	case loginpolicy.FieldValue:
		return m.OldValue(ctx)
	case loginpolicy.FieldReason:
		return m.OldReason(ctx)
	case loginpolicy.FieldType:
		return m.OldType(ctx)
	case loginpolicy.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown LoginPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loginpolicy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loginpolicy.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case loginpolicy.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case loginpolicy.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case loginpolicy.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case loginpolicy.FieldTargetID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case loginpolicy.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case loginpolicy.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case loginpolicy.FieldType:
		v, ok := value.(loginpolicy.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case loginpolicy.FieldMethod:
		v, ok := value.(loginpolicy.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown LoginPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, loginpolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, loginpolicy.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, loginpolicy.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, loginpolicy.FieldTenantID)
	}
	if m.addtarget_id != nil {
		fields = append(fields, loginpolicy.FieldTargetID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loginpolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case loginpolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case loginpolicy.FieldDeletedBy:
		return m.AddedDeletedBy()
	case loginpolicy.FieldTenantID:
		return m.AddedTenantID()
	case loginpolicy.FieldTargetID:
		return m.AddedTargetID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loginpolicy.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case loginpolicy.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case loginpolicy.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case loginpolicy.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case loginpolicy.FieldTargetID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetID(v)
		return nil
	}
	return fmt.Errorf("unknown LoginPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginpolicy.FieldCreatedAt) {
		fields = append(fields, loginpolicy.FieldCreatedAt)
	}
	if m.FieldCleared(loginpolicy.FieldUpdatedAt) {
		fields = append(fields, loginpolicy.FieldUpdatedAt)
	}
	if m.FieldCleared(loginpolicy.FieldDeletedAt) {
		fields = append(fields, loginpolicy.FieldDeletedAt)
	}
	if m.FieldCleared(loginpolicy.FieldCreatedBy) {
		fields = append(fields, loginpolicy.FieldCreatedBy)
	}
	if m.FieldCleared(loginpolicy.FieldUpdatedBy) {
		fields = append(fields, loginpolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(loginpolicy.FieldDeletedBy) {
		fields = append(fields, loginpolicy.FieldDeletedBy)
	}
	if m.FieldCleared(loginpolicy.FieldTenantID) {
		fields = append(fields, loginpolicy.FieldTenantID)
	}
	if m.FieldCleared(loginpolicy.FieldTargetID) {
		fields = append(fields, loginpolicy.FieldTargetID)
	}
	if m.FieldCleared(loginpolicy.FieldValue) {
		fields = append(fields, loginpolicy.FieldValue)
	}
	if m.FieldCleared(loginpolicy.FieldReason) {
		fields = append(fields, loginpolicy.FieldReason)
	}
	if m.FieldCleared(loginpolicy.FieldType) {
		fields = append(fields, loginpolicy.FieldType)
	}
	if m.FieldCleared(loginpolicy.FieldMethod) {
		fields = append(fields, loginpolicy.FieldMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginPolicyMutation) ClearField(name string) error {
	switch name {
	case loginpolicy.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case loginpolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case loginpolicy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case loginpolicy.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case loginpolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case loginpolicy.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case loginpolicy.FieldTenantID:
		m.ClearTenantID()
		return nil
	case loginpolicy.FieldTargetID:
		m.ClearTargetID()
		return nil
	case loginpolicy.FieldValue:
		m.ClearValue()
		return nil
	case loginpolicy.FieldReason:
		m.ClearReason()
		return nil
	case loginpolicy.FieldType:
		m.ClearType()
		return nil
	case loginpolicy.FieldMethod:
		m.ClearMethod()
		return nil
	}
	return fmt.Errorf("unknown LoginPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginPolicyMutation) ResetField(name string) error {
	switch name {
	case loginpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loginpolicy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loginpolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case loginpolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case loginpolicy.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case loginpolicy.FieldTenantID:
		m.ResetTenantID()
		return nil
	case loginpolicy.FieldTargetID:
		m.ResetTargetID()
		return nil
	case loginpolicy.FieldValue:
		m.ResetValue()
		return nil
	case loginpolicy.FieldReason:
		m.ResetReason()
		return nil
	case loginpolicy.FieldType:
		m.ResetType()
		return nil
	case loginpolicy.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown LoginPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginPolicyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginPolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginPolicyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginPolicyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginPolicyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginPolicy edge %s", name)
}

// MembershipMutation represents an operation that mutates the Membership nodes in the graph.
type MembershipMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	created_by     *uint32
	addcreated_by  *int32
	updated_by     *uint32
	addupdated_by  *int32
	deleted_by     *uint32
	adddeleted_by  *int32
	tenant_id      *uint32
	addtenant_id   *int32
	remark         *string
	user_id        *uint32
	adduser_id     *int32
	org_unit_id    *uint32
	addorg_unit_id *int32
	position_id    *uint32
	addposition_id *int32
	role_id        *uint32
	addrole_id     *int32
	is_primary     *bool
	start_at       *time.Time
	end_at         *time.Time
	assigned_at    *time.Time
	assigned_by    *uint32
	addassigned_by *int32
	joined_at      *time.Time
	status         *membership.Status
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Membership, error)
	predicates     []predicate.Membership
}

var _ ent.Mutation = (*MembershipMutation)(nil)

// membershipOption allows management of the mutation configuration using functional options.
type membershipOption func(*MembershipMutation)

// newMembershipMutation creates new mutation for the Membership entity.
func newMembershipMutation(c config, op Op, opts ...membershipOption) *MembershipMutation {
	m := &MembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMembershipID sets the ID field of the mutation.
func withMembershipID(id uint32) membershipOption {
	return func(m *MembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *Membership
		)
		m.oldValue = func(ctx context.Context) (*Membership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Membership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMembership sets the old Membership of the mutation.
func withMembership(node *Membership) membershipOption {
	return func(m *MembershipMutation) {
		m.oldValue = func(context.Context) (*Membership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Membership entities.
func (m *MembershipMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MembershipMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MembershipMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Membership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MembershipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MembershipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MembershipMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membership.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MembershipMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MembershipMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membership.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MembershipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MembershipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MembershipMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membership.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MembershipMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MembershipMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membership.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MembershipMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MembershipMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MembershipMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[membership.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MembershipMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MembershipMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, membership.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *MembershipMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MembershipMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *MembershipMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MembershipMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MembershipMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[membership.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MembershipMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[membership.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MembershipMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, membership.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MembershipMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MembershipMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *MembershipMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MembershipMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MembershipMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[membership.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MembershipMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[membership.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MembershipMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, membership.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MembershipMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MembershipMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *MembershipMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *MembershipMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MembershipMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[membership.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MembershipMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[membership.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MembershipMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, membership.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *MembershipMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MembershipMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *MembershipMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MembershipMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *MembershipMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[membership.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *MembershipMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[membership.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MembershipMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, membership.FieldTenantID)
}

// SetRemark sets the "remark" field.
func (m *MembershipMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MembershipMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MembershipMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[membership.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MembershipMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[membership.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MembershipMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, membership.FieldRemark)
}

// SetUserID sets the "user_id" field.
func (m *MembershipMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MembershipMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *MembershipMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *MembershipMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MembershipMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOrgUnitID sets the "org_unit_id" field.
func (m *MembershipMutation) SetOrgUnitID(u uint32) {
	m.org_unit_id = &u
	m.addorg_unit_id = nil
}

// OrgUnitID returns the value of the "org_unit_id" field in the mutation.
func (m *MembershipMutation) OrgUnitID() (r uint32, exists bool) {
	v := m.org_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitID returns the old "org_unit_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldOrgUnitID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitID: %w", err)
	}
	return oldValue.OrgUnitID, nil
}

// AddOrgUnitID adds u to the "org_unit_id" field.
func (m *MembershipMutation) AddOrgUnitID(u int32) {
	if m.addorg_unit_id != nil {
		*m.addorg_unit_id += u
	} else {
		m.addorg_unit_id = &u
	}
}

// AddedOrgUnitID returns the value that was added to the "org_unit_id" field in this mutation.
func (m *MembershipMutation) AddedOrgUnitID() (r int32, exists bool) {
	v := m.addorg_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrgUnitID clears the value of the "org_unit_id" field.
func (m *MembershipMutation) ClearOrgUnitID() {
	m.org_unit_id = nil
	m.addorg_unit_id = nil
	m.clearedFields[membership.FieldOrgUnitID] = struct{}{}
}

// OrgUnitIDCleared returns if the "org_unit_id" field was cleared in this mutation.
func (m *MembershipMutation) OrgUnitIDCleared() bool {
	_, ok := m.clearedFields[membership.FieldOrgUnitID]
	return ok
}

// ResetOrgUnitID resets all changes to the "org_unit_id" field.
func (m *MembershipMutation) ResetOrgUnitID() {
	m.org_unit_id = nil
	m.addorg_unit_id = nil
	delete(m.clearedFields, membership.FieldOrgUnitID)
}

// SetPositionID sets the "position_id" field.
func (m *MembershipMutation) SetPositionID(u uint32) {
	m.position_id = &u
	m.addposition_id = nil
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *MembershipMutation) PositionID() (r uint32, exists bool) {
	v := m.position_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldPositionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// AddPositionID adds u to the "position_id" field.
func (m *MembershipMutation) AddPositionID(u int32) {
	if m.addposition_id != nil {
		*m.addposition_id += u
	} else {
		m.addposition_id = &u
	}
}

// AddedPositionID returns the value that was added to the "position_id" field in this mutation.
func (m *MembershipMutation) AddedPositionID() (r int32, exists bool) {
	v := m.addposition_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPositionID clears the value of the "position_id" field.
func (m *MembershipMutation) ClearPositionID() {
	m.position_id = nil
	m.addposition_id = nil
	m.clearedFields[membership.FieldPositionID] = struct{}{}
}

// PositionIDCleared returns if the "position_id" field was cleared in this mutation.
func (m *MembershipMutation) PositionIDCleared() bool {
	_, ok := m.clearedFields[membership.FieldPositionID]
	return ok
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *MembershipMutation) ResetPositionID() {
	m.position_id = nil
	m.addposition_id = nil
	delete(m.clearedFields, membership.FieldPositionID)
}

// SetRoleID sets the "role_id" field.
func (m *MembershipMutation) SetRoleID(u uint32) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *MembershipMutation) RoleID() (r uint32, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldRoleID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *MembershipMutation) AddRoleID(u int32) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *MembershipMutation) AddedRoleID() (r int32, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *MembershipMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[membership.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *MembershipMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[membership.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *MembershipMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, membership.FieldRoleID)
}

// SetIsPrimary sets the "is_primary" field.
func (m *MembershipMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *MembershipMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *MembershipMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetStartAt sets the "start_at" field.
func (m *MembershipMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *MembershipMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *MembershipMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[membership.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *MembershipMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *MembershipMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, membership.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *MembershipMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *MembershipMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *MembershipMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[membership.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *MembershipMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *MembershipMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, membership.FieldEndAt)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *MembershipMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *MembershipMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ClearAssignedAt clears the value of the "assigned_at" field.
func (m *MembershipMutation) ClearAssignedAt() {
	m.assigned_at = nil
	m.clearedFields[membership.FieldAssignedAt] = struct{}{}
}

// AssignedAtCleared returns if the "assigned_at" field was cleared in this mutation.
func (m *MembershipMutation) AssignedAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldAssignedAt]
	return ok
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *MembershipMutation) ResetAssignedAt() {
	m.assigned_at = nil
	delete(m.clearedFields, membership.FieldAssignedAt)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *MembershipMutation) SetAssignedBy(u uint32) {
	m.assigned_by = &u
	m.addassigned_by = nil
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *MembershipMutation) AssignedBy() (r uint32, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldAssignedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// AddAssignedBy adds u to the "assigned_by" field.
func (m *MembershipMutation) AddAssignedBy(u int32) {
	if m.addassigned_by != nil {
		*m.addassigned_by += u
	} else {
		m.addassigned_by = &u
	}
}

// AddedAssignedBy returns the value that was added to the "assigned_by" field in this mutation.
func (m *MembershipMutation) AddedAssignedBy() (r int32, exists bool) {
	v := m.addassigned_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *MembershipMutation) ClearAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	m.clearedFields[membership.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *MembershipMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[membership.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *MembershipMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	delete(m.clearedFields, membership.FieldAssignedBy)
}

// SetJoinedAt sets the "joined_at" field.
func (m *MembershipMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *MembershipMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldJoinedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ClearJoinedAt clears the value of the "joined_at" field.
func (m *MembershipMutation) ClearJoinedAt() {
	m.joined_at = nil
	m.clearedFields[membership.FieldJoinedAt] = struct{}{}
}

// JoinedAtCleared returns if the "joined_at" field was cleared in this mutation.
func (m *MembershipMutation) JoinedAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldJoinedAt]
	return ok
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *MembershipMutation) ResetJoinedAt() {
	m.joined_at = nil
	delete(m.clearedFields, membership.FieldJoinedAt)
}

// SetStatus sets the "status" field.
func (m *MembershipMutation) SetStatus(value membership.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MembershipMutation) Status() (r membership.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldStatus(ctx context.Context) (v *membership.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MembershipMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[membership.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MembershipMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membership.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MembershipMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, membership.FieldStatus)
}

// Where appends a list predicates to the MembershipMutation builder.
func (m *MembershipMutation) Where(ps ...predicate.Membership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Membership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Membership).
func (m *MembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MembershipMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, membership.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membership.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, membership.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, membership.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, membership.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, membership.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, membership.FieldTenantID)
	}
	if m.remark != nil {
		fields = append(fields, membership.FieldRemark)
	}
	if m.user_id != nil {
		fields = append(fields, membership.FieldUserID)
	}
	if m.org_unit_id != nil {
		fields = append(fields, membership.FieldOrgUnitID)
	}
	if m.position_id != nil {
		fields = append(fields, membership.FieldPositionID)
	}
	if m.role_id != nil {
		fields = append(fields, membership.FieldRoleID)
	}
	if m.is_primary != nil {
		fields = append(fields, membership.FieldIsPrimary)
	}
	if m.start_at != nil {
		fields = append(fields, membership.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, membership.FieldEndAt)
	}
	if m.assigned_at != nil {
		fields = append(fields, membership.FieldAssignedAt)
	}
	if m.assigned_by != nil {
		fields = append(fields, membership.FieldAssignedBy)
	}
	if m.joined_at != nil {
		fields = append(fields, membership.FieldJoinedAt)
	}
	if m.status != nil {
		fields = append(fields, membership.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membership.FieldCreatedAt:
		return m.CreatedAt()
	case membership.FieldUpdatedAt:
		return m.UpdatedAt()
	case membership.FieldDeletedAt:
		return m.DeletedAt()
	case membership.FieldCreatedBy:
		return m.CreatedBy()
	case membership.FieldUpdatedBy:
		return m.UpdatedBy()
	case membership.FieldDeletedBy:
		return m.DeletedBy()
	case membership.FieldTenantID:
		return m.TenantID()
	case membership.FieldRemark:
		return m.Remark()
	case membership.FieldUserID:
		return m.UserID()
	case membership.FieldOrgUnitID:
		return m.OrgUnitID()
	case membership.FieldPositionID:
		return m.PositionID()
	case membership.FieldRoleID:
		return m.RoleID()
	case membership.FieldIsPrimary:
		return m.IsPrimary()
	case membership.FieldStartAt:
		return m.StartAt()
	case membership.FieldEndAt:
		return m.EndAt()
	case membership.FieldAssignedAt:
		return m.AssignedAt()
	case membership.FieldAssignedBy:
		return m.AssignedBy()
	case membership.FieldJoinedAt:
		return m.JoinedAt()
	case membership.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membership.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membership.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membership.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case membership.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case membership.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case membership.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case membership.FieldTenantID:
		return m.OldTenantID(ctx)
	case membership.FieldRemark:
		return m.OldRemark(ctx)
	case membership.FieldUserID:
		return m.OldUserID(ctx)
	case membership.FieldOrgUnitID:
		return m.OldOrgUnitID(ctx)
	case membership.FieldPositionID:
		return m.OldPositionID(ctx)
	case membership.FieldRoleID:
		return m.OldRoleID(ctx)
	case membership.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case membership.FieldStartAt:
		return m.OldStartAt(ctx)
	case membership.FieldEndAt:
		return m.OldEndAt(ctx)
	case membership.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case membership.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case membership.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case membership.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Membership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membership.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membership.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membership.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case membership.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case membership.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case membership.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case membership.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case membership.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case membership.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case membership.FieldOrgUnitID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitID(v)
		return nil
	case membership.FieldPositionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case membership.FieldRoleID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case membership.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case membership.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case membership.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case membership.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case membership.FieldAssignedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case membership.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case membership.FieldStatus:
		v, ok := value.(membership.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MembershipMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, membership.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, membership.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, membership.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, membership.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, membership.FieldUserID)
	}
	if m.addorg_unit_id != nil {
		fields = append(fields, membership.FieldOrgUnitID)
	}
	if m.addposition_id != nil {
		fields = append(fields, membership.FieldPositionID)
	}
	if m.addrole_id != nil {
		fields = append(fields, membership.FieldRoleID)
	}
	if m.addassigned_by != nil {
		fields = append(fields, membership.FieldAssignedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MembershipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membership.FieldCreatedBy:
		return m.AddedCreatedBy()
	case membership.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case membership.FieldDeletedBy:
		return m.AddedDeletedBy()
	case membership.FieldTenantID:
		return m.AddedTenantID()
	case membership.FieldUserID:
		return m.AddedUserID()
	case membership.FieldOrgUnitID:
		return m.AddedOrgUnitID()
	case membership.FieldPositionID:
		return m.AddedPositionID()
	case membership.FieldRoleID:
		return m.AddedRoleID()
	case membership.FieldAssignedBy:
		return m.AddedAssignedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membership.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case membership.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case membership.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case membership.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case membership.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case membership.FieldOrgUnitID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgUnitID(v)
		return nil
	case membership.FieldPositionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionID(v)
		return nil
	case membership.FieldRoleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case membership.FieldAssignedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Membership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MembershipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membership.FieldCreatedAt) {
		fields = append(fields, membership.FieldCreatedAt)
	}
	if m.FieldCleared(membership.FieldUpdatedAt) {
		fields = append(fields, membership.FieldUpdatedAt)
	}
	if m.FieldCleared(membership.FieldDeletedAt) {
		fields = append(fields, membership.FieldDeletedAt)
	}
	if m.FieldCleared(membership.FieldCreatedBy) {
		fields = append(fields, membership.FieldCreatedBy)
	}
	if m.FieldCleared(membership.FieldUpdatedBy) {
		fields = append(fields, membership.FieldUpdatedBy)
	}
	if m.FieldCleared(membership.FieldDeletedBy) {
		fields = append(fields, membership.FieldDeletedBy)
	}
	if m.FieldCleared(membership.FieldTenantID) {
		fields = append(fields, membership.FieldTenantID)
	}
	if m.FieldCleared(membership.FieldRemark) {
		fields = append(fields, membership.FieldRemark)
	}
	if m.FieldCleared(membership.FieldOrgUnitID) {
		fields = append(fields, membership.FieldOrgUnitID)
	}
	if m.FieldCleared(membership.FieldPositionID) {
		fields = append(fields, membership.FieldPositionID)
	}
	if m.FieldCleared(membership.FieldRoleID) {
		fields = append(fields, membership.FieldRoleID)
	}
	if m.FieldCleared(membership.FieldStartAt) {
		fields = append(fields, membership.FieldStartAt)
	}
	if m.FieldCleared(membership.FieldEndAt) {
		fields = append(fields, membership.FieldEndAt)
	}
	if m.FieldCleared(membership.FieldAssignedAt) {
		fields = append(fields, membership.FieldAssignedAt)
	}
	if m.FieldCleared(membership.FieldAssignedBy) {
		fields = append(fields, membership.FieldAssignedBy)
	}
	if m.FieldCleared(membership.FieldJoinedAt) {
		fields = append(fields, membership.FieldJoinedAt)
	}
	if m.FieldCleared(membership.FieldStatus) {
		fields = append(fields, membership.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MembershipMutation) ClearField(name string) error {
	switch name {
	case membership.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membership.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membership.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case membership.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case membership.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case membership.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case membership.FieldTenantID:
		m.ClearTenantID()
		return nil
	case membership.FieldRemark:
		m.ClearRemark()
		return nil
	case membership.FieldOrgUnitID:
		m.ClearOrgUnitID()
		return nil
	case membership.FieldPositionID:
		m.ClearPositionID()
		return nil
	case membership.FieldRoleID:
		m.ClearRoleID()
		return nil
	case membership.FieldStartAt:
		m.ClearStartAt()
		return nil
	case membership.FieldEndAt:
		m.ClearEndAt()
		return nil
	case membership.FieldAssignedAt:
		m.ClearAssignedAt()
		return nil
	case membership.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case membership.FieldJoinedAt:
		m.ClearJoinedAt()
		return nil
	case membership.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Membership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MembershipMutation) ResetField(name string) error {
	switch name {
	case membership.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membership.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membership.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case membership.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case membership.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case membership.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case membership.FieldTenantID:
		m.ResetTenantID()
		return nil
	case membership.FieldRemark:
		m.ResetRemark()
		return nil
	case membership.FieldUserID:
		m.ResetUserID()
		return nil
	case membership.FieldOrgUnitID:
		m.ResetOrgUnitID()
		return nil
	case membership.FieldPositionID:
		m.ResetPositionID()
		return nil
	case membership.FieldRoleID:
		m.ResetRoleID()
		return nil
	case membership.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case membership.FieldStartAt:
		m.ResetStartAt()
		return nil
	case membership.FieldEndAt:
		m.ResetEndAt()
		return nil
	case membership.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case membership.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case membership.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case membership.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MembershipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MembershipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MembershipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MembershipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Membership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MembershipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Membership edge %s", name)
}

// MembershipOrgUnitMutation represents an operation that mutates the MembershipOrgUnit nodes in the graph.
type MembershipOrgUnitMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	tenant_id        *uint32
	addtenant_id     *int32
	remark           *string
	membership_id    *uint32
	addmembership_id *int32
	org_unit_id      *uint32
	addorg_unit_id   *int32
	position_id      *uint32
	addposition_id   *int32
	role_id          *uint32
	addrole_id       *int32
	start_at         *time.Time
	end_at           *time.Time
	assigned_at      *time.Time
	assigned_by      *uint32
	addassigned_by   *int32
	is_primary       *bool
	status           *membershiporgunit.Status
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*MembershipOrgUnit, error)
	predicates       []predicate.MembershipOrgUnit
}

var _ ent.Mutation = (*MembershipOrgUnitMutation)(nil)

// membershiporgunitOption allows management of the mutation configuration using functional options.
type membershiporgunitOption func(*MembershipOrgUnitMutation)

// newMembershipOrgUnitMutation creates new mutation for the MembershipOrgUnit entity.
func newMembershipOrgUnitMutation(c config, op Op, opts ...membershiporgunitOption) *MembershipOrgUnitMutation {
	m := &MembershipOrgUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeMembershipOrgUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMembershipOrgUnitID sets the ID field of the mutation.
func withMembershipOrgUnitID(id uint32) membershiporgunitOption {
	return func(m *MembershipOrgUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *MembershipOrgUnit
		)
		m.oldValue = func(ctx context.Context) (*MembershipOrgUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MembershipOrgUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMembershipOrgUnit sets the old MembershipOrgUnit of the mutation.
func withMembershipOrgUnit(node *MembershipOrgUnit) membershiporgunitOption {
	return func(m *MembershipOrgUnitMutation) {
		m.oldValue = func(context.Context) (*MembershipOrgUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MembershipOrgUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MembershipOrgUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MembershipOrgUnit entities.
func (m *MembershipOrgUnitMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MembershipOrgUnitMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MembershipOrgUnitMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MembershipOrgUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MembershipOrgUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MembershipOrgUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MembershipOrgUnitMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membershiporgunit.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MembershipOrgUnitMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membershiporgunit.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MembershipOrgUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MembershipOrgUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MembershipOrgUnitMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membershiporgunit.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MembershipOrgUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membershiporgunit.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MembershipOrgUnitMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MembershipOrgUnitMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MembershipOrgUnitMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[membershiporgunit.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MembershipOrgUnitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, membershiporgunit.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *MembershipOrgUnitMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MembershipOrgUnitMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *MembershipOrgUnitMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MembershipOrgUnitMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[membershiporgunit.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MembershipOrgUnitMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, membershiporgunit.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MembershipOrgUnitMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MembershipOrgUnitMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *MembershipOrgUnitMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MembershipOrgUnitMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[membershiporgunit.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MembershipOrgUnitMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, membershiporgunit.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MembershipOrgUnitMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MembershipOrgUnitMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *MembershipOrgUnitMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MembershipOrgUnitMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[membershiporgunit.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MembershipOrgUnitMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, membershiporgunit.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *MembershipOrgUnitMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MembershipOrgUnitMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *MembershipOrgUnitMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *MembershipOrgUnitMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[membershiporgunit.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MembershipOrgUnitMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, membershiporgunit.FieldTenantID)
}

// SetRemark sets the "remark" field.
func (m *MembershipOrgUnitMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MembershipOrgUnitMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MembershipOrgUnitMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[membershiporgunit.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MembershipOrgUnitMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, membershiporgunit.FieldRemark)
}

// SetMembershipID sets the "membership_id" field.
func (m *MembershipOrgUnitMutation) SetMembershipID(u uint32) {
	m.membership_id = &u
	m.addmembership_id = nil
}

// MembershipID returns the value of the "membership_id" field in the mutation.
func (m *MembershipOrgUnitMutation) MembershipID() (r uint32, exists bool) {
	v := m.membership_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMembershipID returns the old "membership_id" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldMembershipID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembershipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembershipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembershipID: %w", err)
	}
	return oldValue.MembershipID, nil
}

// AddMembershipID adds u to the "membership_id" field.
func (m *MembershipOrgUnitMutation) AddMembershipID(u int32) {
	if m.addmembership_id != nil {
		*m.addmembership_id += u
	} else {
		m.addmembership_id = &u
	}
}

// AddedMembershipID returns the value that was added to the "membership_id" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedMembershipID() (r int32, exists bool) {
	v := m.addmembership_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipID resets all changes to the "membership_id" field.
func (m *MembershipOrgUnitMutation) ResetMembershipID() {
	m.membership_id = nil
	m.addmembership_id = nil
}

// SetOrgUnitID sets the "org_unit_id" field.
func (m *MembershipOrgUnitMutation) SetOrgUnitID(u uint32) {
	m.org_unit_id = &u
	m.addorg_unit_id = nil
}

// OrgUnitID returns the value of the "org_unit_id" field in the mutation.
func (m *MembershipOrgUnitMutation) OrgUnitID() (r uint32, exists bool) {
	v := m.org_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitID returns the old "org_unit_id" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldOrgUnitID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitID: %w", err)
	}
	return oldValue.OrgUnitID, nil
}

// AddOrgUnitID adds u to the "org_unit_id" field.
func (m *MembershipOrgUnitMutation) AddOrgUnitID(u int32) {
	if m.addorg_unit_id != nil {
		*m.addorg_unit_id += u
	} else {
		m.addorg_unit_id = &u
	}
}

// AddedOrgUnitID returns the value that was added to the "org_unit_id" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedOrgUnitID() (r int32, exists bool) {
	v := m.addorg_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgUnitID resets all changes to the "org_unit_id" field.
func (m *MembershipOrgUnitMutation) ResetOrgUnitID() {
	m.org_unit_id = nil
	m.addorg_unit_id = nil
}

// SetPositionID sets the "position_id" field.
func (m *MembershipOrgUnitMutation) SetPositionID(u uint32) {
	m.position_id = &u
	m.addposition_id = nil
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *MembershipOrgUnitMutation) PositionID() (r uint32, exists bool) {
	v := m.position_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldPositionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// AddPositionID adds u to the "position_id" field.
func (m *MembershipOrgUnitMutation) AddPositionID(u int32) {
	if m.addposition_id != nil {
		*m.addposition_id += u
	} else {
		m.addposition_id = &u
	}
}

// AddedPositionID returns the value that was added to the "position_id" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedPositionID() (r int32, exists bool) {
	v := m.addposition_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPositionID clears the value of the "position_id" field.
func (m *MembershipOrgUnitMutation) ClearPositionID() {
	m.position_id = nil
	m.addposition_id = nil
	m.clearedFields[membershiporgunit.FieldPositionID] = struct{}{}
}

// PositionIDCleared returns if the "position_id" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) PositionIDCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldPositionID]
	return ok
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *MembershipOrgUnitMutation) ResetPositionID() {
	m.position_id = nil
	m.addposition_id = nil
	delete(m.clearedFields, membershiporgunit.FieldPositionID)
}

// SetRoleID sets the "role_id" field.
func (m *MembershipOrgUnitMutation) SetRoleID(u uint32) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *MembershipOrgUnitMutation) RoleID() (r uint32, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldRoleID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *MembershipOrgUnitMutation) AddRoleID(u int32) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedRoleID() (r int32, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *MembershipOrgUnitMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[membershiporgunit.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *MembershipOrgUnitMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, membershiporgunit.FieldRoleID)
}

// SetStartAt sets the "start_at" field.
func (m *MembershipOrgUnitMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *MembershipOrgUnitMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *MembershipOrgUnitMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[membershiporgunit.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *MembershipOrgUnitMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, membershiporgunit.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *MembershipOrgUnitMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *MembershipOrgUnitMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *MembershipOrgUnitMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[membershiporgunit.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *MembershipOrgUnitMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, membershiporgunit.FieldEndAt)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *MembershipOrgUnitMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *MembershipOrgUnitMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ClearAssignedAt clears the value of the "assigned_at" field.
func (m *MembershipOrgUnitMutation) ClearAssignedAt() {
	m.assigned_at = nil
	m.clearedFields[membershiporgunit.FieldAssignedAt] = struct{}{}
}

// AssignedAtCleared returns if the "assigned_at" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) AssignedAtCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldAssignedAt]
	return ok
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *MembershipOrgUnitMutation) ResetAssignedAt() {
	m.assigned_at = nil
	delete(m.clearedFields, membershiporgunit.FieldAssignedAt)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *MembershipOrgUnitMutation) SetAssignedBy(u uint32) {
	m.assigned_by = &u
	m.addassigned_by = nil
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *MembershipOrgUnitMutation) AssignedBy() (r uint32, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldAssignedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// AddAssignedBy adds u to the "assigned_by" field.
func (m *MembershipOrgUnitMutation) AddAssignedBy(u int32) {
	if m.addassigned_by != nil {
		*m.addassigned_by += u
	} else {
		m.addassigned_by = &u
	}
}

// AddedAssignedBy returns the value that was added to the "assigned_by" field in this mutation.
func (m *MembershipOrgUnitMutation) AddedAssignedBy() (r int32, exists bool) {
	v := m.addassigned_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *MembershipOrgUnitMutation) ClearAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	m.clearedFields[membershiporgunit.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *MembershipOrgUnitMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	delete(m.clearedFields, membershiporgunit.FieldAssignedBy)
}

// SetIsPrimary sets the "is_primary" field.
func (m *MembershipOrgUnitMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *MembershipOrgUnitMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *MembershipOrgUnitMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetStatus sets the "status" field.
func (m *MembershipOrgUnitMutation) SetStatus(value membershiporgunit.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MembershipOrgUnitMutation) Status() (r membershiporgunit.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MembershipOrgUnit entity.
// If the MembershipOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipOrgUnitMutation) OldStatus(ctx context.Context) (v *membershiporgunit.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MembershipOrgUnitMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[membershiporgunit.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MembershipOrgUnitMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membershiporgunit.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MembershipOrgUnitMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, membershiporgunit.FieldStatus)
}

// Where appends a list predicates to the MembershipOrgUnitMutation builder.
func (m *MembershipOrgUnitMutation) Where(ps ...predicate.MembershipOrgUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MembershipOrgUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MembershipOrgUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MembershipOrgUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MembershipOrgUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MembershipOrgUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MembershipOrgUnit).
func (m *MembershipOrgUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MembershipOrgUnitMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, membershiporgunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membershiporgunit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, membershiporgunit.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, membershiporgunit.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, membershiporgunit.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, membershiporgunit.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, membershiporgunit.FieldTenantID)
	}
	if m.remark != nil {
		fields = append(fields, membershiporgunit.FieldRemark)
	}
	if m.membership_id != nil {
		fields = append(fields, membershiporgunit.FieldMembershipID)
	}
	if m.org_unit_id != nil {
		fields = append(fields, membershiporgunit.FieldOrgUnitID)
	}
	if m.position_id != nil {
		fields = append(fields, membershiporgunit.FieldPositionID)
	}
	if m.role_id != nil {
		fields = append(fields, membershiporgunit.FieldRoleID)
	}
	if m.start_at != nil {
		fields = append(fields, membershiporgunit.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, membershiporgunit.FieldEndAt)
	}
	if m.assigned_at != nil {
		fields = append(fields, membershiporgunit.FieldAssignedAt)
	}
	if m.assigned_by != nil {
		fields = append(fields, membershiporgunit.FieldAssignedBy)
	}
	if m.is_primary != nil {
		fields = append(fields, membershiporgunit.FieldIsPrimary)
	}
	if m.status != nil {
		fields = append(fields, membershiporgunit.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MembershipOrgUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membershiporgunit.FieldCreatedAt:
		return m.CreatedAt()
	case membershiporgunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case membershiporgunit.FieldDeletedAt:
		return m.DeletedAt()
	case membershiporgunit.FieldCreatedBy:
		return m.CreatedBy()
	case membershiporgunit.FieldUpdatedBy:
		return m.UpdatedBy()
	case membershiporgunit.FieldDeletedBy:
		return m.DeletedBy()
	case membershiporgunit.FieldTenantID:
		return m.TenantID()
	case membershiporgunit.FieldRemark:
		return m.Remark()
	case membershiporgunit.FieldMembershipID:
		return m.MembershipID()
	case membershiporgunit.FieldOrgUnitID:
		return m.OrgUnitID()
	case membershiporgunit.FieldPositionID:
		return m.PositionID()
	case membershiporgunit.FieldRoleID:
		return m.RoleID()
	case membershiporgunit.FieldStartAt:
		return m.StartAt()
	case membershiporgunit.FieldEndAt:
		return m.EndAt()
	case membershiporgunit.FieldAssignedAt:
		return m.AssignedAt()
	case membershiporgunit.FieldAssignedBy:
		return m.AssignedBy()
	case membershiporgunit.FieldIsPrimary:
		return m.IsPrimary()
	case membershiporgunit.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MembershipOrgUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membershiporgunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membershiporgunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membershiporgunit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case membershiporgunit.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case membershiporgunit.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case membershiporgunit.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case membershiporgunit.FieldTenantID:
		return m.OldTenantID(ctx)
	case membershiporgunit.FieldRemark:
		return m.OldRemark(ctx)
	case membershiporgunit.FieldMembershipID:
		return m.OldMembershipID(ctx)
	case membershiporgunit.FieldOrgUnitID:
		return m.OldOrgUnitID(ctx)
	case membershiporgunit.FieldPositionID:
		return m.OldPositionID(ctx)
	case membershiporgunit.FieldRoleID:
		return m.OldRoleID(ctx)
	case membershiporgunit.FieldStartAt:
		return m.OldStartAt(ctx)
	case membershiporgunit.FieldEndAt:
		return m.OldEndAt(ctx)
	case membershiporgunit.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case membershiporgunit.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case membershiporgunit.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case membershiporgunit.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown MembershipOrgUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipOrgUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membershiporgunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membershiporgunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membershiporgunit.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case membershiporgunit.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case membershiporgunit.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case membershiporgunit.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case membershiporgunit.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case membershiporgunit.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case membershiporgunit.FieldMembershipID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipID(v)
		return nil
	case membershiporgunit.FieldOrgUnitID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitID(v)
		return nil
	case membershiporgunit.FieldPositionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case membershiporgunit.FieldRoleID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case membershiporgunit.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case membershiporgunit.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case membershiporgunit.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case membershiporgunit.FieldAssignedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case membershiporgunit.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case membershiporgunit.FieldStatus:
		v, ok := value.(membershiporgunit.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MembershipOrgUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MembershipOrgUnitMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, membershiporgunit.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, membershiporgunit.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, membershiporgunit.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, membershiporgunit.FieldTenantID)
	}
	if m.addmembership_id != nil {
		fields = append(fields, membershiporgunit.FieldMembershipID)
	}
	if m.addorg_unit_id != nil {
		fields = append(fields, membershiporgunit.FieldOrgUnitID)
	}
	if m.addposition_id != nil {
		fields = append(fields, membershiporgunit.FieldPositionID)
	}
	if m.addrole_id != nil {
		fields = append(fields, membershiporgunit.FieldRoleID)
	}
	if m.addassigned_by != nil {
		fields = append(fields, membershiporgunit.FieldAssignedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MembershipOrgUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membershiporgunit.FieldCreatedBy:
		return m.AddedCreatedBy()
	case membershiporgunit.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case membershiporgunit.FieldDeletedBy:
		return m.AddedDeletedBy()
	case membershiporgunit.FieldTenantID:
		return m.AddedTenantID()
	case membershiporgunit.FieldMembershipID:
		return m.AddedMembershipID()
	case membershiporgunit.FieldOrgUnitID:
		return m.AddedOrgUnitID()
	case membershiporgunit.FieldPositionID:
		return m.AddedPositionID()
	case membershiporgunit.FieldRoleID:
		return m.AddedRoleID()
	case membershiporgunit.FieldAssignedBy:
		return m.AddedAssignedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipOrgUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membershiporgunit.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case membershiporgunit.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case membershiporgunit.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case membershiporgunit.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case membershiporgunit.FieldMembershipID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMembershipID(v)
		return nil
	case membershiporgunit.FieldOrgUnitID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgUnitID(v)
		return nil
	case membershiporgunit.FieldPositionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionID(v)
		return nil
	case membershiporgunit.FieldRoleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case membershiporgunit.FieldAssignedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MembershipOrgUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MembershipOrgUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membershiporgunit.FieldCreatedAt) {
		fields = append(fields, membershiporgunit.FieldCreatedAt)
	}
	if m.FieldCleared(membershiporgunit.FieldUpdatedAt) {
		fields = append(fields, membershiporgunit.FieldUpdatedAt)
	}
	if m.FieldCleared(membershiporgunit.FieldDeletedAt) {
		fields = append(fields, membershiporgunit.FieldDeletedAt)
	}
	if m.FieldCleared(membershiporgunit.FieldCreatedBy) {
		fields = append(fields, membershiporgunit.FieldCreatedBy)
	}
	if m.FieldCleared(membershiporgunit.FieldUpdatedBy) {
		fields = append(fields, membershiporgunit.FieldUpdatedBy)
	}
	if m.FieldCleared(membershiporgunit.FieldDeletedBy) {
		fields = append(fields, membershiporgunit.FieldDeletedBy)
	}
	if m.FieldCleared(membershiporgunit.FieldTenantID) {
		fields = append(fields, membershiporgunit.FieldTenantID)
	}
	if m.FieldCleared(membershiporgunit.FieldRemark) {
		fields = append(fields, membershiporgunit.FieldRemark)
	}
	if m.FieldCleared(membershiporgunit.FieldPositionID) {
		fields = append(fields, membershiporgunit.FieldPositionID)
	}
	if m.FieldCleared(membershiporgunit.FieldRoleID) {
		fields = append(fields, membershiporgunit.FieldRoleID)
	}
	if m.FieldCleared(membershiporgunit.FieldStartAt) {
		fields = append(fields, membershiporgunit.FieldStartAt)
	}
	if m.FieldCleared(membershiporgunit.FieldEndAt) {
		fields = append(fields, membershiporgunit.FieldEndAt)
	}
	if m.FieldCleared(membershiporgunit.FieldAssignedAt) {
		fields = append(fields, membershiporgunit.FieldAssignedAt)
	}
	if m.FieldCleared(membershiporgunit.FieldAssignedBy) {
		fields = append(fields, membershiporgunit.FieldAssignedBy)
	}
	if m.FieldCleared(membershiporgunit.FieldStatus) {
		fields = append(fields, membershiporgunit.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MembershipOrgUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MembershipOrgUnitMutation) ClearField(name string) error {
	switch name {
	case membershiporgunit.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membershiporgunit.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membershiporgunit.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case membershiporgunit.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case membershiporgunit.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case membershiporgunit.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case membershiporgunit.FieldTenantID:
		m.ClearTenantID()
		return nil
	case membershiporgunit.FieldRemark:
		m.ClearRemark()
		return nil
	case membershiporgunit.FieldPositionID:
		m.ClearPositionID()
		return nil
	case membershiporgunit.FieldRoleID:
		m.ClearRoleID()
		return nil
	case membershiporgunit.FieldStartAt:
		m.ClearStartAt()
		return nil
	case membershiporgunit.FieldEndAt:
		m.ClearEndAt()
		return nil
	case membershiporgunit.FieldAssignedAt:
		m.ClearAssignedAt()
		return nil
	case membershiporgunit.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case membershiporgunit.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown MembershipOrgUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MembershipOrgUnitMutation) ResetField(name string) error {
	switch name {
	case membershiporgunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membershiporgunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membershiporgunit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case membershiporgunit.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case membershiporgunit.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case membershiporgunit.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case membershiporgunit.FieldTenantID:
		m.ResetTenantID()
		return nil
	case membershiporgunit.FieldRemark:
		m.ResetRemark()
		return nil
	case membershiporgunit.FieldMembershipID:
		m.ResetMembershipID()
		return nil
	case membershiporgunit.FieldOrgUnitID:
		m.ResetOrgUnitID()
		return nil
	case membershiporgunit.FieldPositionID:
		m.ResetPositionID()
		return nil
	case membershiporgunit.FieldRoleID:
		m.ResetRoleID()
		return nil
	case membershiporgunit.FieldStartAt:
		m.ResetStartAt()
		return nil
	case membershiporgunit.FieldEndAt:
		m.ResetEndAt()
		return nil
	case membershiporgunit.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case membershiporgunit.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case membershiporgunit.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case membershiporgunit.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown MembershipOrgUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MembershipOrgUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MembershipOrgUnitMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MembershipOrgUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MembershipOrgUnitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MembershipOrgUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MembershipOrgUnitMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MembershipOrgUnitMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MembershipOrgUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MembershipOrgUnitMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MembershipOrgUnit edge %s", name)
}

// MembershipPositionMutation represents an operation that mutates the MembershipPosition nodes in the graph.
type MembershipPositionMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	tenant_id        *uint32
	addtenant_id     *int32
	remark           *string
	membership_id    *uint32
	addmembership_id *int32
	position_id      *uint32
	addposition_id   *int32
	is_primary       *bool
	start_at         *time.Time
	end_at           *time.Time
	assigned_at      *time.Time
	assigned_by      *uint32
	addassigned_by   *int32
	status           *membershipposition.Status
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*MembershipPosition, error)
	predicates       []predicate.MembershipPosition
}

var _ ent.Mutation = (*MembershipPositionMutation)(nil)

// membershippositionOption allows management of the mutation configuration using functional options.
type membershippositionOption func(*MembershipPositionMutation)

// newMembershipPositionMutation creates new mutation for the MembershipPosition entity.
func newMembershipPositionMutation(c config, op Op, opts ...membershippositionOption) *MembershipPositionMutation {
	m := &MembershipPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeMembershipPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMembershipPositionID sets the ID field of the mutation.
func withMembershipPositionID(id uint32) membershippositionOption {
	return func(m *MembershipPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *MembershipPosition
		)
		m.oldValue = func(ctx context.Context) (*MembershipPosition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MembershipPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMembershipPosition sets the old MembershipPosition of the mutation.
func withMembershipPosition(node *MembershipPosition) membershippositionOption {
	return func(m *MembershipPositionMutation) {
		m.oldValue = func(context.Context) (*MembershipPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MembershipPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MembershipPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MembershipPosition entities.
func (m *MembershipPositionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MembershipPositionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MembershipPositionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MembershipPosition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MembershipPositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MembershipPositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MembershipPositionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membershipposition.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MembershipPositionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MembershipPositionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membershipposition.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MembershipPositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MembershipPositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MembershipPositionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membershipposition.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MembershipPositionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MembershipPositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membershipposition.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MembershipPositionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MembershipPositionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MembershipPositionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[membershipposition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MembershipPositionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MembershipPositionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, membershipposition.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *MembershipPositionMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MembershipPositionMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *MembershipPositionMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MembershipPositionMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MembershipPositionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[membershipposition.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MembershipPositionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MembershipPositionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, membershipposition.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MembershipPositionMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MembershipPositionMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *MembershipPositionMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MembershipPositionMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MembershipPositionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[membershipposition.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MembershipPositionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MembershipPositionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, membershipposition.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MembershipPositionMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MembershipPositionMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *MembershipPositionMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *MembershipPositionMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MembershipPositionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[membershipposition.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MembershipPositionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MembershipPositionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, membershipposition.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *MembershipPositionMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MembershipPositionMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *MembershipPositionMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MembershipPositionMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *MembershipPositionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[membershipposition.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *MembershipPositionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MembershipPositionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, membershipposition.FieldTenantID)
}

// SetRemark sets the "remark" field.
func (m *MembershipPositionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MembershipPositionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MembershipPositionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[membershipposition.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MembershipPositionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MembershipPositionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, membershipposition.FieldRemark)
}

// SetMembershipID sets the "membership_id" field.
func (m *MembershipPositionMutation) SetMembershipID(u uint32) {
	m.membership_id = &u
	m.addmembership_id = nil
}

// MembershipID returns the value of the "membership_id" field in the mutation.
func (m *MembershipPositionMutation) MembershipID() (r uint32, exists bool) {
	v := m.membership_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMembershipID returns the old "membership_id" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldMembershipID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembershipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembershipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembershipID: %w", err)
	}
	return oldValue.MembershipID, nil
}

// AddMembershipID adds u to the "membership_id" field.
func (m *MembershipPositionMutation) AddMembershipID(u int32) {
	if m.addmembership_id != nil {
		*m.addmembership_id += u
	} else {
		m.addmembership_id = &u
	}
}

// AddedMembershipID returns the value that was added to the "membership_id" field in this mutation.
func (m *MembershipPositionMutation) AddedMembershipID() (r int32, exists bool) {
	v := m.addmembership_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipID resets all changes to the "membership_id" field.
func (m *MembershipPositionMutation) ResetMembershipID() {
	m.membership_id = nil
	m.addmembership_id = nil
}

// SetPositionID sets the "position_id" field.
func (m *MembershipPositionMutation) SetPositionID(u uint32) {
	m.position_id = &u
	m.addposition_id = nil
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *MembershipPositionMutation) PositionID() (r uint32, exists bool) {
	v := m.position_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldPositionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// AddPositionID adds u to the "position_id" field.
func (m *MembershipPositionMutation) AddPositionID(u int32) {
	if m.addposition_id != nil {
		*m.addposition_id += u
	} else {
		m.addposition_id = &u
	}
}

// AddedPositionID returns the value that was added to the "position_id" field in this mutation.
func (m *MembershipPositionMutation) AddedPositionID() (r int32, exists bool) {
	v := m.addposition_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *MembershipPositionMutation) ResetPositionID() {
	m.position_id = nil
	m.addposition_id = nil
}

// SetIsPrimary sets the "is_primary" field.
func (m *MembershipPositionMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *MembershipPositionMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ClearIsPrimary clears the value of the "is_primary" field.
func (m *MembershipPositionMutation) ClearIsPrimary() {
	m.is_primary = nil
	m.clearedFields[membershipposition.FieldIsPrimary] = struct{}{}
}

// IsPrimaryCleared returns if the "is_primary" field was cleared in this mutation.
func (m *MembershipPositionMutation) IsPrimaryCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldIsPrimary]
	return ok
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *MembershipPositionMutation) ResetIsPrimary() {
	m.is_primary = nil
	delete(m.clearedFields, membershipposition.FieldIsPrimary)
}

// SetStartAt sets the "start_at" field.
func (m *MembershipPositionMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *MembershipPositionMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *MembershipPositionMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[membershipposition.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *MembershipPositionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *MembershipPositionMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, membershipposition.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *MembershipPositionMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *MembershipPositionMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *MembershipPositionMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[membershipposition.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *MembershipPositionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *MembershipPositionMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, membershipposition.FieldEndAt)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *MembershipPositionMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *MembershipPositionMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ClearAssignedAt clears the value of the "assigned_at" field.
func (m *MembershipPositionMutation) ClearAssignedAt() {
	m.assigned_at = nil
	m.clearedFields[membershipposition.FieldAssignedAt] = struct{}{}
}

// AssignedAtCleared returns if the "assigned_at" field was cleared in this mutation.
func (m *MembershipPositionMutation) AssignedAtCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldAssignedAt]
	return ok
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *MembershipPositionMutation) ResetAssignedAt() {
	m.assigned_at = nil
	delete(m.clearedFields, membershipposition.FieldAssignedAt)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *MembershipPositionMutation) SetAssignedBy(u uint32) {
	m.assigned_by = &u
	m.addassigned_by = nil
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *MembershipPositionMutation) AssignedBy() (r uint32, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldAssignedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// AddAssignedBy adds u to the "assigned_by" field.
func (m *MembershipPositionMutation) AddAssignedBy(u int32) {
	if m.addassigned_by != nil {
		*m.addassigned_by += u
	} else {
		m.addassigned_by = &u
	}
}

// AddedAssignedBy returns the value that was added to the "assigned_by" field in this mutation.
func (m *MembershipPositionMutation) AddedAssignedBy() (r int32, exists bool) {
	v := m.addassigned_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *MembershipPositionMutation) ClearAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	m.clearedFields[membershipposition.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *MembershipPositionMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[membershipposition.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *MembershipPositionMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	delete(m.clearedFields, membershipposition.FieldAssignedBy)
}

// SetStatus sets the "status" field.
func (m *MembershipPositionMutation) SetStatus(value membershipposition.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MembershipPositionMutation) Status() (r membershipposition.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MembershipPosition entity.
// If the MembershipPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipPositionMutation) OldStatus(ctx context.Context) (v membershipposition.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MembershipPositionMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the MembershipPositionMutation builder.
func (m *MembershipPositionMutation) Where(ps ...predicate.MembershipPosition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MembershipPositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MembershipPositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MembershipPosition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MembershipPositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MembershipPositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MembershipPosition).
func (m *MembershipPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MembershipPositionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, membershipposition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membershipposition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, membershipposition.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, membershipposition.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, membershipposition.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, membershipposition.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, membershipposition.FieldTenantID)
	}
	if m.remark != nil {
		fields = append(fields, membershipposition.FieldRemark)
	}
	if m.membership_id != nil {
		fields = append(fields, membershipposition.FieldMembershipID)
	}
	if m.position_id != nil {
		fields = append(fields, membershipposition.FieldPositionID)
	}
	if m.is_primary != nil {
		fields = append(fields, membershipposition.FieldIsPrimary)
	}
	if m.start_at != nil {
		fields = append(fields, membershipposition.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, membershipposition.FieldEndAt)
	}
	if m.assigned_at != nil {
		fields = append(fields, membershipposition.FieldAssignedAt)
	}
	if m.assigned_by != nil {
		fields = append(fields, membershipposition.FieldAssignedBy)
	}
	if m.status != nil {
		fields = append(fields, membershipposition.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MembershipPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membershipposition.FieldCreatedAt:
		return m.CreatedAt()
	case membershipposition.FieldUpdatedAt:
		return m.UpdatedAt()
	case membershipposition.FieldDeletedAt:
		return m.DeletedAt()
	case membershipposition.FieldCreatedBy:
		return m.CreatedBy()
	case membershipposition.FieldUpdatedBy:
		return m.UpdatedBy()
	case membershipposition.FieldDeletedBy:
		return m.DeletedBy()
	case membershipposition.FieldTenantID:
		return m.TenantID()
	case membershipposition.FieldRemark:
		return m.Remark()
	case membershipposition.FieldMembershipID:
		return m.MembershipID()
	case membershipposition.FieldPositionID:
		return m.PositionID()
	case membershipposition.FieldIsPrimary:
		return m.IsPrimary()
	case membershipposition.FieldStartAt:
		return m.StartAt()
	case membershipposition.FieldEndAt:
		return m.EndAt()
	case membershipposition.FieldAssignedAt:
		return m.AssignedAt()
	case membershipposition.FieldAssignedBy:
		return m.AssignedBy()
	case membershipposition.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MembershipPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membershipposition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membershipposition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membershipposition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case membershipposition.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case membershipposition.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case membershipposition.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case membershipposition.FieldTenantID:
		return m.OldTenantID(ctx)
	case membershipposition.FieldRemark:
		return m.OldRemark(ctx)
	case membershipposition.FieldMembershipID:
		return m.OldMembershipID(ctx)
	case membershipposition.FieldPositionID:
		return m.OldPositionID(ctx)
	case membershipposition.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case membershipposition.FieldStartAt:
		return m.OldStartAt(ctx)
	case membershipposition.FieldEndAt:
		return m.OldEndAt(ctx)
	case membershipposition.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case membershipposition.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case membershipposition.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown MembershipPosition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membershipposition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membershipposition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membershipposition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case membershipposition.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case membershipposition.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case membershipposition.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case membershipposition.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case membershipposition.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case membershipposition.FieldMembershipID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipID(v)
		return nil
	case membershipposition.FieldPositionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case membershipposition.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case membershipposition.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case membershipposition.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case membershipposition.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case membershipposition.FieldAssignedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case membershipposition.FieldStatus:
		v, ok := value.(membershipposition.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MembershipPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MembershipPositionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, membershipposition.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, membershipposition.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, membershipposition.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, membershipposition.FieldTenantID)
	}
	if m.addmembership_id != nil {
		fields = append(fields, membershipposition.FieldMembershipID)
	}
	if m.addposition_id != nil {
		fields = append(fields, membershipposition.FieldPositionID)
	}
	if m.addassigned_by != nil {
		fields = append(fields, membershipposition.FieldAssignedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MembershipPositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membershipposition.FieldCreatedBy:
		return m.AddedCreatedBy()
	case membershipposition.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case membershipposition.FieldDeletedBy:
		return m.AddedDeletedBy()
	case membershipposition.FieldTenantID:
		return m.AddedTenantID()
	case membershipposition.FieldMembershipID:
		return m.AddedMembershipID()
	case membershipposition.FieldPositionID:
		return m.AddedPositionID()
	case membershipposition.FieldAssignedBy:
		return m.AddedAssignedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membershipposition.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case membershipposition.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case membershipposition.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case membershipposition.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case membershipposition.FieldMembershipID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMembershipID(v)
		return nil
	case membershipposition.FieldPositionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionID(v)
		return nil
	case membershipposition.FieldAssignedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MembershipPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MembershipPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membershipposition.FieldCreatedAt) {
		fields = append(fields, membershipposition.FieldCreatedAt)
	}
	if m.FieldCleared(membershipposition.FieldUpdatedAt) {
		fields = append(fields, membershipposition.FieldUpdatedAt)
	}
	if m.FieldCleared(membershipposition.FieldDeletedAt) {
		fields = append(fields, membershipposition.FieldDeletedAt)
	}
	if m.FieldCleared(membershipposition.FieldCreatedBy) {
		fields = append(fields, membershipposition.FieldCreatedBy)
	}
	if m.FieldCleared(membershipposition.FieldUpdatedBy) {
		fields = append(fields, membershipposition.FieldUpdatedBy)
	}
	if m.FieldCleared(membershipposition.FieldDeletedBy) {
		fields = append(fields, membershipposition.FieldDeletedBy)
	}
	if m.FieldCleared(membershipposition.FieldTenantID) {
		fields = append(fields, membershipposition.FieldTenantID)
	}
	if m.FieldCleared(membershipposition.FieldRemark) {
		fields = append(fields, membershipposition.FieldRemark)
	}
	if m.FieldCleared(membershipposition.FieldIsPrimary) {
		fields = append(fields, membershipposition.FieldIsPrimary)
	}
	if m.FieldCleared(membershipposition.FieldStartAt) {
		fields = append(fields, membershipposition.FieldStartAt)
	}
	if m.FieldCleared(membershipposition.FieldEndAt) {
		fields = append(fields, membershipposition.FieldEndAt)
	}
	if m.FieldCleared(membershipposition.FieldAssignedAt) {
		fields = append(fields, membershipposition.FieldAssignedAt)
	}
	if m.FieldCleared(membershipposition.FieldAssignedBy) {
		fields = append(fields, membershipposition.FieldAssignedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MembershipPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MembershipPositionMutation) ClearField(name string) error {
	switch name {
	case membershipposition.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membershipposition.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membershipposition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case membershipposition.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case membershipposition.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case membershipposition.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case membershipposition.FieldTenantID:
		m.ClearTenantID()
		return nil
	case membershipposition.FieldRemark:
		m.ClearRemark()
		return nil
	case membershipposition.FieldIsPrimary:
		m.ClearIsPrimary()
		return nil
	case membershipposition.FieldStartAt:
		m.ClearStartAt()
		return nil
	case membershipposition.FieldEndAt:
		m.ClearEndAt()
		return nil
	case membershipposition.FieldAssignedAt:
		m.ClearAssignedAt()
		return nil
	case membershipposition.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	}
	return fmt.Errorf("unknown MembershipPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MembershipPositionMutation) ResetField(name string) error {
	switch name {
	case membershipposition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membershipposition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membershipposition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case membershipposition.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case membershipposition.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case membershipposition.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case membershipposition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case membershipposition.FieldRemark:
		m.ResetRemark()
		return nil
	case membershipposition.FieldMembershipID:
		m.ResetMembershipID()
		return nil
	case membershipposition.FieldPositionID:
		m.ResetPositionID()
		return nil
	case membershipposition.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case membershipposition.FieldStartAt:
		m.ResetStartAt()
		return nil
	case membershipposition.FieldEndAt:
		m.ResetEndAt()
		return nil
	case membershipposition.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case membershipposition.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case membershipposition.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown MembershipPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MembershipPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MembershipPositionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MembershipPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MembershipPositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MembershipPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MembershipPositionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MembershipPositionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MembershipPosition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MembershipPositionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MembershipPosition edge %s", name)
}

// MembershipRoleMutation represents an operation that mutates the MembershipRole nodes in the graph.
type MembershipRoleMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	tenant_id        *uint32
	addtenant_id     *int32
	membership_id    *uint32
	addmembership_id *int32
	role_id          *uint32
	addrole_id       *int32
	start_at         *time.Time
	end_at           *time.Time
	assigned_at      *time.Time
	assigned_by      *uint32
	addassigned_by   *int32
	is_primary       *bool
	status           *membershiprole.Status
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*MembershipRole, error)
	predicates       []predicate.MembershipRole
}

var _ ent.Mutation = (*MembershipRoleMutation)(nil)

// membershiproleOption allows management of the mutation configuration using functional options.
type membershiproleOption func(*MembershipRoleMutation)

// newMembershipRoleMutation creates new mutation for the MembershipRole entity.
func newMembershipRoleMutation(c config, op Op, opts ...membershiproleOption) *MembershipRoleMutation {
	m := &MembershipRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeMembershipRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMembershipRoleID sets the ID field of the mutation.
func withMembershipRoleID(id uint32) membershiproleOption {
	return func(m *MembershipRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *MembershipRole
		)
		m.oldValue = func(ctx context.Context) (*MembershipRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MembershipRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMembershipRole sets the old MembershipRole of the mutation.
func withMembershipRole(node *MembershipRole) membershiproleOption {
	return func(m *MembershipRoleMutation) {
		m.oldValue = func(context.Context) (*MembershipRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MembershipRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MembershipRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MembershipRole entities.
func (m *MembershipRoleMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MembershipRoleMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MembershipRoleMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MembershipRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MembershipRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MembershipRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MembershipRoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membershiprole.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MembershipRoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MembershipRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membershiprole.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MembershipRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MembershipRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MembershipRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membershiprole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MembershipRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MembershipRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membershiprole.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MembershipRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MembershipRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MembershipRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[membershiprole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MembershipRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MembershipRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, membershiprole.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *MembershipRoleMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MembershipRoleMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *MembershipRoleMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MembershipRoleMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MembershipRoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[membershiprole.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MembershipRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MembershipRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, membershiprole.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MembershipRoleMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MembershipRoleMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *MembershipRoleMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MembershipRoleMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MembershipRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[membershiprole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MembershipRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MembershipRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, membershiprole.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MembershipRoleMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MembershipRoleMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *MembershipRoleMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *MembershipRoleMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MembershipRoleMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[membershiprole.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MembershipRoleMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MembershipRoleMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, membershiprole.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *MembershipRoleMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MembershipRoleMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *MembershipRoleMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MembershipRoleMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *MembershipRoleMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[membershiprole.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *MembershipRoleMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MembershipRoleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, membershiprole.FieldTenantID)
}

// SetMembershipID sets the "membership_id" field.
func (m *MembershipRoleMutation) SetMembershipID(u uint32) {
	m.membership_id = &u
	m.addmembership_id = nil
}

// MembershipID returns the value of the "membership_id" field in the mutation.
func (m *MembershipRoleMutation) MembershipID() (r uint32, exists bool) {
	v := m.membership_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMembershipID returns the old "membership_id" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldMembershipID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembershipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembershipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembershipID: %w", err)
	}
	return oldValue.MembershipID, nil
}

// AddMembershipID adds u to the "membership_id" field.
func (m *MembershipRoleMutation) AddMembershipID(u int32) {
	if m.addmembership_id != nil {
		*m.addmembership_id += u
	} else {
		m.addmembership_id = &u
	}
}

// AddedMembershipID returns the value that was added to the "membership_id" field in this mutation.
func (m *MembershipRoleMutation) AddedMembershipID() (r int32, exists bool) {
	v := m.addmembership_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipID resets all changes to the "membership_id" field.
func (m *MembershipRoleMutation) ResetMembershipID() {
	m.membership_id = nil
	m.addmembership_id = nil
}

// SetRoleID sets the "role_id" field.
func (m *MembershipRoleMutation) SetRoleID(u uint32) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *MembershipRoleMutation) RoleID() (r uint32, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldRoleID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *MembershipRoleMutation) AddRoleID(u int32) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *MembershipRoleMutation) AddedRoleID() (r int32, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *MembershipRoleMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetStartAt sets the "start_at" field.
func (m *MembershipRoleMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *MembershipRoleMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *MembershipRoleMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[membershiprole.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *MembershipRoleMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *MembershipRoleMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, membershiprole.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *MembershipRoleMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *MembershipRoleMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *MembershipRoleMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[membershiprole.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *MembershipRoleMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *MembershipRoleMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, membershiprole.FieldEndAt)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *MembershipRoleMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *MembershipRoleMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ClearAssignedAt clears the value of the "assigned_at" field.
func (m *MembershipRoleMutation) ClearAssignedAt() {
	m.assigned_at = nil
	m.clearedFields[membershiprole.FieldAssignedAt] = struct{}{}
}

// AssignedAtCleared returns if the "assigned_at" field was cleared in this mutation.
func (m *MembershipRoleMutation) AssignedAtCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldAssignedAt]
	return ok
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *MembershipRoleMutation) ResetAssignedAt() {
	m.assigned_at = nil
	delete(m.clearedFields, membershiprole.FieldAssignedAt)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *MembershipRoleMutation) SetAssignedBy(u uint32) {
	m.assigned_by = &u
	m.addassigned_by = nil
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *MembershipRoleMutation) AssignedBy() (r uint32, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldAssignedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// AddAssignedBy adds u to the "assigned_by" field.
func (m *MembershipRoleMutation) AddAssignedBy(u int32) {
	if m.addassigned_by != nil {
		*m.addassigned_by += u
	} else {
		m.addassigned_by = &u
	}
}

// AddedAssignedBy returns the value that was added to the "assigned_by" field in this mutation.
func (m *MembershipRoleMutation) AddedAssignedBy() (r int32, exists bool) {
	v := m.addassigned_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *MembershipRoleMutation) ClearAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	m.clearedFields[membershiprole.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *MembershipRoleMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[membershiprole.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *MembershipRoleMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	delete(m.clearedFields, membershiprole.FieldAssignedBy)
}

// SetIsPrimary sets the "is_primary" field.
func (m *MembershipRoleMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *MembershipRoleMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *MembershipRoleMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetStatus sets the "status" field.
func (m *MembershipRoleMutation) SetStatus(value membershiprole.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MembershipRoleMutation) Status() (r membershiprole.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MembershipRole entity.
// If the MembershipRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipRoleMutation) OldStatus(ctx context.Context) (v membershiprole.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MembershipRoleMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the MembershipRoleMutation builder.
func (m *MembershipRoleMutation) Where(ps ...predicate.MembershipRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MembershipRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MembershipRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MembershipRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MembershipRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MembershipRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MembershipRole).
func (m *MembershipRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MembershipRoleMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, membershiprole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membershiprole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, membershiprole.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, membershiprole.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, membershiprole.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, membershiprole.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, membershiprole.FieldTenantID)
	}
	if m.membership_id != nil {
		fields = append(fields, membershiprole.FieldMembershipID)
	}
	if m.role_id != nil {
		fields = append(fields, membershiprole.FieldRoleID)
	}
	if m.start_at != nil {
		fields = append(fields, membershiprole.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, membershiprole.FieldEndAt)
	}
	if m.assigned_at != nil {
		fields = append(fields, membershiprole.FieldAssignedAt)
	}
	if m.assigned_by != nil {
		fields = append(fields, membershiprole.FieldAssignedBy)
	}
	if m.is_primary != nil {
		fields = append(fields, membershiprole.FieldIsPrimary)
	}
	if m.status != nil {
		fields = append(fields, membershiprole.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MembershipRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membershiprole.FieldCreatedAt:
		return m.CreatedAt()
	case membershiprole.FieldUpdatedAt:
		return m.UpdatedAt()
	case membershiprole.FieldDeletedAt:
		return m.DeletedAt()
	case membershiprole.FieldCreatedBy:
		return m.CreatedBy()
	case membershiprole.FieldUpdatedBy:
		return m.UpdatedBy()
	case membershiprole.FieldDeletedBy:
		return m.DeletedBy()
	case membershiprole.FieldTenantID:
		return m.TenantID()
	case membershiprole.FieldMembershipID:
		return m.MembershipID()
	case membershiprole.FieldRoleID:
		return m.RoleID()
	case membershiprole.FieldStartAt:
		return m.StartAt()
	case membershiprole.FieldEndAt:
		return m.EndAt()
	case membershiprole.FieldAssignedAt:
		return m.AssignedAt()
	case membershiprole.FieldAssignedBy:
		return m.AssignedBy()
	case membershiprole.FieldIsPrimary:
		return m.IsPrimary()
	case membershiprole.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MembershipRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membershiprole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membershiprole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membershiprole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case membershiprole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case membershiprole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case membershiprole.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case membershiprole.FieldTenantID:
		return m.OldTenantID(ctx)
	case membershiprole.FieldMembershipID:
		return m.OldMembershipID(ctx)
	case membershiprole.FieldRoleID:
		return m.OldRoleID(ctx)
	case membershiprole.FieldStartAt:
		return m.OldStartAt(ctx)
	case membershiprole.FieldEndAt:
		return m.OldEndAt(ctx)
	case membershiprole.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case membershiprole.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case membershiprole.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case membershiprole.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown MembershipRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membershiprole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membershiprole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membershiprole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case membershiprole.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case membershiprole.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case membershiprole.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case membershiprole.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case membershiprole.FieldMembershipID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipID(v)
		return nil
	case membershiprole.FieldRoleID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case membershiprole.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case membershiprole.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case membershiprole.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case membershiprole.FieldAssignedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case membershiprole.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case membershiprole.FieldStatus:
		v, ok := value.(membershiprole.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MembershipRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MembershipRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, membershiprole.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, membershiprole.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, membershiprole.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, membershiprole.FieldTenantID)
	}
	if m.addmembership_id != nil {
		fields = append(fields, membershiprole.FieldMembershipID)
	}
	if m.addrole_id != nil {
		fields = append(fields, membershiprole.FieldRoleID)
	}
	if m.addassigned_by != nil {
		fields = append(fields, membershiprole.FieldAssignedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MembershipRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membershiprole.FieldCreatedBy:
		return m.AddedCreatedBy()
	case membershiprole.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case membershiprole.FieldDeletedBy:
		return m.AddedDeletedBy()
	case membershiprole.FieldTenantID:
		return m.AddedTenantID()
	case membershiprole.FieldMembershipID:
		return m.AddedMembershipID()
	case membershiprole.FieldRoleID:
		return m.AddedRoleID()
	case membershiprole.FieldAssignedBy:
		return m.AddedAssignedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membershiprole.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case membershiprole.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case membershiprole.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case membershiprole.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case membershiprole.FieldMembershipID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMembershipID(v)
		return nil
	case membershiprole.FieldRoleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case membershiprole.FieldAssignedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MembershipRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MembershipRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membershiprole.FieldCreatedAt) {
		fields = append(fields, membershiprole.FieldCreatedAt)
	}
	if m.FieldCleared(membershiprole.FieldUpdatedAt) {
		fields = append(fields, membershiprole.FieldUpdatedAt)
	}
	if m.FieldCleared(membershiprole.FieldDeletedAt) {
		fields = append(fields, membershiprole.FieldDeletedAt)
	}
	if m.FieldCleared(membershiprole.FieldCreatedBy) {
		fields = append(fields, membershiprole.FieldCreatedBy)
	}
	if m.FieldCleared(membershiprole.FieldUpdatedBy) {
		fields = append(fields, membershiprole.FieldUpdatedBy)
	}
	if m.FieldCleared(membershiprole.FieldDeletedBy) {
		fields = append(fields, membershiprole.FieldDeletedBy)
	}
	if m.FieldCleared(membershiprole.FieldTenantID) {
		fields = append(fields, membershiprole.FieldTenantID)
	}
	if m.FieldCleared(membershiprole.FieldStartAt) {
		fields = append(fields, membershiprole.FieldStartAt)
	}
	if m.FieldCleared(membershiprole.FieldEndAt) {
		fields = append(fields, membershiprole.FieldEndAt)
	}
	if m.FieldCleared(membershiprole.FieldAssignedAt) {
		fields = append(fields, membershiprole.FieldAssignedAt)
	}
	if m.FieldCleared(membershiprole.FieldAssignedBy) {
		fields = append(fields, membershiprole.FieldAssignedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MembershipRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MembershipRoleMutation) ClearField(name string) error {
	switch name {
	case membershiprole.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membershiprole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membershiprole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case membershiprole.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case membershiprole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case membershiprole.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case membershiprole.FieldTenantID:
		m.ClearTenantID()
		return nil
	case membershiprole.FieldStartAt:
		m.ClearStartAt()
		return nil
	case membershiprole.FieldEndAt:
		m.ClearEndAt()
		return nil
	case membershiprole.FieldAssignedAt:
		m.ClearAssignedAt()
		return nil
	case membershiprole.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	}
	return fmt.Errorf("unknown MembershipRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MembershipRoleMutation) ResetField(name string) error {
	switch name {
	case membershiprole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membershiprole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membershiprole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case membershiprole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case membershiprole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case membershiprole.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case membershiprole.FieldTenantID:
		m.ResetTenantID()
		return nil
	case membershiprole.FieldMembershipID:
		m.ResetMembershipID()
		return nil
	case membershiprole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case membershiprole.FieldStartAt:
		m.ResetStartAt()
		return nil
	case membershiprole.FieldEndAt:
		m.ResetEndAt()
		return nil
	case membershiprole.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case membershiprole.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case membershiprole.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case membershiprole.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown MembershipRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MembershipRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MembershipRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MembershipRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MembershipRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MembershipRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MembershipRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MembershipRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MembershipRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MembershipRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MembershipRole edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	created_by      *uint32
	addcreated_by   *int32
	updated_by      *uint32
	addupdated_by   *int32
	deleted_by      *uint32
	adddeleted_by   *int32
	remark          *string
	status          *menu.Status
	_type           *menu.Type
	_path           *string
	redirect        *string
	alias           *string
	name            *string
	component       *string
	meta            **resourcepb.MenuMeta
	clearedFields   map[string]struct{}
	parent          *uint32
	clearedparent   bool
	children        map[uint32]struct{}
	removedchildren map[uint32]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id uint32) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menu.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menu.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menu.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MenuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MenuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MenuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[menu.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MenuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MenuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, menu.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *MenuMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MenuMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *MenuMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MenuMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MenuMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[menu.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MenuMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MenuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, menu.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MenuMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MenuMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *MenuMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MenuMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MenuMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[menu.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MenuMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, menu.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MenuMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MenuMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *MenuMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *MenuMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MenuMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[menu.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MenuMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[menu.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MenuMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, menu.FieldDeletedBy)
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(u uint32) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r uint32, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetRemark sets the "remark" field.
func (m *MenuMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MenuMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MenuMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[menu.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MenuMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[menu.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MenuMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, menu.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *MenuMutation) SetStatus(value menu.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MenuMutation) Status() (r menu.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldStatus(ctx context.Context) (v *menu.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MenuMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *MenuMutation) SetType(value menu.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuMutation) GetType() (r menu.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldType(ctx context.Context) (v *menu.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MenuMutation) ClearType() {
	m._type = nil
	m.clearedFields[menu.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MenuMutation) TypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MenuMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, menu.FieldType)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetRedirect sets the "redirect" field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of the "redirect" field.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the "redirect" field was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetAlias sets the "alias" field.
func (m *MenuMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *MenuMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldAlias(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ClearAlias clears the value of the "alias" field.
func (m *MenuMutation) ClearAlias() {
	m.alias = nil
	m.clearedFields[menu.FieldAlias] = struct{}{}
}

// AliasCleared returns if the "alias" field was cleared in this mutation.
func (m *MenuMutation) AliasCleared() bool {
	_, ok := m.clearedFields[menu.FieldAlias]
	return ok
}

// ResetAlias resets all changes to the "alias" field.
func (m *MenuMutation) ResetAlias() {
	m.alias = nil
	delete(m.clearedFields, menu.FieldAlias)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[menu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[menu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, menu.FieldName)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetMeta sets the "meta" field.
func (m *MenuMutation) SetMeta(rm *resourcepb.MenuMeta) {
	m.meta = &rm
}

// Meta returns the value of the "meta" field in the mutation.
func (m *MenuMutation) Meta() (r *resourcepb.MenuMeta, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMeta(ctx context.Context) (v *resourcepb.MenuMeta, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ClearMeta clears the value of the "meta" field.
func (m *MenuMutation) ClearMeta() {
	m.meta = nil
	m.clearedFields[menu.FieldMeta] = struct{}{}
}

// MetaCleared returns if the "meta" field was cleared in this mutation.
func (m *MenuMutation) MetaCleared() bool {
	_, ok := m.clearedFields[menu.FieldMeta]
	return ok
}

// ResetMeta resets all changes to the "meta" field.
func (m *MenuMutation) ResetMeta() {
	m.meta = nil
	delete(m.clearedFields, menu.FieldMeta)
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []uint32) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...uint32) {
	if m.children == nil {
		m.children = make(map[uint32]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...uint32) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []uint32) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []uint32) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, menu.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, menu.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, menu.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, menu.FieldDeletedBy)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.remark != nil {
		fields = append(fields, menu.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, menu.FieldType)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.alias != nil {
		fields = append(fields, menu.FieldAlias)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.meta != nil {
		fields = append(fields, menu.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldDeletedAt:
		return m.DeletedAt()
	case menu.FieldCreatedBy:
		return m.CreatedBy()
	case menu.FieldUpdatedBy:
		return m.UpdatedBy()
	case menu.FieldDeletedBy:
		return m.DeletedBy()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldRemark:
		return m.Remark()
	case menu.FieldStatus:
		return m.Status()
	case menu.FieldType:
		return m.GetType()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldAlias:
		return m.Alias()
	case menu.FieldName:
		return m.Name()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case menu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case menu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case menu.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldRemark:
		return m.OldRemark(ctx)
	case menu.FieldStatus:
		return m.OldStatus(ctx)
	case menu.FieldType:
		return m.OldType(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldAlias:
		return m.OldAlias(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case menu.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case menu.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case menu.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(menu.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menu.FieldType:
		v, ok := value.(menu.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldMeta:
		v, ok := value.(*resourcepb.MenuMeta)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, menu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, menu.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, menu.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case menu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case menu.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case menu.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case menu.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldCreatedAt) {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.FieldCleared(menu.FieldUpdatedAt) {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.FieldCleared(menu.FieldDeletedAt) {
		fields = append(fields, menu.FieldDeletedAt)
	}
	if m.FieldCleared(menu.FieldCreatedBy) {
		fields = append(fields, menu.FieldCreatedBy)
	}
	if m.FieldCleared(menu.FieldUpdatedBy) {
		fields = append(fields, menu.FieldUpdatedBy)
	}
	if m.FieldCleared(menu.FieldDeletedBy) {
		fields = append(fields, menu.FieldDeletedBy)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldRemark) {
		fields = append(fields, menu.FieldRemark)
	}
	if m.FieldCleared(menu.FieldType) {
		fields = append(fields, menu.FieldType)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldAlias) {
		fields = append(fields, menu.FieldAlias)
	}
	if m.FieldCleared(menu.FieldName) {
		fields = append(fields, menu.FieldName)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldMeta) {
		fields = append(fields, menu.FieldMeta)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menu.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case menu.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case menu.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case menu.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldRemark:
		m.ClearRemark()
		return nil
	case menu.FieldType:
		m.ClearType()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldAlias:
		m.ClearAlias()
		return nil
	case menu.FieldName:
		m.ClearName()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldMeta:
		m.ClearMeta()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case menu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case menu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case menu.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldRemark:
		m.ResetRemark()
		return nil
	case menu.FieldStatus:
		m.ResetStatus()
		return nil
	case menu.FieldType:
		m.ResetType()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldAlias:
		m.ResetAlias()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// OperationAuditLogMutation represents an operation that mutates the OperationAuditLog nodes in the graph.
type OperationAuditLogMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	tenant_id       *uint32
	addtenant_id    *int32
	user_id         *uint32
	adduser_id      *int32
	username        *string
	resource_type   *string
	resource_id     *string
	action          *operationauditlog.Action
	before_data     *string
	after_data      *string
	sensitive_level *operationauditlog.SensitiveLevel
	request_id      *string
	trace_id        *string
	success         *bool
	failure_reason  *string
	ip_address      *string
	geo_location    **auditpb.GeoLocation
	device_info     **auditpb.DeviceInfo
	log_hash        *string
	signature       *[]byte
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*OperationAuditLog, error)
	predicates      []predicate.OperationAuditLog
}

var _ ent.Mutation = (*OperationAuditLogMutation)(nil)

// operationauditlogOption allows management of the mutation configuration using functional options.
type operationauditlogOption func(*OperationAuditLogMutation)

// newOperationAuditLogMutation creates new mutation for the OperationAuditLog entity.
func newOperationAuditLogMutation(c config, op Op, opts ...operationauditlogOption) *OperationAuditLogMutation {
	m := &OperationAuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeOperationAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperationAuditLogID sets the ID field of the mutation.
func withOperationAuditLogID(id uint32) operationauditlogOption {
	return func(m *OperationAuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *OperationAuditLog
		)
		m.oldValue = func(ctx context.Context) (*OperationAuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OperationAuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperationAuditLog sets the old OperationAuditLog of the mutation.
func withOperationAuditLog(node *OperationAuditLog) operationauditlogOption {
	return func(m *OperationAuditLogMutation) {
		m.oldValue = func(context.Context) (*OperationAuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperationAuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperationAuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OperationAuditLog entities.
func (m *OperationAuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperationAuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperationAuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OperationAuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OperationAuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OperationAuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OperationAuditLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[operationauditlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OperationAuditLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OperationAuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, operationauditlog.FieldCreatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *OperationAuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OperationAuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *OperationAuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *OperationAuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *OperationAuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[operationauditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *OperationAuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OperationAuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, operationauditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *OperationAuditLogMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OperationAuditLogMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *OperationAuditLogMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OperationAuditLogMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *OperationAuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[operationauditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OperationAuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OperationAuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, operationauditlog.FieldUserID)
}

// SetUsername sets the "username" field.
func (m *OperationAuditLogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperationAuditLogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *OperationAuditLogMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[operationauditlog.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *OperationAuditLogMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *OperationAuditLogMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, operationauditlog.FieldUsername)
}

// SetResourceType sets the "resource_type" field.
func (m *OperationAuditLogMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *OperationAuditLogMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldResourceType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ClearResourceType clears the value of the "resource_type" field.
func (m *OperationAuditLogMutation) ClearResourceType() {
	m.resource_type = nil
	m.clearedFields[operationauditlog.FieldResourceType] = struct{}{}
}

// ResourceTypeCleared returns if the "resource_type" field was cleared in this mutation.
func (m *OperationAuditLogMutation) ResourceTypeCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldResourceType]
	return ok
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *OperationAuditLogMutation) ResetResourceType() {
	m.resource_type = nil
	delete(m.clearedFields, operationauditlog.FieldResourceType)
}

// SetResourceID sets the "resource_id" field.
func (m *OperationAuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *OperationAuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldResourceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *OperationAuditLogMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[operationauditlog.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *OperationAuditLogMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *OperationAuditLogMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, operationauditlog.FieldResourceID)
}

// SetAction sets the "action" field.
func (m *OperationAuditLogMutation) SetAction(o operationauditlog.Action) {
	m.action = &o
}

// Action returns the value of the "action" field in the mutation.
func (m *OperationAuditLogMutation) Action() (r operationauditlog.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldAction(ctx context.Context) (v *operationauditlog.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *OperationAuditLogMutation) ClearAction() {
	m.action = nil
	m.clearedFields[operationauditlog.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *OperationAuditLogMutation) ActionCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *OperationAuditLogMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, operationauditlog.FieldAction)
}

// SetBeforeData sets the "before_data" field.
func (m *OperationAuditLogMutation) SetBeforeData(s string) {
	m.before_data = &s
}

// BeforeData returns the value of the "before_data" field in the mutation.
func (m *OperationAuditLogMutation) BeforeData() (r string, exists bool) {
	v := m.before_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBeforeData returns the old "before_data" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldBeforeData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeforeData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeforeData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeforeData: %w", err)
	}
	return oldValue.BeforeData, nil
}

// ClearBeforeData clears the value of the "before_data" field.
func (m *OperationAuditLogMutation) ClearBeforeData() {
	m.before_data = nil
	m.clearedFields[operationauditlog.FieldBeforeData] = struct{}{}
}

// BeforeDataCleared returns if the "before_data" field was cleared in this mutation.
func (m *OperationAuditLogMutation) BeforeDataCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldBeforeData]
	return ok
}

// ResetBeforeData resets all changes to the "before_data" field.
func (m *OperationAuditLogMutation) ResetBeforeData() {
	m.before_data = nil
	delete(m.clearedFields, operationauditlog.FieldBeforeData)
}

// SetAfterData sets the "after_data" field.
func (m *OperationAuditLogMutation) SetAfterData(s string) {
	m.after_data = &s
}

// AfterData returns the value of the "after_data" field in the mutation.
func (m *OperationAuditLogMutation) AfterData() (r string, exists bool) {
	v := m.after_data
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterData returns the old "after_data" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldAfterData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterData: %w", err)
	}
	return oldValue.AfterData, nil
}

// ClearAfterData clears the value of the "after_data" field.
func (m *OperationAuditLogMutation) ClearAfterData() {
	m.after_data = nil
	m.clearedFields[operationauditlog.FieldAfterData] = struct{}{}
}

// AfterDataCleared returns if the "after_data" field was cleared in this mutation.
func (m *OperationAuditLogMutation) AfterDataCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldAfterData]
	return ok
}

// ResetAfterData resets all changes to the "after_data" field.
func (m *OperationAuditLogMutation) ResetAfterData() {
	m.after_data = nil
	delete(m.clearedFields, operationauditlog.FieldAfterData)
}

// SetSensitiveLevel sets the "sensitive_level" field.
func (m *OperationAuditLogMutation) SetSensitiveLevel(ol operationauditlog.SensitiveLevel) {
	m.sensitive_level = &ol
}

// SensitiveLevel returns the value of the "sensitive_level" field in the mutation.
func (m *OperationAuditLogMutation) SensitiveLevel() (r operationauditlog.SensitiveLevel, exists bool) {
	v := m.sensitive_level
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitiveLevel returns the old "sensitive_level" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldSensitiveLevel(ctx context.Context) (v *operationauditlog.SensitiveLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitiveLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitiveLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitiveLevel: %w", err)
	}
	return oldValue.SensitiveLevel, nil
}

// ClearSensitiveLevel clears the value of the "sensitive_level" field.
func (m *OperationAuditLogMutation) ClearSensitiveLevel() {
	m.sensitive_level = nil
	m.clearedFields[operationauditlog.FieldSensitiveLevel] = struct{}{}
}

// SensitiveLevelCleared returns if the "sensitive_level" field was cleared in this mutation.
func (m *OperationAuditLogMutation) SensitiveLevelCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldSensitiveLevel]
	return ok
}

// ResetSensitiveLevel resets all changes to the "sensitive_level" field.
func (m *OperationAuditLogMutation) ResetSensitiveLevel() {
	m.sensitive_level = nil
	delete(m.clearedFields, operationauditlog.FieldSensitiveLevel)
}

// SetRequestID sets the "request_id" field.
func (m *OperationAuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *OperationAuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *OperationAuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[operationauditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *OperationAuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *OperationAuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, operationauditlog.FieldRequestID)
}

// SetTraceID sets the "trace_id" field.
func (m *OperationAuditLogMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *OperationAuditLogMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldTraceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *OperationAuditLogMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[operationauditlog.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *OperationAuditLogMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *OperationAuditLogMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, operationauditlog.FieldTraceID)
}

// SetSuccess sets the "success" field.
func (m *OperationAuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *OperationAuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldSuccess(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ClearSuccess clears the value of the "success" field.
func (m *OperationAuditLogMutation) ClearSuccess() {
	m.success = nil
	m.clearedFields[operationauditlog.FieldSuccess] = struct{}{}
}

// SuccessCleared returns if the "success" field was cleared in this mutation.
func (m *OperationAuditLogMutation) SuccessCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldSuccess]
	return ok
}

// ResetSuccess resets all changes to the "success" field.
func (m *OperationAuditLogMutation) ResetSuccess() {
	m.success = nil
	delete(m.clearedFields, operationauditlog.FieldSuccess)
}

// SetFailureReason sets the "failure_reason" field.
func (m *OperationAuditLogMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *OperationAuditLogMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *OperationAuditLogMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[operationauditlog.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *OperationAuditLogMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *OperationAuditLogMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, operationauditlog.FieldFailureReason)
}

// SetIPAddress sets the "ip_address" field.
func (m *OperationAuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *OperationAuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *OperationAuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[operationauditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *OperationAuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *OperationAuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, operationauditlog.FieldIPAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *OperationAuditLogMutation) SetGeoLocation(al *auditpb.GeoLocation) {
	m.geo_location = &al
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *OperationAuditLogMutation) GeoLocation() (r *auditpb.GeoLocation, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldGeoLocation(ctx context.Context) (v *auditpb.GeoLocation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *OperationAuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[operationauditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *OperationAuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *OperationAuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, operationauditlog.FieldGeoLocation)
}

// SetDeviceInfo sets the "device_info" field.
func (m *OperationAuditLogMutation) SetDeviceInfo(ai *auditpb.DeviceInfo) {
	m.device_info = &ai
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *OperationAuditLogMutation) DeviceInfo() (r *auditpb.DeviceInfo, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldDeviceInfo(ctx context.Context) (v *auditpb.DeviceInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *OperationAuditLogMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[operationauditlog.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *OperationAuditLogMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *OperationAuditLogMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, operationauditlog.FieldDeviceInfo)
}

// SetLogHash sets the "log_hash" field.
func (m *OperationAuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *OperationAuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldLogHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *OperationAuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[operationauditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *OperationAuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *OperationAuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, operationauditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *OperationAuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *OperationAuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the OperationAuditLog entity.
// If the OperationAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationAuditLogMutation) OldSignature(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *OperationAuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[operationauditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *OperationAuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[operationauditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *OperationAuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, operationauditlog.FieldSignature)
}

// Where appends a list predicates to the OperationAuditLogMutation builder.
func (m *OperationAuditLogMutation) Where(ps ...predicate.OperationAuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperationAuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperationAuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OperationAuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperationAuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperationAuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OperationAuditLog).
func (m *OperationAuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperationAuditLogMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, operationauditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, operationauditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, operationauditlog.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, operationauditlog.FieldUsername)
	}
	if m.resource_type != nil {
		fields = append(fields, operationauditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, operationauditlog.FieldResourceID)
	}
	if m.action != nil {
		fields = append(fields, operationauditlog.FieldAction)
	}
	if m.before_data != nil {
		fields = append(fields, operationauditlog.FieldBeforeData)
	}
	if m.after_data != nil {
		fields = append(fields, operationauditlog.FieldAfterData)
	}
	if m.sensitive_level != nil {
		fields = append(fields, operationauditlog.FieldSensitiveLevel)
	}
	if m.request_id != nil {
		fields = append(fields, operationauditlog.FieldRequestID)
	}
	if m.trace_id != nil {
		fields = append(fields, operationauditlog.FieldTraceID)
	}
	if m.success != nil {
		fields = append(fields, operationauditlog.FieldSuccess)
	}
	if m.failure_reason != nil {
		fields = append(fields, operationauditlog.FieldFailureReason)
	}
	if m.ip_address != nil {
		fields = append(fields, operationauditlog.FieldIPAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, operationauditlog.FieldGeoLocation)
	}
	if m.device_info != nil {
		fields = append(fields, operationauditlog.FieldDeviceInfo)
	}
	if m.log_hash != nil {
		fields = append(fields, operationauditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, operationauditlog.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperationAuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operationauditlog.FieldCreatedAt:
		return m.CreatedAt()
	case operationauditlog.FieldTenantID:
		return m.TenantID()
	case operationauditlog.FieldUserID:
		return m.UserID()
	case operationauditlog.FieldUsername:
		return m.Username()
	case operationauditlog.FieldResourceType:
		return m.ResourceType()
	case operationauditlog.FieldResourceID:
		return m.ResourceID()
	case operationauditlog.FieldAction:
		return m.Action()
	case operationauditlog.FieldBeforeData:
		return m.BeforeData()
	case operationauditlog.FieldAfterData:
		return m.AfterData()
	case operationauditlog.FieldSensitiveLevel:
		return m.SensitiveLevel()
	case operationauditlog.FieldRequestID:
		return m.RequestID()
	case operationauditlog.FieldTraceID:
		return m.TraceID()
	case operationauditlog.FieldSuccess:
		return m.Success()
	case operationauditlog.FieldFailureReason:
		return m.FailureReason()
	case operationauditlog.FieldIPAddress:
		return m.IPAddress()
	case operationauditlog.FieldGeoLocation:
		return m.GeoLocation()
	case operationauditlog.FieldDeviceInfo:
		return m.DeviceInfo()
	case operationauditlog.FieldLogHash:
		return m.LogHash()
	case operationauditlog.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperationAuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operationauditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case operationauditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case operationauditlog.FieldUserID:
		return m.OldUserID(ctx)
	case operationauditlog.FieldUsername:
		return m.OldUsername(ctx)
	case operationauditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case operationauditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case operationauditlog.FieldAction:
		return m.OldAction(ctx)
	case operationauditlog.FieldBeforeData:
		return m.OldBeforeData(ctx)
	case operationauditlog.FieldAfterData:
		return m.OldAfterData(ctx)
	case operationauditlog.FieldSensitiveLevel:
		return m.OldSensitiveLevel(ctx)
	case operationauditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case operationauditlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case operationauditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case operationauditlog.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case operationauditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case operationauditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case operationauditlog.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case operationauditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case operationauditlog.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown OperationAuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationAuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operationauditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case operationauditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case operationauditlog.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case operationauditlog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operationauditlog.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case operationauditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case operationauditlog.FieldAction:
		v, ok := value.(operationauditlog.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case operationauditlog.FieldBeforeData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeforeData(v)
		return nil
	case operationauditlog.FieldAfterData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterData(v)
		return nil
	case operationauditlog.FieldSensitiveLevel:
		v, ok := value.(operationauditlog.SensitiveLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitiveLevel(v)
		return nil
	case operationauditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case operationauditlog.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case operationauditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case operationauditlog.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case operationauditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case operationauditlog.FieldGeoLocation:
		v, ok := value.(*auditpb.GeoLocation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case operationauditlog.FieldDeviceInfo:
		v, ok := value.(*auditpb.DeviceInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case operationauditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case operationauditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown OperationAuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperationAuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, operationauditlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, operationauditlog.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperationAuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case operationauditlog.FieldTenantID:
		return m.AddedTenantID()
	case operationauditlog.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationAuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case operationauditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case operationauditlog.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OperationAuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperationAuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operationauditlog.FieldCreatedAt) {
		fields = append(fields, operationauditlog.FieldCreatedAt)
	}
	if m.FieldCleared(operationauditlog.FieldTenantID) {
		fields = append(fields, operationauditlog.FieldTenantID)
	}
	if m.FieldCleared(operationauditlog.FieldUserID) {
		fields = append(fields, operationauditlog.FieldUserID)
	}
	if m.FieldCleared(operationauditlog.FieldUsername) {
		fields = append(fields, operationauditlog.FieldUsername)
	}
	if m.FieldCleared(operationauditlog.FieldResourceType) {
		fields = append(fields, operationauditlog.FieldResourceType)
	}
	if m.FieldCleared(operationauditlog.FieldResourceID) {
		fields = append(fields, operationauditlog.FieldResourceID)
	}
	if m.FieldCleared(operationauditlog.FieldAction) {
		fields = append(fields, operationauditlog.FieldAction)
	}
	if m.FieldCleared(operationauditlog.FieldBeforeData) {
		fields = append(fields, operationauditlog.FieldBeforeData)
	}
	if m.FieldCleared(operationauditlog.FieldAfterData) {
		fields = append(fields, operationauditlog.FieldAfterData)
	}
	if m.FieldCleared(operationauditlog.FieldSensitiveLevel) {
		fields = append(fields, operationauditlog.FieldSensitiveLevel)
	}
	if m.FieldCleared(operationauditlog.FieldRequestID) {
		fields = append(fields, operationauditlog.FieldRequestID)
	}
	if m.FieldCleared(operationauditlog.FieldTraceID) {
		fields = append(fields, operationauditlog.FieldTraceID)
	}
	if m.FieldCleared(operationauditlog.FieldSuccess) {
		fields = append(fields, operationauditlog.FieldSuccess)
	}
	if m.FieldCleared(operationauditlog.FieldFailureReason) {
		fields = append(fields, operationauditlog.FieldFailureReason)
	}
	if m.FieldCleared(operationauditlog.FieldIPAddress) {
		fields = append(fields, operationauditlog.FieldIPAddress)
	}
	if m.FieldCleared(operationauditlog.FieldGeoLocation) {
		fields = append(fields, operationauditlog.FieldGeoLocation)
	}
	if m.FieldCleared(operationauditlog.FieldDeviceInfo) {
		fields = append(fields, operationauditlog.FieldDeviceInfo)
	}
	if m.FieldCleared(operationauditlog.FieldLogHash) {
		fields = append(fields, operationauditlog.FieldLogHash)
	}
	if m.FieldCleared(operationauditlog.FieldSignature) {
		fields = append(fields, operationauditlog.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperationAuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperationAuditLogMutation) ClearField(name string) error {
	switch name {
	case operationauditlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case operationauditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case operationauditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case operationauditlog.FieldUsername:
		m.ClearUsername()
		return nil
	case operationauditlog.FieldResourceType:
		m.ClearResourceType()
		return nil
	case operationauditlog.FieldResourceID:
		m.ClearResourceID()
		return nil
	case operationauditlog.FieldAction:
		m.ClearAction()
		return nil
	case operationauditlog.FieldBeforeData:
		m.ClearBeforeData()
		return nil
	case operationauditlog.FieldAfterData:
		m.ClearAfterData()
		return nil
	case operationauditlog.FieldSensitiveLevel:
		m.ClearSensitiveLevel()
		return nil
	case operationauditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case operationauditlog.FieldTraceID:
		m.ClearTraceID()
		return nil
	case operationauditlog.FieldSuccess:
		m.ClearSuccess()
		return nil
	case operationauditlog.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case operationauditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case operationauditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case operationauditlog.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case operationauditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case operationauditlog.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown OperationAuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperationAuditLogMutation) ResetField(name string) error {
	switch name {
	case operationauditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case operationauditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case operationauditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case operationauditlog.FieldUsername:
		m.ResetUsername()
		return nil
	case operationauditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case operationauditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case operationauditlog.FieldAction:
		m.ResetAction()
		return nil
	case operationauditlog.FieldBeforeData:
		m.ResetBeforeData()
		return nil
	case operationauditlog.FieldAfterData:
		m.ResetAfterData()
		return nil
	case operationauditlog.FieldSensitiveLevel:
		m.ResetSensitiveLevel()
		return nil
	case operationauditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case operationauditlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case operationauditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case operationauditlog.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case operationauditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case operationauditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case operationauditlog.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case operationauditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case operationauditlog.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown OperationAuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperationAuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperationAuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperationAuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperationAuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperationAuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperationAuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperationAuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OperationAuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperationAuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OperationAuditLog edge %s", name)
}

// OrgUnitMutation represents an operation that mutates the OrgUnit nodes in the graph.
type OrgUnitMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint32
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	created_by             *uint32
	addcreated_by          *int32
	updated_by             *uint32
	addupdated_by          *int32
	deleted_by             *uint32
	adddeleted_by          *int32
	status                 *orgunit.Status
	sort_order             *uint32
	addsort_order          *int32
	tenant_id              *uint32
	addtenant_id           *int32
	remark                 *string
	description            *string
	_path                  *string
	name                   *string
	code                   *string
	leader_id              *uint32
	addleader_id           *int32
	_type                  *orgunit.Type
	business_scopes        *[]string
	appendbusiness_scopes  []string
	external_id            *string
	is_legal_entity        *bool
	registration_number    *string
	tax_id                 *string
	legal_entity_org_id    *uint32
	addlegal_entity_org_id *int32
	address                *string
	phone                  *string
	email                  *string
	timezone               *string
	country                *string
	latitude               *float64
	addlatitude            *float64
	longitude              *float64
	addlongitude           *float64
	start_at               *time.Time
	end_at                 *time.Time
	contact_user_id        *uint32
	addcontact_user_id     *int32
	permission_tags        *[]string
	appendpermission_tags  []string
	clearedFields          map[string]struct{}
	parent                 *uint32
	clearedparent          bool
	children               map[uint32]struct{}
	removedchildren        map[uint32]struct{}
	clearedchildren        bool
	done                   bool
	oldValue               func(context.Context) (*OrgUnit, error)
	predicates             []predicate.OrgUnit
}

var _ ent.Mutation = (*OrgUnitMutation)(nil)

// orgunitOption allows management of the mutation configuration using functional options.
type orgunitOption func(*OrgUnitMutation)

// newOrgUnitMutation creates new mutation for the OrgUnit entity.
func newOrgUnitMutation(c config, op Op, opts ...orgunitOption) *OrgUnitMutation {
	m := &OrgUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgUnitID sets the ID field of the mutation.
func withOrgUnitID(id uint32) orgunitOption {
	return func(m *OrgUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgUnit
		)
		m.oldValue = func(ctx context.Context) (*OrgUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgUnit sets the old OrgUnit of the mutation.
func withOrgUnit(node *OrgUnit) orgunitOption {
	return func(m *OrgUnitMutation) {
		m.oldValue = func(context.Context) (*OrgUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgUnit entities.
func (m *OrgUnitMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgUnitMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgUnitMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrgUnitMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orgunit.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrgUnitMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgUnitMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orgunit.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgUnitMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgunit.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgUnitMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgunit.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrgUnitMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrgUnitMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrgUnitMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orgunit.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrgUnitMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrgUnitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orgunit.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgUnitMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgUnitMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *OrgUnitMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgUnitMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrgUnitMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[orgunit.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrgUnitMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgUnitMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, orgunit.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgUnitMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgUnitMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *OrgUnitMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgUnitMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgUnitMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[orgunit.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgUnitMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgUnitMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, orgunit.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrgUnitMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrgUnitMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *OrgUnitMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *OrgUnitMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrgUnitMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[orgunit.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrgUnitMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrgUnitMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, orgunit.FieldDeletedBy)
}

// SetStatus sets the "status" field.
func (m *OrgUnitMutation) SetStatus(o orgunit.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrgUnitMutation) Status() (r orgunit.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldStatus(ctx context.Context) (v *orgunit.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrgUnitMutation) ResetStatus() {
	m.status = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *OrgUnitMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *OrgUnitMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *OrgUnitMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *OrgUnitMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *OrgUnitMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[orgunit.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *OrgUnitMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *OrgUnitMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, orgunit.FieldSortOrder)
}

// SetTenantID sets the "tenant_id" field.
func (m *OrgUnitMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OrgUnitMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *OrgUnitMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *OrgUnitMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *OrgUnitMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[orgunit.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *OrgUnitMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OrgUnitMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, orgunit.FieldTenantID)
}

// SetRemark sets the "remark" field.
func (m *OrgUnitMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrgUnitMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrgUnitMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[orgunit.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrgUnitMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrgUnitMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, orgunit.FieldRemark)
}

// SetDescription sets the "description" field.
func (m *OrgUnitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrgUnitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrgUnitMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[orgunit.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrgUnitMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrgUnitMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, orgunit.FieldDescription)
}

// SetParentID sets the "parent_id" field.
func (m *OrgUnitMutation) SetParentID(u uint32) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrgUnitMutation) ParentID() (r uint32, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *OrgUnitMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[orgunit.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *OrgUnitMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrgUnitMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, orgunit.FieldParentID)
}

// SetPath sets the "path" field.
func (m *OrgUnitMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *OrgUnitMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *OrgUnitMutation) ClearPath() {
	m._path = nil
	m.clearedFields[orgunit.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *OrgUnitMutation) PathCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *OrgUnitMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, orgunit.FieldPath)
}

// SetName sets the "name" field.
func (m *OrgUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgUnitMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *OrgUnitMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrgUnitMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *OrgUnitMutation) ClearCode() {
	m.code = nil
	m.clearedFields[orgunit.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *OrgUnitMutation) CodeCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *OrgUnitMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, orgunit.FieldCode)
}

// SetLeaderID sets the "leader_id" field.
func (m *OrgUnitMutation) SetLeaderID(u uint32) {
	m.leader_id = &u
	m.addleader_id = nil
}

// LeaderID returns the value of the "leader_id" field in the mutation.
func (m *OrgUnitMutation) LeaderID() (r uint32, exists bool) {
	v := m.leader_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderID returns the old "leader_id" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldLeaderID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderID: %w", err)
	}
	return oldValue.LeaderID, nil
}

// AddLeaderID adds u to the "leader_id" field.
func (m *OrgUnitMutation) AddLeaderID(u int32) {
	if m.addleader_id != nil {
		*m.addleader_id += u
	} else {
		m.addleader_id = &u
	}
}

// AddedLeaderID returns the value that was added to the "leader_id" field in this mutation.
func (m *OrgUnitMutation) AddedLeaderID() (r int32, exists bool) {
	v := m.addleader_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLeaderID clears the value of the "leader_id" field.
func (m *OrgUnitMutation) ClearLeaderID() {
	m.leader_id = nil
	m.addleader_id = nil
	m.clearedFields[orgunit.FieldLeaderID] = struct{}{}
}

// LeaderIDCleared returns if the "leader_id" field was cleared in this mutation.
func (m *OrgUnitMutation) LeaderIDCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldLeaderID]
	return ok
}

// ResetLeaderID resets all changes to the "leader_id" field.
func (m *OrgUnitMutation) ResetLeaderID() {
	m.leader_id = nil
	m.addleader_id = nil
	delete(m.clearedFields, orgunit.FieldLeaderID)
}

// SetType sets the "type" field.
func (m *OrgUnitMutation) SetType(o orgunit.Type) {
	m._type = &o
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrgUnitMutation) GetType() (r orgunit.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldType(ctx context.Context) (v *orgunit.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrgUnitMutation) ResetType() {
	m._type = nil
}

// SetBusinessScopes sets the "business_scopes" field.
func (m *OrgUnitMutation) SetBusinessScopes(s []string) {
	m.business_scopes = &s
	m.appendbusiness_scopes = nil
}

// BusinessScopes returns the value of the "business_scopes" field in the mutation.
func (m *OrgUnitMutation) BusinessScopes() (r []string, exists bool) {
	v := m.business_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessScopes returns the old "business_scopes" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldBusinessScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessScopes: %w", err)
	}
	return oldValue.BusinessScopes, nil
}

// AppendBusinessScopes adds s to the "business_scopes" field.
func (m *OrgUnitMutation) AppendBusinessScopes(s []string) {
	m.appendbusiness_scopes = append(m.appendbusiness_scopes, s...)
}

// AppendedBusinessScopes returns the list of values that were appended to the "business_scopes" field in this mutation.
func (m *OrgUnitMutation) AppendedBusinessScopes() ([]string, bool) {
	if len(m.appendbusiness_scopes) == 0 {
		return nil, false
	}
	return m.appendbusiness_scopes, true
}

// ClearBusinessScopes clears the value of the "business_scopes" field.
func (m *OrgUnitMutation) ClearBusinessScopes() {
	m.business_scopes = nil
	m.appendbusiness_scopes = nil
	m.clearedFields[orgunit.FieldBusinessScopes] = struct{}{}
}

// BusinessScopesCleared returns if the "business_scopes" field was cleared in this mutation.
func (m *OrgUnitMutation) BusinessScopesCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldBusinessScopes]
	return ok
}

// ResetBusinessScopes resets all changes to the "business_scopes" field.
func (m *OrgUnitMutation) ResetBusinessScopes() {
	m.business_scopes = nil
	m.appendbusiness_scopes = nil
	delete(m.clearedFields, orgunit.FieldBusinessScopes)
}

// SetExternalID sets the "external_id" field.
func (m *OrgUnitMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OrgUnitMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OrgUnitMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[orgunit.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OrgUnitMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OrgUnitMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, orgunit.FieldExternalID)
}

// SetIsLegalEntity sets the "is_legal_entity" field.
func (m *OrgUnitMutation) SetIsLegalEntity(b bool) {
	m.is_legal_entity = &b
}

// IsLegalEntity returns the value of the "is_legal_entity" field in the mutation.
func (m *OrgUnitMutation) IsLegalEntity() (r bool, exists bool) {
	v := m.is_legal_entity
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLegalEntity returns the old "is_legal_entity" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldIsLegalEntity(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLegalEntity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLegalEntity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLegalEntity: %w", err)
	}
	return oldValue.IsLegalEntity, nil
}

// ClearIsLegalEntity clears the value of the "is_legal_entity" field.
func (m *OrgUnitMutation) ClearIsLegalEntity() {
	m.is_legal_entity = nil
	m.clearedFields[orgunit.FieldIsLegalEntity] = struct{}{}
}

// IsLegalEntityCleared returns if the "is_legal_entity" field was cleared in this mutation.
func (m *OrgUnitMutation) IsLegalEntityCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldIsLegalEntity]
	return ok
}

// ResetIsLegalEntity resets all changes to the "is_legal_entity" field.
func (m *OrgUnitMutation) ResetIsLegalEntity() {
	m.is_legal_entity = nil
	delete(m.clearedFields, orgunit.FieldIsLegalEntity)
}

// SetRegistrationNumber sets the "registration_number" field.
func (m *OrgUnitMutation) SetRegistrationNumber(s string) {
	m.registration_number = &s
}

// RegistrationNumber returns the value of the "registration_number" field in the mutation.
func (m *OrgUnitMutation) RegistrationNumber() (r string, exists bool) {
	v := m.registration_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationNumber returns the old "registration_number" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldRegistrationNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationNumber: %w", err)
	}
	return oldValue.RegistrationNumber, nil
}

// ClearRegistrationNumber clears the value of the "registration_number" field.
func (m *OrgUnitMutation) ClearRegistrationNumber() {
	m.registration_number = nil
	m.clearedFields[orgunit.FieldRegistrationNumber] = struct{}{}
}

// RegistrationNumberCleared returns if the "registration_number" field was cleared in this mutation.
func (m *OrgUnitMutation) RegistrationNumberCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldRegistrationNumber]
	return ok
}

// ResetRegistrationNumber resets all changes to the "registration_number" field.
func (m *OrgUnitMutation) ResetRegistrationNumber() {
	m.registration_number = nil
	delete(m.clearedFields, orgunit.FieldRegistrationNumber)
}

// SetTaxID sets the "tax_id" field.
func (m *OrgUnitMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *OrgUnitMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldTaxID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *OrgUnitMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[orgunit.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *OrgUnitMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *OrgUnitMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, orgunit.FieldTaxID)
}

// SetLegalEntityOrgID sets the "legal_entity_org_id" field.
func (m *OrgUnitMutation) SetLegalEntityOrgID(u uint32) {
	m.legal_entity_org_id = &u
	m.addlegal_entity_org_id = nil
}

// LegalEntityOrgID returns the value of the "legal_entity_org_id" field in the mutation.
func (m *OrgUnitMutation) LegalEntityOrgID() (r uint32, exists bool) {
	v := m.legal_entity_org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalEntityOrgID returns the old "legal_entity_org_id" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldLegalEntityOrgID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalEntityOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalEntityOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalEntityOrgID: %w", err)
	}
	return oldValue.LegalEntityOrgID, nil
}

// AddLegalEntityOrgID adds u to the "legal_entity_org_id" field.
func (m *OrgUnitMutation) AddLegalEntityOrgID(u int32) {
	if m.addlegal_entity_org_id != nil {
		*m.addlegal_entity_org_id += u
	} else {
		m.addlegal_entity_org_id = &u
	}
}

// AddedLegalEntityOrgID returns the value that was added to the "legal_entity_org_id" field in this mutation.
func (m *OrgUnitMutation) AddedLegalEntityOrgID() (r int32, exists bool) {
	v := m.addlegal_entity_org_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLegalEntityOrgID clears the value of the "legal_entity_org_id" field.
func (m *OrgUnitMutation) ClearLegalEntityOrgID() {
	m.legal_entity_org_id = nil
	m.addlegal_entity_org_id = nil
	m.clearedFields[orgunit.FieldLegalEntityOrgID] = struct{}{}
}

// LegalEntityOrgIDCleared returns if the "legal_entity_org_id" field was cleared in this mutation.
func (m *OrgUnitMutation) LegalEntityOrgIDCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldLegalEntityOrgID]
	return ok
}

// ResetLegalEntityOrgID resets all changes to the "legal_entity_org_id" field.
func (m *OrgUnitMutation) ResetLegalEntityOrgID() {
	m.legal_entity_org_id = nil
	m.addlegal_entity_org_id = nil
	delete(m.clearedFields, orgunit.FieldLegalEntityOrgID)
}

// SetAddress sets the "address" field.
func (m *OrgUnitMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *OrgUnitMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *OrgUnitMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[orgunit.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *OrgUnitMutation) AddressCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *OrgUnitMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, orgunit.FieldAddress)
}

// SetPhone sets the "phone" field.
func (m *OrgUnitMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *OrgUnitMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *OrgUnitMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[orgunit.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *OrgUnitMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *OrgUnitMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, orgunit.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *OrgUnitMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *OrgUnitMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *OrgUnitMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[orgunit.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *OrgUnitMutation) EmailCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *OrgUnitMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, orgunit.FieldEmail)
}

// SetTimezone sets the "timezone" field.
func (m *OrgUnitMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OrgUnitMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldTimezone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OrgUnitMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[orgunit.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OrgUnitMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OrgUnitMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, orgunit.FieldTimezone)
}

// SetCountry sets the "country" field.
func (m *OrgUnitMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *OrgUnitMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *OrgUnitMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[orgunit.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *OrgUnitMutation) CountryCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *OrgUnitMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, orgunit.FieldCountry)
}

// SetLatitude sets the "latitude" field.
func (m *OrgUnitMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *OrgUnitMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *OrgUnitMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *OrgUnitMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *OrgUnitMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[orgunit.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *OrgUnitMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *OrgUnitMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, orgunit.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *OrgUnitMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *OrgUnitMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *OrgUnitMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *OrgUnitMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *OrgUnitMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[orgunit.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *OrgUnitMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *OrgUnitMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, orgunit.FieldLongitude)
}

// SetStartAt sets the "start_at" field.
func (m *OrgUnitMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *OrgUnitMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *OrgUnitMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[orgunit.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *OrgUnitMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *OrgUnitMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, orgunit.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *OrgUnitMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *OrgUnitMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *OrgUnitMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[orgunit.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *OrgUnitMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *OrgUnitMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, orgunit.FieldEndAt)
}

// SetContactUserID sets the "contact_user_id" field.
func (m *OrgUnitMutation) SetContactUserID(u uint32) {
	m.contact_user_id = &u
	m.addcontact_user_id = nil
}

// ContactUserID returns the value of the "contact_user_id" field in the mutation.
func (m *OrgUnitMutation) ContactUserID() (r uint32, exists bool) {
	v := m.contact_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContactUserID returns the old "contact_user_id" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldContactUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactUserID: %w", err)
	}
	return oldValue.ContactUserID, nil
}

// AddContactUserID adds u to the "contact_user_id" field.
func (m *OrgUnitMutation) AddContactUserID(u int32) {
	if m.addcontact_user_id != nil {
		*m.addcontact_user_id += u
	} else {
		m.addcontact_user_id = &u
	}
}

// AddedContactUserID returns the value that was added to the "contact_user_id" field in this mutation.
func (m *OrgUnitMutation) AddedContactUserID() (r int32, exists bool) {
	v := m.addcontact_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContactUserID clears the value of the "contact_user_id" field.
func (m *OrgUnitMutation) ClearContactUserID() {
	m.contact_user_id = nil
	m.addcontact_user_id = nil
	m.clearedFields[orgunit.FieldContactUserID] = struct{}{}
}

// ContactUserIDCleared returns if the "contact_user_id" field was cleared in this mutation.
func (m *OrgUnitMutation) ContactUserIDCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldContactUserID]
	return ok
}

// ResetContactUserID resets all changes to the "contact_user_id" field.
func (m *OrgUnitMutation) ResetContactUserID() {
	m.contact_user_id = nil
	m.addcontact_user_id = nil
	delete(m.clearedFields, orgunit.FieldContactUserID)
}

// SetPermissionTags sets the "permission_tags" field.
func (m *OrgUnitMutation) SetPermissionTags(s []string) {
	m.permission_tags = &s
	m.appendpermission_tags = nil
}

// PermissionTags returns the value of the "permission_tags" field in the mutation.
func (m *OrgUnitMutation) PermissionTags() (r []string, exists bool) {
	v := m.permission_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionTags returns the old "permission_tags" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldPermissionTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionTags: %w", err)
	}
	return oldValue.PermissionTags, nil
}

// AppendPermissionTags adds s to the "permission_tags" field.
func (m *OrgUnitMutation) AppendPermissionTags(s []string) {
	m.appendpermission_tags = append(m.appendpermission_tags, s...)
}

// AppendedPermissionTags returns the list of values that were appended to the "permission_tags" field in this mutation.
func (m *OrgUnitMutation) AppendedPermissionTags() ([]string, bool) {
	if len(m.appendpermission_tags) == 0 {
		return nil, false
	}
	return m.appendpermission_tags, true
}

// ClearPermissionTags clears the value of the "permission_tags" field.
func (m *OrgUnitMutation) ClearPermissionTags() {
	m.permission_tags = nil
	m.appendpermission_tags = nil
	m.clearedFields[orgunit.FieldPermissionTags] = struct{}{}
}

// PermissionTagsCleared returns if the "permission_tags" field was cleared in this mutation.
func (m *OrgUnitMutation) PermissionTagsCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldPermissionTags]
	return ok
}

// ResetPermissionTags resets all changes to the "permission_tags" field.
func (m *OrgUnitMutation) ResetPermissionTags() {
	m.permission_tags = nil
	m.appendpermission_tags = nil
	delete(m.clearedFields, orgunit.FieldPermissionTags)
}

// ClearParent clears the "parent" edge to the OrgUnit entity.
func (m *OrgUnitMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[orgunit.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the OrgUnit entity was cleared.
func (m *OrgUnitMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMutation) ParentIDs() (ids []uint32) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrgUnitMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the OrgUnit entity by ids.
func (m *OrgUnitMutation) AddChildIDs(ids ...uint32) {
	if m.children == nil {
		m.children = make(map[uint32]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the OrgUnit entity.
func (m *OrgUnitMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the OrgUnit entity was cleared.
func (m *OrgUnitMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the OrgUnit entity by IDs.
func (m *OrgUnitMutation) RemoveChildIDs(ids ...uint32) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the OrgUnit entity.
func (m *OrgUnitMutation) RemovedChildrenIDs() (ids []uint32) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrgUnitMutation) ChildrenIDs() (ids []uint32) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrgUnitMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the OrgUnitMutation builder.
func (m *OrgUnitMutation) Where(ps ...predicate.OrgUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgUnit).
func (m *OrgUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgUnitMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.created_at != nil {
		fields = append(fields, orgunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orgunit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orgunit.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, orgunit.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, orgunit.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, orgunit.FieldDeletedBy)
	}
	if m.status != nil {
		fields = append(fields, orgunit.FieldStatus)
	}
	if m.sort_order != nil {
		fields = append(fields, orgunit.FieldSortOrder)
	}
	if m.tenant_id != nil {
		fields = append(fields, orgunit.FieldTenantID)
	}
	if m.remark != nil {
		fields = append(fields, orgunit.FieldRemark)
	}
	if m.description != nil {
		fields = append(fields, orgunit.FieldDescription)
	}
	if m.parent != nil {
		fields = append(fields, orgunit.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, orgunit.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, orgunit.FieldName)
	}
	if m.code != nil {
		fields = append(fields, orgunit.FieldCode)
	}
	if m.leader_id != nil {
		fields = append(fields, orgunit.FieldLeaderID)
	}
	if m._type != nil {
		fields = append(fields, orgunit.FieldType)
	}
	if m.business_scopes != nil {
		fields = append(fields, orgunit.FieldBusinessScopes)
	}
	if m.external_id != nil {
		fields = append(fields, orgunit.FieldExternalID)
	}
	if m.is_legal_entity != nil {
		fields = append(fields, orgunit.FieldIsLegalEntity)
	}
	if m.registration_number != nil {
		fields = append(fields, orgunit.FieldRegistrationNumber)
	}
	if m.tax_id != nil {
		fields = append(fields, orgunit.FieldTaxID)
	}
	if m.legal_entity_org_id != nil {
		fields = append(fields, orgunit.FieldLegalEntityOrgID)
	}
	if m.address != nil {
		fields = append(fields, orgunit.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, orgunit.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, orgunit.FieldEmail)
	}
	if m.timezone != nil {
		fields = append(fields, orgunit.FieldTimezone)
	}
	if m.country != nil {
		fields = append(fields, orgunit.FieldCountry)
	}
	if m.latitude != nil {
		fields = append(fields, orgunit.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, orgunit.FieldLongitude)
	}
	if m.start_at != nil {
		fields = append(fields, orgunit.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, orgunit.FieldEndAt)
	}
	if m.contact_user_id != nil {
		fields = append(fields, orgunit.FieldContactUserID)
	}
	if m.permission_tags != nil {
		fields = append(fields, orgunit.FieldPermissionTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgunit.FieldCreatedAt:
		return m.CreatedAt()
	case orgunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgunit.FieldDeletedAt:
		return m.DeletedAt()
	case orgunit.FieldCreatedBy:
		return m.CreatedBy()
	case orgunit.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgunit.FieldDeletedBy:
		return m.DeletedBy()
	case orgunit.FieldStatus:
		return m.Status()
	case orgunit.FieldSortOrder:
		return m.SortOrder()
	case orgunit.FieldTenantID:
		return m.TenantID()
	case orgunit.FieldRemark:
		return m.Remark()
	case orgunit.FieldDescription:
		return m.Description()
	case orgunit.FieldParentID:
		return m.ParentID()
	case orgunit.FieldPath:
		return m.Path()
	case orgunit.FieldName:
		return m.Name()
	case orgunit.FieldCode:
		return m.Code()
	case orgunit.FieldLeaderID:
		return m.LeaderID()
	case orgunit.FieldType:
		return m.GetType()
	case orgunit.FieldBusinessScopes:
		return m.BusinessScopes()
	case orgunit.FieldExternalID:
		return m.ExternalID()
	case orgunit.FieldIsLegalEntity:
		return m.IsLegalEntity()
	case orgunit.FieldRegistrationNumber:
		return m.RegistrationNumber()
	case orgunit.FieldTaxID:
		return m.TaxID()
	case orgunit.FieldLegalEntityOrgID:
		return m.LegalEntityOrgID()
	case orgunit.FieldAddress:
		return m.Address()
	case orgunit.FieldPhone:
		return m.Phone()
	case orgunit.FieldEmail:
		return m.Email()
	case orgunit.FieldTimezone:
		return m.Timezone()
	case orgunit.FieldCountry:
		return m.Country()
	case orgunit.FieldLatitude:
		return m.Latitude()
	case orgunit.FieldLongitude:
		return m.Longitude()
	case orgunit.FieldStartAt:
		return m.StartAt()
	case orgunit.FieldEndAt:
		return m.EndAt()
	case orgunit.FieldContactUserID:
		return m.ContactUserID()
	case orgunit.FieldPermissionTags:
		return m.PermissionTags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgunit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orgunit.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgunit.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgunit.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case orgunit.FieldStatus:
		return m.OldStatus(ctx)
	case orgunit.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case orgunit.FieldTenantID:
		return m.OldTenantID(ctx)
	case orgunit.FieldRemark:
		return m.OldRemark(ctx)
	case orgunit.FieldDescription:
		return m.OldDescription(ctx)
	case orgunit.FieldParentID:
		return m.OldParentID(ctx)
	case orgunit.FieldPath:
		return m.OldPath(ctx)
	case orgunit.FieldName:
		return m.OldName(ctx)
	case orgunit.FieldCode:
		return m.OldCode(ctx)
	case orgunit.FieldLeaderID:
		return m.OldLeaderID(ctx)
	case orgunit.FieldType:
		return m.OldType(ctx)
	case orgunit.FieldBusinessScopes:
		return m.OldBusinessScopes(ctx)
	case orgunit.FieldExternalID:
		return m.OldExternalID(ctx)
	case orgunit.FieldIsLegalEntity:
		return m.OldIsLegalEntity(ctx)
	case orgunit.FieldRegistrationNumber:
		return m.OldRegistrationNumber(ctx)
	case orgunit.FieldTaxID:
		return m.OldTaxID(ctx)
	case orgunit.FieldLegalEntityOrgID:
		return m.OldLegalEntityOrgID(ctx)
	case orgunit.FieldAddress:
		return m.OldAddress(ctx)
	case orgunit.FieldPhone:
		return m.OldPhone(ctx)
	case orgunit.FieldEmail:
		return m.OldEmail(ctx)
	case orgunit.FieldTimezone:
		return m.OldTimezone(ctx)
	case orgunit.FieldCountry:
		return m.OldCountry(ctx)
	case orgunit.FieldLatitude:
		return m.OldLatitude(ctx)
	case orgunit.FieldLongitude:
		return m.OldLongitude(ctx)
	case orgunit.FieldStartAt:
		return m.OldStartAt(ctx)
	case orgunit.FieldEndAt:
		return m.OldEndAt(ctx)
	case orgunit.FieldContactUserID:
		return m.OldContactUserID(ctx)
	case orgunit.FieldPermissionTags:
		return m.OldPermissionTags(ctx)
	}
	return nil, fmt.Errorf("unknown OrgUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgunit.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orgunit.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgunit.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgunit.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case orgunit.FieldStatus:
		v, ok := value.(orgunit.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orgunit.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case orgunit.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case orgunit.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case orgunit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case orgunit.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case orgunit.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case orgunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orgunit.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case orgunit.FieldLeaderID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderID(v)
		return nil
	case orgunit.FieldType:
		v, ok := value.(orgunit.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orgunit.FieldBusinessScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessScopes(v)
		return nil
	case orgunit.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case orgunit.FieldIsLegalEntity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLegalEntity(v)
		return nil
	case orgunit.FieldRegistrationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationNumber(v)
		return nil
	case orgunit.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case orgunit.FieldLegalEntityOrgID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalEntityOrgID(v)
		return nil
	case orgunit.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case orgunit.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case orgunit.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case orgunit.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case orgunit.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case orgunit.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case orgunit.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case orgunit.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case orgunit.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case orgunit.FieldContactUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactUserID(v)
		return nil
	case orgunit.FieldPermissionTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionTags(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgUnitMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, orgunit.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orgunit.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, orgunit.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, orgunit.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, orgunit.FieldTenantID)
	}
	if m.addleader_id != nil {
		fields = append(fields, orgunit.FieldLeaderID)
	}
	if m.addlegal_entity_org_id != nil {
		fields = append(fields, orgunit.FieldLegalEntityOrgID)
	}
	if m.addlatitude != nil {
		fields = append(fields, orgunit.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, orgunit.FieldLongitude)
	}
	if m.addcontact_user_id != nil {
		fields = append(fields, orgunit.FieldContactUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgunit.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orgunit.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case orgunit.FieldDeletedBy:
		return m.AddedDeletedBy()
	case orgunit.FieldSortOrder:
		return m.AddedSortOrder()
	case orgunit.FieldTenantID:
		return m.AddedTenantID()
	case orgunit.FieldLeaderID:
		return m.AddedLeaderID()
	case orgunit.FieldLegalEntityOrgID:
		return m.AddedLegalEntityOrgID()
	case orgunit.FieldLatitude:
		return m.AddedLatitude()
	case orgunit.FieldLongitude:
		return m.AddedLongitude()
	case orgunit.FieldContactUserID:
		return m.AddedContactUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgunit.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orgunit.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case orgunit.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case orgunit.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case orgunit.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case orgunit.FieldLeaderID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeaderID(v)
		return nil
	case orgunit.FieldLegalEntityOrgID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLegalEntityOrgID(v)
		return nil
	case orgunit.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case orgunit.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case orgunit.FieldContactUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContactUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgunit.FieldCreatedAt) {
		fields = append(fields, orgunit.FieldCreatedAt)
	}
	if m.FieldCleared(orgunit.FieldUpdatedAt) {
		fields = append(fields, orgunit.FieldUpdatedAt)
	}
	if m.FieldCleared(orgunit.FieldDeletedAt) {
		fields = append(fields, orgunit.FieldDeletedAt)
	}
	if m.FieldCleared(orgunit.FieldCreatedBy) {
		fields = append(fields, orgunit.FieldCreatedBy)
	}
	if m.FieldCleared(orgunit.FieldUpdatedBy) {
		fields = append(fields, orgunit.FieldUpdatedBy)
	}
	if m.FieldCleared(orgunit.FieldDeletedBy) {
		fields = append(fields, orgunit.FieldDeletedBy)
	}
	if m.FieldCleared(orgunit.FieldSortOrder) {
		fields = append(fields, orgunit.FieldSortOrder)
	}
	if m.FieldCleared(orgunit.FieldTenantID) {
		fields = append(fields, orgunit.FieldTenantID)
	}
	if m.FieldCleared(orgunit.FieldRemark) {
		fields = append(fields, orgunit.FieldRemark)
	}
	if m.FieldCleared(orgunit.FieldDescription) {
		fields = append(fields, orgunit.FieldDescription)
	}
	if m.FieldCleared(orgunit.FieldParentID) {
		fields = append(fields, orgunit.FieldParentID)
	}
	if m.FieldCleared(orgunit.FieldPath) {
		fields = append(fields, orgunit.FieldPath)
	}
	if m.FieldCleared(orgunit.FieldCode) {
		fields = append(fields, orgunit.FieldCode)
	}
	if m.FieldCleared(orgunit.FieldLeaderID) {
		fields = append(fields, orgunit.FieldLeaderID)
	}
	if m.FieldCleared(orgunit.FieldBusinessScopes) {
		fields = append(fields, orgunit.FieldBusinessScopes)
	}
	if m.FieldCleared(orgunit.FieldExternalID) {
		fields = append(fields, orgunit.FieldExternalID)
	}
	if m.FieldCleared(orgunit.FieldIsLegalEntity) {
		fields = append(fields, orgunit.FieldIsLegalEntity)
	}
	if m.FieldCleared(orgunit.FieldRegistrationNumber) {
		fields = append(fields, orgunit.FieldRegistrationNumber)
	}
	if m.FieldCleared(orgunit.FieldTaxID) {
		fields = append(fields, orgunit.FieldTaxID)
	}
	if m.FieldCleared(orgunit.FieldLegalEntityOrgID) {
		fields = append(fields, orgunit.FieldLegalEntityOrgID)
	}
	if m.FieldCleared(orgunit.FieldAddress) {
		fields = append(fields, orgunit.FieldAddress)
	}
	if m.FieldCleared(orgunit.FieldPhone) {
		fields = append(fields, orgunit.FieldPhone)
	}
	if m.FieldCleared(orgunit.FieldEmail) {
		fields = append(fields, orgunit.FieldEmail)
	}
	if m.FieldCleared(orgunit.FieldTimezone) {
		fields = append(fields, orgunit.FieldTimezone)
	}
	if m.FieldCleared(orgunit.FieldCountry) {
		fields = append(fields, orgunit.FieldCountry)
	}
	if m.FieldCleared(orgunit.FieldLatitude) {
		fields = append(fields, orgunit.FieldLatitude)
	}
	if m.FieldCleared(orgunit.FieldLongitude) {
		fields = append(fields, orgunit.FieldLongitude)
	}
	if m.FieldCleared(orgunit.FieldStartAt) {
		fields = append(fields, orgunit.FieldStartAt)
	}
	if m.FieldCleared(orgunit.FieldEndAt) {
		fields = append(fields, orgunit.FieldEndAt)
	}
	if m.FieldCleared(orgunit.FieldContactUserID) {
		fields = append(fields, orgunit.FieldContactUserID)
	}
	if m.FieldCleared(orgunit.FieldPermissionTags) {
		fields = append(fields, orgunit.FieldPermissionTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgUnitMutation) ClearField(name string) error {
	switch name {
	case orgunit.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orgunit.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orgunit.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orgunit.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case orgunit.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgunit.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case orgunit.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case orgunit.FieldTenantID:
		m.ClearTenantID()
		return nil
	case orgunit.FieldRemark:
		m.ClearRemark()
		return nil
	case orgunit.FieldDescription:
		m.ClearDescription()
		return nil
	case orgunit.FieldParentID:
		m.ClearParentID()
		return nil
	case orgunit.FieldPath:
		m.ClearPath()
		return nil
	case orgunit.FieldCode:
		m.ClearCode()
		return nil
	case orgunit.FieldLeaderID:
		m.ClearLeaderID()
		return nil
	case orgunit.FieldBusinessScopes:
		m.ClearBusinessScopes()
		return nil
	case orgunit.FieldExternalID:
		m.ClearExternalID()
		return nil
	case orgunit.FieldIsLegalEntity:
		m.ClearIsLegalEntity()
		return nil
	case orgunit.FieldRegistrationNumber:
		m.ClearRegistrationNumber()
		return nil
	case orgunit.FieldTaxID:
		m.ClearTaxID()
		return nil
	case orgunit.FieldLegalEntityOrgID:
		m.ClearLegalEntityOrgID()
		return nil
	case orgunit.FieldAddress:
		m.ClearAddress()
		return nil
	case orgunit.FieldPhone:
		m.ClearPhone()
		return nil
	case orgunit.FieldEmail:
		m.ClearEmail()
		return nil
	case orgunit.FieldTimezone:
		m.ClearTimezone()
		return nil
	case orgunit.FieldCountry:
		m.ClearCountry()
		return nil
	case orgunit.FieldLatitude:
		m.ClearLatitude()
		return nil
	case orgunit.FieldLongitude:
		m.ClearLongitude()
		return nil
	case orgunit.FieldStartAt:
		m.ClearStartAt()
		return nil
	case orgunit.FieldEndAt:
		m.ClearEndAt()
		return nil
	case orgunit.FieldContactUserID:
		m.ClearContactUserID()
		return nil
	case orgunit.FieldPermissionTags:
		m.ClearPermissionTags()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgUnitMutation) ResetField(name string) error {
	switch name {
	case orgunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgunit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orgunit.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgunit.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgunit.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case orgunit.FieldStatus:
		m.ResetStatus()
		return nil
	case orgunit.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case orgunit.FieldTenantID:
		m.ResetTenantID()
		return nil
	case orgunit.FieldRemark:
		m.ResetRemark()
		return nil
	case orgunit.FieldDescription:
		m.ResetDescription()
		return nil
	case orgunit.FieldParentID:
		m.ResetParentID()
		return nil
	case orgunit.FieldPath:
		m.ResetPath()
		return nil
	case orgunit.FieldName:
		m.ResetName()
		return nil
	case orgunit.FieldCode:
		m.ResetCode()
		return nil
	case orgunit.FieldLeaderID:
		m.ResetLeaderID()
		return nil
	case orgunit.FieldType:
		m.ResetType()
		return nil
	case orgunit.FieldBusinessScopes:
		m.ResetBusinessScopes()
		return nil
	case orgunit.FieldExternalID:
		m.ResetExternalID()
		return nil
	case orgunit.FieldIsLegalEntity:
		m.ResetIsLegalEntity()
		return nil
	case orgunit.FieldRegistrationNumber:
		m.ResetRegistrationNumber()
		return nil
	case orgunit.FieldTaxID:
		m.ResetTaxID()
		return nil
	case orgunit.FieldLegalEntityOrgID:
		m.ResetLegalEntityOrgID()
		return nil
	case orgunit.FieldAddress:
		m.ResetAddress()
		return nil
	case orgunit.FieldPhone:
		m.ResetPhone()
		return nil
	case orgunit.FieldEmail:
		m.ResetEmail()
		return nil
	case orgunit.FieldTimezone:
		m.ResetTimezone()
		return nil
	case orgunit.FieldCountry:
		m.ResetCountry()
		return nil
	case orgunit.FieldLatitude:
		m.ResetLatitude()
		return nil
	case orgunit.FieldLongitude:
		m.ResetLongitude()
		return nil
	case orgunit.FieldStartAt:
		m.ResetStartAt()
		return nil
	case orgunit.FieldEndAt:
		m.ResetEndAt()
		return nil
	case orgunit.FieldContactUserID:
		m.ResetContactUserID()
		return nil
	case orgunit.FieldPermissionTags:
		m.ResetPermissionTags()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, orgunit.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, orgunit.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgunit.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case orgunit.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildren != nil {
		edges = append(edges, orgunit.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgunit.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, orgunit.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, orgunit.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case orgunit.EdgeParent:
		return m.clearedparent
	case orgunit.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgUnitMutation) ClearEdge(name string) error {
	switch name {
	case orgunit.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgUnitMutation) ResetEdge(name string) error {
	switch name {
	case orgunit.EdgeParent:
		m.ResetParent()
		return nil
	case orgunit.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	updated_by    *uint32
	addupdated_by *int32
	deleted_by    *uint32
	adddeleted_by *int32
	status        *permission.Status
	description   *string
	name          *string
	code          *string
	group_id      *uint32
	addgroup_id   *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id uint32) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PermissionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[permission.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PermissionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, permission.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permission.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permission.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *PermissionMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PermissionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[permission.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PermissionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, permission.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *PermissionMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PermissionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[permission.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, permission.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PermissionMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PermissionMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *PermissionMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PermissionMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PermissionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[permission.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PermissionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PermissionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, permission.FieldDeletedBy)
}

// SetStatus sets the "status" field.
func (m *PermissionMutation) SetStatus(pe permission.Status) {
	m.status = &pe
}

// Status returns the value of the "status" field in the mutation.
func (m *PermissionMutation) Status() (r permission.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldStatus(ctx context.Context) (v *permission.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PermissionMutation) ResetStatus() {
	m.status = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *PermissionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PermissionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PermissionMutation) ResetCode() {
	m.code = nil
}

// SetGroupID sets the "group_id" field.
func (m *PermissionMutation) SetGroupID(u uint32) {
	m.group_id = &u
	m.addgroup_id = nil
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *PermissionMutation) GroupID() (r uint32, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldGroupID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// AddGroupID adds u to the "group_id" field.
func (m *PermissionMutation) AddGroupID(u int32) {
	if m.addgroup_id != nil {
		*m.addgroup_id += u
	} else {
		m.addgroup_id = &u
	}
}

// AddedGroupID returns the value that was added to the "group_id" field in this mutation.
func (m *PermissionMutation) AddedGroupID() (r int32, exists bool) {
	v := m.addgroup_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupID clears the value of the "group_id" field.
func (m *PermissionMutation) ClearGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
	m.clearedFields[permission.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *PermissionMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *PermissionMutation) ResetGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
	delete(m.clearedFields, permission.FieldGroupID)
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.status != nil {
		fields = append(fields, permission.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.code != nil {
		fields = append(fields, permission.FieldCode)
	}
	if m.group_id != nil {
		fields = append(fields, permission.FieldGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldDeletedAt:
		return m.DeletedAt()
	case permission.FieldCreatedBy:
		return m.CreatedBy()
	case permission.FieldUpdatedBy:
		return m.UpdatedBy()
	case permission.FieldDeletedBy:
		return m.DeletedBy()
	case permission.FieldStatus:
		return m.Status()
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldName:
		return m.Name()
	case permission.FieldCode:
		return m.Code()
	case permission.FieldGroupID:
		return m.GroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permission.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case permission.FieldStatus:
		return m.OldStatus(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldCode:
		return m.OldCode(ctx)
	case permission.FieldGroupID:
		return m.OldGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permission.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permission.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case permission.FieldStatus:
		v, ok := value.(permission.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case permission.FieldGroupID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.addgroup_id != nil {
		fields = append(fields, permission.FieldGroupID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case permission.FieldDeletedBy:
		return m.AddedDeletedBy()
	case permission.FieldGroupID:
		return m.AddedGroupID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case permission.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case permission.FieldGroupID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldCreatedAt) {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.FieldCleared(permission.FieldUpdatedAt) {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.FieldCleared(permission.FieldDeletedAt) {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.FieldCleared(permission.FieldCreatedBy) {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.FieldCleared(permission.FieldUpdatedBy) {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.FieldCleared(permission.FieldDeletedBy) {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	if m.FieldCleared(permission.FieldGroupID) {
		fields = append(fields, permission.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permission.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case permission.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case permission.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	case permission.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permission.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case permission.FieldStatus:
		m.ResetStatus()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldCode:
		m.ResetCode()
		return nil
	case permission.FieldGroupID:
		m.ResetGroupID()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Permission edge %s", name)
}

// PermissionApiMutation represents an operation that mutates the PermissionApi nodes in the graph.
type PermissionApiMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	permission_id    *uint32
	addpermission_id *int32
	api_id           *uint32
	addapi_id        *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*PermissionApi, error)
	predicates       []predicate.PermissionApi
}

var _ ent.Mutation = (*PermissionApiMutation)(nil)

// permissionapiOption allows management of the mutation configuration using functional options.
type permissionapiOption func(*PermissionApiMutation)

// newPermissionApiMutation creates new mutation for the PermissionApi entity.
func newPermissionApiMutation(c config, op Op, opts ...permissionapiOption) *PermissionApiMutation {
	m := &PermissionApiMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionApi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionApiID sets the ID field of the mutation.
func withPermissionApiID(id uint32) permissionapiOption {
	return func(m *PermissionApiMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionApi
		)
		m.oldValue = func(ctx context.Context) (*PermissionApi, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionApi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionApi sets the old PermissionApi of the mutation.
func withPermissionApi(node *PermissionApi) permissionapiOption {
	return func(m *PermissionApiMutation) {
		m.oldValue = func(context.Context) (*PermissionApi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionApiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionApiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionApi entities.
func (m *PermissionApiMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionApiMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionApiMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionApi.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionApiMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionApiMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PermissionApiMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[permissionapi.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PermissionApiMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[permissionapi.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionApiMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, permissionapi.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionApiMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionApiMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionApiMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permissionapi.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionApiMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permissionapi.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionApiMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permissionapi.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionApiMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionApiMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionApiMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permissionapi.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionApiMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permissionapi.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionApiMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permissionapi.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionApiMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionApiMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *PermissionApiMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionApiMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PermissionApiMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[permissionapi.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PermissionApiMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[permissionapi.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionApiMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, permissionapi.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionApiMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionApiMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *PermissionApiMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionApiMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PermissionApiMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[permissionapi.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PermissionApiMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[permissionapi.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionApiMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, permissionapi.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PermissionApiMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PermissionApiMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *PermissionApiMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PermissionApiMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PermissionApiMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[permissionapi.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PermissionApiMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[permissionapi.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PermissionApiMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, permissionapi.FieldDeletedBy)
}

// SetPermissionID sets the "permission_id" field.
func (m *PermissionApiMutation) SetPermissionID(u uint32) {
	m.permission_id = &u
	m.addpermission_id = nil
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *PermissionApiMutation) PermissionID() (r uint32, exists bool) {
	v := m.permission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldPermissionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// AddPermissionID adds u to the "permission_id" field.
func (m *PermissionApiMutation) AddPermissionID(u int32) {
	if m.addpermission_id != nil {
		*m.addpermission_id += u
	} else {
		m.addpermission_id = &u
	}
}

// AddedPermissionID returns the value that was added to the "permission_id" field in this mutation.
func (m *PermissionApiMutation) AddedPermissionID() (r int32, exists bool) {
	v := m.addpermission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *PermissionApiMutation) ResetPermissionID() {
	m.permission_id = nil
	m.addpermission_id = nil
}

// SetAPIID sets the "api_id" field.
func (m *PermissionApiMutation) SetAPIID(u uint32) {
	m.api_id = &u
	m.addapi_id = nil
}

// APIID returns the value of the "api_id" field in the mutation.
func (m *PermissionApiMutation) APIID() (r uint32, exists bool) {
	v := m.api_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIID returns the old "api_id" field's value of the PermissionApi entity.
// If the PermissionApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionApiMutation) OldAPIID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIID: %w", err)
	}
	return oldValue.APIID, nil
}

// AddAPIID adds u to the "api_id" field.
func (m *PermissionApiMutation) AddAPIID(u int32) {
	if m.addapi_id != nil {
		*m.addapi_id += u
	} else {
		m.addapi_id = &u
	}
}

// AddedAPIID returns the value that was added to the "api_id" field in this mutation.
func (m *PermissionApiMutation) AddedAPIID() (r int32, exists bool) {
	v := m.addapi_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAPIID resets all changes to the "api_id" field.
func (m *PermissionApiMutation) ResetAPIID() {
	m.api_id = nil
	m.addapi_id = nil
}

// Where appends a list predicates to the PermissionApiMutation builder.
func (m *PermissionApiMutation) Where(ps ...predicate.PermissionApi) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionApiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionApiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionApi, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionApiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionApiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionApi).
func (m *PermissionApiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionApiMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, permissionapi.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permissionapi.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permissionapi.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, permissionapi.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, permissionapi.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, permissionapi.FieldDeletedBy)
	}
	if m.permission_id != nil {
		fields = append(fields, permissionapi.FieldPermissionID)
	}
	if m.api_id != nil {
		fields = append(fields, permissionapi.FieldAPIID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionApiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionapi.FieldCreatedAt:
		return m.CreatedAt()
	case permissionapi.FieldUpdatedAt:
		return m.UpdatedAt()
	case permissionapi.FieldDeletedAt:
		return m.DeletedAt()
	case permissionapi.FieldCreatedBy:
		return m.CreatedBy()
	case permissionapi.FieldUpdatedBy:
		return m.UpdatedBy()
	case permissionapi.FieldDeletedBy:
		return m.DeletedBy()
	case permissionapi.FieldPermissionID:
		return m.PermissionID()
	case permissionapi.FieldAPIID:
		return m.APIID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionApiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionapi.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissionapi.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permissionapi.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permissionapi.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permissionapi.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permissionapi.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case permissionapi.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case permissionapi.FieldAPIID:
		return m.OldAPIID(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionApi field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionApiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionapi.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissionapi.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permissionapi.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permissionapi.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permissionapi.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permissionapi.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case permissionapi.FieldPermissionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case permissionapi.FieldAPIID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionApi field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionApiMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permissionapi.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permissionapi.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, permissionapi.FieldDeletedBy)
	}
	if m.addpermission_id != nil {
		fields = append(fields, permissionapi.FieldPermissionID)
	}
	if m.addapi_id != nil {
		fields = append(fields, permissionapi.FieldAPIID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionApiMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissionapi.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permissionapi.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case permissionapi.FieldDeletedBy:
		return m.AddedDeletedBy()
	case permissionapi.FieldPermissionID:
		return m.AddedPermissionID()
	case permissionapi.FieldAPIID:
		return m.AddedAPIID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionApiMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissionapi.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permissionapi.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case permissionapi.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case permissionapi.FieldPermissionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPermissionID(v)
		return nil
	case permissionapi.FieldAPIID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAPIID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionApi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionApiMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissionapi.FieldCreatedAt) {
		fields = append(fields, permissionapi.FieldCreatedAt)
	}
	if m.FieldCleared(permissionapi.FieldUpdatedAt) {
		fields = append(fields, permissionapi.FieldUpdatedAt)
	}
	if m.FieldCleared(permissionapi.FieldDeletedAt) {
		fields = append(fields, permissionapi.FieldDeletedAt)
	}
	if m.FieldCleared(permissionapi.FieldCreatedBy) {
		fields = append(fields, permissionapi.FieldCreatedBy)
	}
	if m.FieldCleared(permissionapi.FieldUpdatedBy) {
		fields = append(fields, permissionapi.FieldUpdatedBy)
	}
	if m.FieldCleared(permissionapi.FieldDeletedBy) {
		fields = append(fields, permissionapi.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionApiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionApiMutation) ClearField(name string) error {
	switch name {
	case permissionapi.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case permissionapi.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permissionapi.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permissionapi.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case permissionapi.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case permissionapi.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown PermissionApi nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionApiMutation) ResetField(name string) error {
	switch name {
	case permissionapi.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissionapi.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permissionapi.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permissionapi.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permissionapi.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permissionapi.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case permissionapi.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case permissionapi.FieldAPIID:
		m.ResetAPIID()
		return nil
	}
	return fmt.Errorf("unknown PermissionApi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionApiMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionApiMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionApiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionApiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionApiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionApiMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionApiMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionApi unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionApiMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionApi edge %s", name)
}

// PermissionAuditLogMutation represents an operation that mutates the PermissionAuditLog nodes in the graph.
type PermissionAuditLogMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	tenant_id      *uint32
	addtenant_id   *int32
	operator_id    *uint32
	addoperator_id *int32
	target_type    *string
	target_id      *string
	action         *permissionauditlog.Action
	old_value      *string
	new_value      *string
	ip_address     *string
	request_id     *string
	reason         *string
	log_hash       *string
	signature      *[]byte
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*PermissionAuditLog, error)
	predicates     []predicate.PermissionAuditLog
}

var _ ent.Mutation = (*PermissionAuditLogMutation)(nil)

// permissionauditlogOption allows management of the mutation configuration using functional options.
type permissionauditlogOption func(*PermissionAuditLogMutation)

// newPermissionAuditLogMutation creates new mutation for the PermissionAuditLog entity.
func newPermissionAuditLogMutation(c config, op Op, opts ...permissionauditlogOption) *PermissionAuditLogMutation {
	m := &PermissionAuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionAuditLogID sets the ID field of the mutation.
func withPermissionAuditLogID(id uint32) permissionauditlogOption {
	return func(m *PermissionAuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionAuditLog
		)
		m.oldValue = func(ctx context.Context) (*PermissionAuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionAuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionAuditLog sets the old PermissionAuditLog of the mutation.
func withPermissionAuditLog(node *PermissionAuditLog) permissionauditlogOption {
	return func(m *PermissionAuditLogMutation) {
		m.oldValue = func(context.Context) (*PermissionAuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionAuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionAuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionAuditLog entities.
func (m *PermissionAuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionAuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionAuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionAuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionAuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionAuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PermissionAuditLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[permissionauditlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionAuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, permissionauditlog.FieldCreatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *PermissionAuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PermissionAuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *PermissionAuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *PermissionAuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PermissionAuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[permissionauditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PermissionAuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, permissionauditlog.FieldTenantID)
}

// SetOperatorID sets the "operator_id" field.
func (m *PermissionAuditLogMutation) SetOperatorID(u uint32) {
	m.operator_id = &u
	m.addoperator_id = nil
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *PermissionAuditLogMutation) OperatorID() (r uint32, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldOperatorID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// AddOperatorID adds u to the "operator_id" field.
func (m *PermissionAuditLogMutation) AddOperatorID(u int32) {
	if m.addoperator_id != nil {
		*m.addoperator_id += u
	} else {
		m.addoperator_id = &u
	}
}

// AddedOperatorID returns the value that was added to the "operator_id" field in this mutation.
func (m *PermissionAuditLogMutation) AddedOperatorID() (r int32, exists bool) {
	v := m.addoperator_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOperatorID clears the value of the "operator_id" field.
func (m *PermissionAuditLogMutation) ClearOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	m.clearedFields[permissionauditlog.FieldOperatorID] = struct{}{}
}

// OperatorIDCleared returns if the "operator_id" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) OperatorIDCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldOperatorID]
	return ok
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *PermissionAuditLogMutation) ResetOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	delete(m.clearedFields, permissionauditlog.FieldOperatorID)
}

// SetTargetType sets the "target_type" field.
func (m *PermissionAuditLogMutation) SetTargetType(s string) {
	m.target_type = &s
}

// TargetType returns the value of the "target_type" field in the mutation.
func (m *PermissionAuditLogMutation) TargetType() (r string, exists bool) {
	v := m.target_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetType returns the old "target_type" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldTargetType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetType: %w", err)
	}
	return oldValue.TargetType, nil
}

// ClearTargetType clears the value of the "target_type" field.
func (m *PermissionAuditLogMutation) ClearTargetType() {
	m.target_type = nil
	m.clearedFields[permissionauditlog.FieldTargetType] = struct{}{}
}

// TargetTypeCleared returns if the "target_type" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) TargetTypeCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldTargetType]
	return ok
}

// ResetTargetType resets all changes to the "target_type" field.
func (m *PermissionAuditLogMutation) ResetTargetType() {
	m.target_type = nil
	delete(m.clearedFields, permissionauditlog.FieldTargetType)
}

// SetTargetID sets the "target_id" field.
func (m *PermissionAuditLogMutation) SetTargetID(s string) {
	m.target_id = &s
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *PermissionAuditLogMutation) TargetID() (r string, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldTargetID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// ClearTargetID clears the value of the "target_id" field.
func (m *PermissionAuditLogMutation) ClearTargetID() {
	m.target_id = nil
	m.clearedFields[permissionauditlog.FieldTargetID] = struct{}{}
}

// TargetIDCleared returns if the "target_id" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) TargetIDCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldTargetID]
	return ok
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *PermissionAuditLogMutation) ResetTargetID() {
	m.target_id = nil
	delete(m.clearedFields, permissionauditlog.FieldTargetID)
}

// SetAction sets the "action" field.
func (m *PermissionAuditLogMutation) SetAction(pe permissionauditlog.Action) {
	m.action = &pe
}

// Action returns the value of the "action" field in the mutation.
func (m *PermissionAuditLogMutation) Action() (r permissionauditlog.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldAction(ctx context.Context) (v *permissionauditlog.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *PermissionAuditLogMutation) ClearAction() {
	m.action = nil
	m.clearedFields[permissionauditlog.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) ActionCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *PermissionAuditLogMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, permissionauditlog.FieldAction)
}

// SetOldValue sets the "old_value" field.
func (m *PermissionAuditLogMutation) SetOldValue(s string) {
	m.old_value = &s
}

// OldValue returns the value of the "old_value" field in the mutation.
func (m *PermissionAuditLogMutation) OldValue() (r string, exists bool) {
	v := m.old_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOldValue returns the old "old_value" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldOldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldValue: %w", err)
	}
	return oldValue.OldValue, nil
}

// ClearOldValue clears the value of the "old_value" field.
func (m *PermissionAuditLogMutation) ClearOldValue() {
	m.old_value = nil
	m.clearedFields[permissionauditlog.FieldOldValue] = struct{}{}
}

// OldValueCleared returns if the "old_value" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) OldValueCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldOldValue]
	return ok
}

// ResetOldValue resets all changes to the "old_value" field.
func (m *PermissionAuditLogMutation) ResetOldValue() {
	m.old_value = nil
	delete(m.clearedFields, permissionauditlog.FieldOldValue)
}

// SetNewValue sets the "new_value" field.
func (m *PermissionAuditLogMutation) SetNewValue(s string) {
	m.new_value = &s
}

// NewValue returns the value of the "new_value" field in the mutation.
func (m *PermissionAuditLogMutation) NewValue() (r string, exists bool) {
	v := m.new_value
	if v == nil {
		return
	}
	return *v, true
}

// OldNewValue returns the old "new_value" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldNewValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewValue: %w", err)
	}
	return oldValue.NewValue, nil
}

// ClearNewValue clears the value of the "new_value" field.
func (m *PermissionAuditLogMutation) ClearNewValue() {
	m.new_value = nil
	m.clearedFields[permissionauditlog.FieldNewValue] = struct{}{}
}

// NewValueCleared returns if the "new_value" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) NewValueCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldNewValue]
	return ok
}

// ResetNewValue resets all changes to the "new_value" field.
func (m *PermissionAuditLogMutation) ResetNewValue() {
	m.new_value = nil
	delete(m.clearedFields, permissionauditlog.FieldNewValue)
}

// SetIPAddress sets the "ip_address" field.
func (m *PermissionAuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *PermissionAuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *PermissionAuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetRequestID sets the "request_id" field.
func (m *PermissionAuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *PermissionAuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *PermissionAuditLogMutation) ResetRequestID() {
	m.request_id = nil
}

// SetReason sets the "reason" field.
func (m *PermissionAuditLogMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *PermissionAuditLogMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *PermissionAuditLogMutation) ResetReason() {
	m.reason = nil
}

// SetLogHash sets the "log_hash" field.
func (m *PermissionAuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *PermissionAuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldLogHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *PermissionAuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[permissionauditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *PermissionAuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, permissionauditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *PermissionAuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *PermissionAuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the PermissionAuditLog entity.
// If the PermissionAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionAuditLogMutation) OldSignature(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *PermissionAuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[permissionauditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *PermissionAuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[permissionauditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *PermissionAuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, permissionauditlog.FieldSignature)
}

// Where appends a list predicates to the PermissionAuditLogMutation builder.
func (m *PermissionAuditLogMutation) Where(ps ...predicate.PermissionAuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionAuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionAuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionAuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionAuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionAuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionAuditLog).
func (m *PermissionAuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionAuditLogMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, permissionauditlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, permissionauditlog.FieldTenantID)
	}
	if m.operator_id != nil {
		fields = append(fields, permissionauditlog.FieldOperatorID)
	}
	if m.target_type != nil {
		fields = append(fields, permissionauditlog.FieldTargetType)
	}
	if m.target_id != nil {
		fields = append(fields, permissionauditlog.FieldTargetID)
	}
	if m.action != nil {
		fields = append(fields, permissionauditlog.FieldAction)
	}
	if m.old_value != nil {
		fields = append(fields, permissionauditlog.FieldOldValue)
	}
	if m.new_value != nil {
		fields = append(fields, permissionauditlog.FieldNewValue)
	}
	if m.ip_address != nil {
		fields = append(fields, permissionauditlog.FieldIPAddress)
	}
	if m.request_id != nil {
		fields = append(fields, permissionauditlog.FieldRequestID)
	}
	if m.reason != nil {
		fields = append(fields, permissionauditlog.FieldReason)
	}
	if m.log_hash != nil {
		fields = append(fields, permissionauditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, permissionauditlog.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionAuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionauditlog.FieldCreatedAt:
		return m.CreatedAt()
	case permissionauditlog.FieldTenantID:
		return m.TenantID()
	case permissionauditlog.FieldOperatorID:
		return m.OperatorID()
	case permissionauditlog.FieldTargetType:
		return m.TargetType()
	case permissionauditlog.FieldTargetID:
		return m.TargetID()
	case permissionauditlog.FieldAction:
		return m.Action()
	case permissionauditlog.FieldOldValue:
		return m.OldValue()
	case permissionauditlog.FieldNewValue:
		return m.NewValue()
	case permissionauditlog.FieldIPAddress:
		return m.IPAddress()
	case permissionauditlog.FieldRequestID:
		return m.RequestID()
	case permissionauditlog.FieldReason:
		return m.Reason()
	case permissionauditlog.FieldLogHash:
		return m.LogHash()
	case permissionauditlog.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionAuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionauditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissionauditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case permissionauditlog.FieldOperatorID:
		return m.OldOperatorID(ctx)
	case permissionauditlog.FieldTargetType:
		return m.OldTargetType(ctx)
	case permissionauditlog.FieldTargetID:
		return m.OldTargetID(ctx)
	case permissionauditlog.FieldAction:
		return m.OldAction(ctx)
	case permissionauditlog.FieldOldValue:
		return m.OldOldValue(ctx)
	case permissionauditlog.FieldNewValue:
		return m.OldNewValue(ctx)
	case permissionauditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case permissionauditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case permissionauditlog.FieldReason:
		return m.OldReason(ctx)
	case permissionauditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case permissionauditlog.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionAuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionAuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionauditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissionauditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case permissionauditlog.FieldOperatorID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	case permissionauditlog.FieldTargetType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetType(v)
		return nil
	case permissionauditlog.FieldTargetID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case permissionauditlog.FieldAction:
		v, ok := value.(permissionauditlog.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case permissionauditlog.FieldOldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldValue(v)
		return nil
	case permissionauditlog.FieldNewValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewValue(v)
		return nil
	case permissionauditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case permissionauditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case permissionauditlog.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case permissionauditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case permissionauditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionAuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionAuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, permissionauditlog.FieldTenantID)
	}
	if m.addoperator_id != nil {
		fields = append(fields, permissionauditlog.FieldOperatorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionAuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissionauditlog.FieldTenantID:
		return m.AddedTenantID()
	case permissionauditlog.FieldOperatorID:
		return m.AddedOperatorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionAuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissionauditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case permissionauditlog.FieldOperatorID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionAuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionAuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissionauditlog.FieldCreatedAt) {
		fields = append(fields, permissionauditlog.FieldCreatedAt)
	}
	if m.FieldCleared(permissionauditlog.FieldTenantID) {
		fields = append(fields, permissionauditlog.FieldTenantID)
	}
	if m.FieldCleared(permissionauditlog.FieldOperatorID) {
		fields = append(fields, permissionauditlog.FieldOperatorID)
	}
	if m.FieldCleared(permissionauditlog.FieldTargetType) {
		fields = append(fields, permissionauditlog.FieldTargetType)
	}
	if m.FieldCleared(permissionauditlog.FieldTargetID) {
		fields = append(fields, permissionauditlog.FieldTargetID)
	}
	if m.FieldCleared(permissionauditlog.FieldAction) {
		fields = append(fields, permissionauditlog.FieldAction)
	}
	if m.FieldCleared(permissionauditlog.FieldOldValue) {
		fields = append(fields, permissionauditlog.FieldOldValue)
	}
	if m.FieldCleared(permissionauditlog.FieldNewValue) {
		fields = append(fields, permissionauditlog.FieldNewValue)
	}
	if m.FieldCleared(permissionauditlog.FieldLogHash) {
		fields = append(fields, permissionauditlog.FieldLogHash)
	}
	if m.FieldCleared(permissionauditlog.FieldSignature) {
		fields = append(fields, permissionauditlog.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionAuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionAuditLogMutation) ClearField(name string) error {
	switch name {
	case permissionauditlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case permissionauditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case permissionauditlog.FieldOperatorID:
		m.ClearOperatorID()
		return nil
	case permissionauditlog.FieldTargetType:
		m.ClearTargetType()
		return nil
	case permissionauditlog.FieldTargetID:
		m.ClearTargetID()
		return nil
	case permissionauditlog.FieldAction:
		m.ClearAction()
		return nil
	case permissionauditlog.FieldOldValue:
		m.ClearOldValue()
		return nil
	case permissionauditlog.FieldNewValue:
		m.ClearNewValue()
		return nil
	case permissionauditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case permissionauditlog.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown PermissionAuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionAuditLogMutation) ResetField(name string) error {
	switch name {
	case permissionauditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissionauditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case permissionauditlog.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	case permissionauditlog.FieldTargetType:
		m.ResetTargetType()
		return nil
	case permissionauditlog.FieldTargetID:
		m.ResetTargetID()
		return nil
	case permissionauditlog.FieldAction:
		m.ResetAction()
		return nil
	case permissionauditlog.FieldOldValue:
		m.ResetOldValue()
		return nil
	case permissionauditlog.FieldNewValue:
		m.ResetNewValue()
		return nil
	case permissionauditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case permissionauditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case permissionauditlog.FieldReason:
		m.ResetReason()
		return nil
	case permissionauditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case permissionauditlog.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown PermissionAuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionAuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionAuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionAuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionAuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionAuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionAuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionAuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionAuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionAuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionAuditLog edge %s", name)
}

// PermissionGroupMutation represents an operation that mutates the PermissionGroup nodes in the graph.
type PermissionGroupMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	created_by      *uint32
	addcreated_by   *int32
	updated_by      *uint32
	addupdated_by   *int32
	deleted_by      *uint32
	adddeleted_by   *int32
	description     *string
	status          *permissiongroup.Status
	sort_order      *uint32
	addsort_order   *int32
	_path           *string
	name            *string
	module          *string
	clearedFields   map[string]struct{}
	parent          *uint32
	clearedparent   bool
	children        map[uint32]struct{}
	removedchildren map[uint32]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*PermissionGroup, error)
	predicates      []predicate.PermissionGroup
}

var _ ent.Mutation = (*PermissionGroupMutation)(nil)

// permissiongroupOption allows management of the mutation configuration using functional options.
type permissiongroupOption func(*PermissionGroupMutation)

// newPermissionGroupMutation creates new mutation for the PermissionGroup entity.
func newPermissionGroupMutation(c config, op Op, opts ...permissiongroupOption) *PermissionGroupMutation {
	m := &PermissionGroupMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionGroupID sets the ID field of the mutation.
func withPermissionGroupID(id uint32) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionGroup
		)
		m.oldValue = func(ctx context.Context) (*PermissionGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionGroup sets the old PermissionGroup of the mutation.
func withPermissionGroup(node *PermissionGroup) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		m.oldValue = func(context.Context) (*PermissionGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionGroup entities.
func (m *PermissionGroupMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionGroupMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionGroupMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PermissionGroupMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[permissiongroup.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PermissionGroupMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionGroupMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, permissiongroup.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionGroupMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permissiongroup.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionGroupMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permissiongroup.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionGroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionGroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionGroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permissiongroup.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionGroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionGroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permissiongroup.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionGroupMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionGroupMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *PermissionGroupMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionGroupMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PermissionGroupMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[permissiongroup.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PermissionGroupMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionGroupMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, permissiongroup.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionGroupMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionGroupMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *PermissionGroupMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionGroupMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PermissionGroupMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[permissiongroup.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PermissionGroupMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionGroupMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, permissiongroup.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PermissionGroupMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PermissionGroupMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *PermissionGroupMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PermissionGroupMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PermissionGroupMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[permissiongroup.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PermissionGroupMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PermissionGroupMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, permissiongroup.FieldDeletedBy)
}

// SetDescription sets the "description" field.
func (m *PermissionGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permissiongroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permissiongroup.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *PermissionGroupMutation) SetStatus(pe permissiongroup.Status) {
	m.status = &pe
}

// Status returns the value of the "status" field in the mutation.
func (m *PermissionGroupMutation) Status() (r permissiongroup.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldStatus(ctx context.Context) (v *permissiongroup.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PermissionGroupMutation) ResetStatus() {
	m.status = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *PermissionGroupMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *PermissionGroupMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *PermissionGroupMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *PermissionGroupMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *PermissionGroupMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[permissiongroup.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *PermissionGroupMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *PermissionGroupMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, permissiongroup.FieldSortOrder)
}

// SetParentID sets the "parent_id" field.
func (m *PermissionGroupMutation) SetParentID(u uint32) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *PermissionGroupMutation) ParentID() (r uint32, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *PermissionGroupMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[permissiongroup.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *PermissionGroupMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *PermissionGroupMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, permissiongroup.FieldParentID)
}

// SetPath sets the "path" field.
func (m *PermissionGroupMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *PermissionGroupMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *PermissionGroupMutation) ClearPath() {
	m._path = nil
	m.clearedFields[permissiongroup.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *PermissionGroupMutation) PathCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *PermissionGroupMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, permissiongroup.FieldPath)
}

// SetName sets the "name" field.
func (m *PermissionGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionGroupMutation) ResetName() {
	m.name = nil
}

// SetModule sets the "module" field.
func (m *PermissionGroupMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *PermissionGroupMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldModule(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ClearModule clears the value of the "module" field.
func (m *PermissionGroupMutation) ClearModule() {
	m.module = nil
	m.clearedFields[permissiongroup.FieldModule] = struct{}{}
}

// ModuleCleared returns if the "module" field was cleared in this mutation.
func (m *PermissionGroupMutation) ModuleCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldModule]
	return ok
}

// ResetModule resets all changes to the "module" field.
func (m *PermissionGroupMutation) ResetModule() {
	m.module = nil
	delete(m.clearedFields, permissiongroup.FieldModule)
}

// ClearParent clears the "parent" edge to the PermissionGroup entity.
func (m *PermissionGroupMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[permissiongroup.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the PermissionGroup entity was cleared.
func (m *PermissionGroupMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *PermissionGroupMutation) ParentIDs() (ids []uint32) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *PermissionGroupMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the PermissionGroup entity by ids.
func (m *PermissionGroupMutation) AddChildIDs(ids ...uint32) {
	if m.children == nil {
		m.children = make(map[uint32]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the PermissionGroup entity.
func (m *PermissionGroupMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the PermissionGroup entity was cleared.
func (m *PermissionGroupMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the PermissionGroup entity by IDs.
func (m *PermissionGroupMutation) RemoveChildIDs(ids ...uint32) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the PermissionGroup entity.
func (m *PermissionGroupMutation) RemovedChildrenIDs() (ids []uint32) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *PermissionGroupMutation) ChildrenIDs() (ids []uint32) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *PermissionGroupMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the PermissionGroupMutation builder.
func (m *PermissionGroupMutation) Where(ps ...predicate.PermissionGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionGroup).
func (m *PermissionGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionGroupMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, permissiongroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permissiongroup.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permissiongroup.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, permissiongroup.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, permissiongroup.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, permissiongroup.FieldDeletedBy)
	}
	if m.description != nil {
		fields = append(fields, permissiongroup.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, permissiongroup.FieldStatus)
	}
	if m.sort_order != nil {
		fields = append(fields, permissiongroup.FieldSortOrder)
	}
	if m.parent != nil {
		fields = append(fields, permissiongroup.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, permissiongroup.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, permissiongroup.FieldName)
	}
	if m.module != nil {
		fields = append(fields, permissiongroup.FieldModule)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldCreatedAt:
		return m.CreatedAt()
	case permissiongroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case permissiongroup.FieldDeletedAt:
		return m.DeletedAt()
	case permissiongroup.FieldCreatedBy:
		return m.CreatedBy()
	case permissiongroup.FieldUpdatedBy:
		return m.UpdatedBy()
	case permissiongroup.FieldDeletedBy:
		return m.DeletedBy()
	case permissiongroup.FieldDescription:
		return m.Description()
	case permissiongroup.FieldStatus:
		return m.Status()
	case permissiongroup.FieldSortOrder:
		return m.SortOrder()
	case permissiongroup.FieldParentID:
		return m.ParentID()
	case permissiongroup.FieldPath:
		return m.Path()
	case permissiongroup.FieldName:
		return m.Name()
	case permissiongroup.FieldModule:
		return m.Module()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissiongroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissiongroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permissiongroup.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permissiongroup.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permissiongroup.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permissiongroup.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case permissiongroup.FieldDescription:
		return m.OldDescription(ctx)
	case permissiongroup.FieldStatus:
		return m.OldStatus(ctx)
	case permissiongroup.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case permissiongroup.FieldParentID:
		return m.OldParentID(ctx)
	case permissiongroup.FieldPath:
		return m.OldPath(ctx)
	case permissiongroup.FieldName:
		return m.OldName(ctx)
	case permissiongroup.FieldModule:
		return m.OldModule(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissiongroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permissiongroup.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permissiongroup.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permissiongroup.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permissiongroup.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case permissiongroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permissiongroup.FieldStatus:
		v, ok := value.(permissiongroup.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case permissiongroup.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case permissiongroup.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case permissiongroup.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case permissiongroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permissiongroup.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionGroupMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permissiongroup.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permissiongroup.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, permissiongroup.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, permissiongroup.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permissiongroup.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case permissiongroup.FieldDeletedBy:
		return m.AddedDeletedBy()
	case permissiongroup.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permissiongroup.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case permissiongroup.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case permissiongroup.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissiongroup.FieldCreatedAt) {
		fields = append(fields, permissiongroup.FieldCreatedAt)
	}
	if m.FieldCleared(permissiongroup.FieldUpdatedAt) {
		fields = append(fields, permissiongroup.FieldUpdatedAt)
	}
	if m.FieldCleared(permissiongroup.FieldDeletedAt) {
		fields = append(fields, permissiongroup.FieldDeletedAt)
	}
	if m.FieldCleared(permissiongroup.FieldCreatedBy) {
		fields = append(fields, permissiongroup.FieldCreatedBy)
	}
	if m.FieldCleared(permissiongroup.FieldUpdatedBy) {
		fields = append(fields, permissiongroup.FieldUpdatedBy)
	}
	if m.FieldCleared(permissiongroup.FieldDeletedBy) {
		fields = append(fields, permissiongroup.FieldDeletedBy)
	}
	if m.FieldCleared(permissiongroup.FieldDescription) {
		fields = append(fields, permissiongroup.FieldDescription)
	}
	if m.FieldCleared(permissiongroup.FieldSortOrder) {
		fields = append(fields, permissiongroup.FieldSortOrder)
	}
	if m.FieldCleared(permissiongroup.FieldParentID) {
		fields = append(fields, permissiongroup.FieldParentID)
	}
	if m.FieldCleared(permissiongroup.FieldPath) {
		fields = append(fields, permissiongroup.FieldPath)
	}
	if m.FieldCleared(permissiongroup.FieldModule) {
		fields = append(fields, permissiongroup.FieldModule)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ClearField(name string) error {
	switch name {
	case permissiongroup.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case permissiongroup.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permissiongroup.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permissiongroup.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case permissiongroup.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case permissiongroup.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case permissiongroup.FieldDescription:
		m.ClearDescription()
		return nil
	case permissiongroup.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case permissiongroup.FieldParentID:
		m.ClearParentID()
		return nil
	case permissiongroup.FieldPath:
		m.ClearPath()
		return nil
	case permissiongroup.FieldModule:
		m.ClearModule()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ResetField(name string) error {
	switch name {
	case permissiongroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissiongroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permissiongroup.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permissiongroup.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permissiongroup.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permissiongroup.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case permissiongroup.FieldDescription:
		m.ResetDescription()
		return nil
	case permissiongroup.FieldStatus:
		m.ResetStatus()
		return nil
	case permissiongroup.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case permissiongroup.FieldParentID:
		m.ResetParentID()
		return nil
	case permissiongroup.FieldPath:
		m.ResetPath()
		return nil
	case permissiongroup.FieldName:
		m.ResetName()
		return nil
	case permissiongroup.FieldModule:
		m.ResetModule()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, permissiongroup.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, permissiongroup.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permissiongroup.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case permissiongroup.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildren != nil {
		edges = append(edges, permissiongroup.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permissiongroup.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, permissiongroup.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, permissiongroup.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case permissiongroup.EdgeParent:
		return m.clearedparent
	case permissiongroup.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionGroupMutation) ClearEdge(name string) error {
	switch name {
	case permissiongroup.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionGroupMutation) ResetEdge(name string) error {
	switch name {
	case permissiongroup.EdgeParent:
		m.ResetParent()
		return nil
	case permissiongroup.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup edge %s", name)
}

// PermissionMenuMutation represents an operation that mutates the PermissionMenu nodes in the graph.
type PermissionMenuMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	permission_id    *uint32
	addpermission_id *int32
	menu_id          *uint32
	addmenu_id       *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*PermissionMenu, error)
	predicates       []predicate.PermissionMenu
}

var _ ent.Mutation = (*PermissionMenuMutation)(nil)

// permissionmenuOption allows management of the mutation configuration using functional options.
type permissionmenuOption func(*PermissionMenuMutation)

// newPermissionMenuMutation creates new mutation for the PermissionMenu entity.
func newPermissionMenuMutation(c config, op Op, opts ...permissionmenuOption) *PermissionMenuMutation {
	m := &PermissionMenuMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionMenuID sets the ID field of the mutation.
func withPermissionMenuID(id uint32) permissionmenuOption {
	return func(m *PermissionMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionMenu
		)
		m.oldValue = func(ctx context.Context) (*PermissionMenu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionMenu sets the old PermissionMenu of the mutation.
func withPermissionMenu(node *PermissionMenu) permissionmenuOption {
	return func(m *PermissionMenuMutation) {
		m.oldValue = func(context.Context) (*PermissionMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionMenu entities.
func (m *PermissionMenuMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMenuMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMenuMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionMenu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PermissionMenuMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[permissionmenu.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PermissionMenuMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[permissionmenu.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMenuMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, permissionmenu.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionMenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permissionmenu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionMenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permissionmenu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permissionmenu.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMenuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMenuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMenuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permissionmenu.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMenuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permissionmenu.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMenuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permissionmenu.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionMenuMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionMenuMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *PermissionMenuMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionMenuMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PermissionMenuMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[permissionmenu.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PermissionMenuMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[permissionmenu.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionMenuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, permissionmenu.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionMenuMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionMenuMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *PermissionMenuMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionMenuMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PermissionMenuMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[permissionmenu.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PermissionMenuMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[permissionmenu.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionMenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, permissionmenu.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PermissionMenuMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PermissionMenuMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *PermissionMenuMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PermissionMenuMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PermissionMenuMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[permissionmenu.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PermissionMenuMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[permissionmenu.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PermissionMenuMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, permissionmenu.FieldDeletedBy)
}

// SetPermissionID sets the "permission_id" field.
func (m *PermissionMenuMutation) SetPermissionID(u uint32) {
	m.permission_id = &u
	m.addpermission_id = nil
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *PermissionMenuMutation) PermissionID() (r uint32, exists bool) {
	v := m.permission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldPermissionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// AddPermissionID adds u to the "permission_id" field.
func (m *PermissionMenuMutation) AddPermissionID(u int32) {
	if m.addpermission_id != nil {
		*m.addpermission_id += u
	} else {
		m.addpermission_id = &u
	}
}

// AddedPermissionID returns the value that was added to the "permission_id" field in this mutation.
func (m *PermissionMenuMutation) AddedPermissionID() (r int32, exists bool) {
	v := m.addpermission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *PermissionMenuMutation) ResetPermissionID() {
	m.permission_id = nil
	m.addpermission_id = nil
}

// SetMenuID sets the "menu_id" field.
func (m *PermissionMenuMutation) SetMenuID(u uint32) {
	m.menu_id = &u
	m.addmenu_id = nil
}

// MenuID returns the value of the "menu_id" field in the mutation.
func (m *PermissionMenuMutation) MenuID() (r uint32, exists bool) {
	v := m.menu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old "menu_id" field's value of the PermissionMenu entity.
// If the PermissionMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMenuMutation) OldMenuID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// AddMenuID adds u to the "menu_id" field.
func (m *PermissionMenuMutation) AddMenuID(u int32) {
	if m.addmenu_id != nil {
		*m.addmenu_id += u
	} else {
		m.addmenu_id = &u
	}
}

// AddedMenuID returns the value that was added to the "menu_id" field in this mutation.
func (m *PermissionMenuMutation) AddedMenuID() (r int32, exists bool) {
	v := m.addmenu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuID resets all changes to the "menu_id" field.
func (m *PermissionMenuMutation) ResetMenuID() {
	m.menu_id = nil
	m.addmenu_id = nil
}

// Where appends a list predicates to the PermissionMenuMutation builder.
func (m *PermissionMenuMutation) Where(ps ...predicate.PermissionMenu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionMenu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionMenu).
func (m *PermissionMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMenuMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, permissionmenu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permissionmenu.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permissionmenu.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, permissionmenu.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, permissionmenu.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, permissionmenu.FieldDeletedBy)
	}
	if m.permission_id != nil {
		fields = append(fields, permissionmenu.FieldPermissionID)
	}
	if m.menu_id != nil {
		fields = append(fields, permissionmenu.FieldMenuID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionmenu.FieldCreatedAt:
		return m.CreatedAt()
	case permissionmenu.FieldUpdatedAt:
		return m.UpdatedAt()
	case permissionmenu.FieldDeletedAt:
		return m.DeletedAt()
	case permissionmenu.FieldCreatedBy:
		return m.CreatedBy()
	case permissionmenu.FieldUpdatedBy:
		return m.UpdatedBy()
	case permissionmenu.FieldDeletedBy:
		return m.DeletedBy()
	case permissionmenu.FieldPermissionID:
		return m.PermissionID()
	case permissionmenu.FieldMenuID:
		return m.MenuID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionmenu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissionmenu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permissionmenu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permissionmenu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permissionmenu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permissionmenu.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case permissionmenu.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case permissionmenu.FieldMenuID:
		return m.OldMenuID(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionmenu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissionmenu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permissionmenu.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permissionmenu.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permissionmenu.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permissionmenu.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case permissionmenu.FieldPermissionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case permissionmenu.FieldMenuID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permissionmenu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permissionmenu.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, permissionmenu.FieldDeletedBy)
	}
	if m.addpermission_id != nil {
		fields = append(fields, permissionmenu.FieldPermissionID)
	}
	if m.addmenu_id != nil {
		fields = append(fields, permissionmenu.FieldMenuID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissionmenu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permissionmenu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case permissionmenu.FieldDeletedBy:
		return m.AddedDeletedBy()
	case permissionmenu.FieldPermissionID:
		return m.AddedPermissionID()
	case permissionmenu.FieldMenuID:
		return m.AddedMenuID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissionmenu.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permissionmenu.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case permissionmenu.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case permissionmenu.FieldPermissionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPermissionID(v)
		return nil
	case permissionmenu.FieldMenuID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissionmenu.FieldCreatedAt) {
		fields = append(fields, permissionmenu.FieldCreatedAt)
	}
	if m.FieldCleared(permissionmenu.FieldUpdatedAt) {
		fields = append(fields, permissionmenu.FieldUpdatedAt)
	}
	if m.FieldCleared(permissionmenu.FieldDeletedAt) {
		fields = append(fields, permissionmenu.FieldDeletedAt)
	}
	if m.FieldCleared(permissionmenu.FieldCreatedBy) {
		fields = append(fields, permissionmenu.FieldCreatedBy)
	}
	if m.FieldCleared(permissionmenu.FieldUpdatedBy) {
		fields = append(fields, permissionmenu.FieldUpdatedBy)
	}
	if m.FieldCleared(permissionmenu.FieldDeletedBy) {
		fields = append(fields, permissionmenu.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMenuMutation) ClearField(name string) error {
	switch name {
	case permissionmenu.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case permissionmenu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permissionmenu.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permissionmenu.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case permissionmenu.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case permissionmenu.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown PermissionMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMenuMutation) ResetField(name string) error {
	switch name {
	case permissionmenu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissionmenu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permissionmenu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permissionmenu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permissionmenu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permissionmenu.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case permissionmenu.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case permissionmenu.FieldMenuID:
		m.ResetMenuID()
		return nil
	}
	return fmt.Errorf("unknown PermissionMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMenuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMenuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMenuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMenuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionMenu edge %s", name)
}

// PermissionPolicyMutation represents an operation that mutates the PermissionPolicy nodes in the graph.
type PermissionPolicyMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	status           *permissionpolicy.Status
	permission_id    *uint32
	addpermission_id *int32
	policy_engine    *permissionpolicy.PolicyEngine
	definition       *string
	version          *uint32
	addversion       *int32
	eval_order       *uint32
	addeval_order    *int32
	cache_ttl        *uint32
	addcache_ttl     *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*PermissionPolicy, error)
	predicates       []predicate.PermissionPolicy
}

var _ ent.Mutation = (*PermissionPolicyMutation)(nil)

// permissionpolicyOption allows management of the mutation configuration using functional options.
type permissionpolicyOption func(*PermissionPolicyMutation)

// newPermissionPolicyMutation creates new mutation for the PermissionPolicy entity.
func newPermissionPolicyMutation(c config, op Op, opts ...permissionpolicyOption) *PermissionPolicyMutation {
	m := &PermissionPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionPolicyID sets the ID field of the mutation.
func withPermissionPolicyID(id uint32) permissionpolicyOption {
	return func(m *PermissionPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionPolicy
		)
		m.oldValue = func(ctx context.Context) (*PermissionPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionPolicy sets the old PermissionPolicy of the mutation.
func withPermissionPolicy(node *PermissionPolicy) permissionpolicyOption {
	return func(m *PermissionPolicyMutation) {
		m.oldValue = func(context.Context) (*PermissionPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionPolicy entities.
func (m *PermissionPolicyMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionPolicyMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionPolicyMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PermissionPolicyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[permissionpolicy.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PermissionPolicyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[permissionpolicy.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, permissionpolicy.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionPolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permissionpolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionPolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permissionpolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permissionpolicy.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionPolicyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionPolicyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionPolicyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permissionpolicy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionPolicyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permissionpolicy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionPolicyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permissionpolicy.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionPolicyMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionPolicyMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *PermissionPolicyMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionPolicyMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PermissionPolicyMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[permissionpolicy.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PermissionPolicyMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[permissionpolicy.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, permissionpolicy.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionPolicyMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionPolicyMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *PermissionPolicyMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionPolicyMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PermissionPolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[permissionpolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PermissionPolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[permissionpolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, permissionpolicy.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PermissionPolicyMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PermissionPolicyMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *PermissionPolicyMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PermissionPolicyMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PermissionPolicyMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[permissionpolicy.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PermissionPolicyMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[permissionpolicy.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PermissionPolicyMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, permissionpolicy.FieldDeletedBy)
}

// SetStatus sets the "status" field.
func (m *PermissionPolicyMutation) SetStatus(pe permissionpolicy.Status) {
	m.status = &pe
}

// Status returns the value of the "status" field in the mutation.
func (m *PermissionPolicyMutation) Status() (r permissionpolicy.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldStatus(ctx context.Context) (v *permissionpolicy.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PermissionPolicyMutation) ResetStatus() {
	m.status = nil
}

// SetPermissionID sets the "permission_id" field.
func (m *PermissionPolicyMutation) SetPermissionID(u uint32) {
	m.permission_id = &u
	m.addpermission_id = nil
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *PermissionPolicyMutation) PermissionID() (r uint32, exists bool) {
	v := m.permission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldPermissionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// AddPermissionID adds u to the "permission_id" field.
func (m *PermissionPolicyMutation) AddPermissionID(u int32) {
	if m.addpermission_id != nil {
		*m.addpermission_id += u
	} else {
		m.addpermission_id = &u
	}
}

// AddedPermissionID returns the value that was added to the "permission_id" field in this mutation.
func (m *PermissionPolicyMutation) AddedPermissionID() (r int32, exists bool) {
	v := m.addpermission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *PermissionPolicyMutation) ResetPermissionID() {
	m.permission_id = nil
	m.addpermission_id = nil
}

// SetPolicyEngine sets the "policy_engine" field.
func (m *PermissionPolicyMutation) SetPolicyEngine(pe permissionpolicy.PolicyEngine) {
	m.policy_engine = &pe
}

// PolicyEngine returns the value of the "policy_engine" field in the mutation.
func (m *PermissionPolicyMutation) PolicyEngine() (r permissionpolicy.PolicyEngine, exists bool) {
	v := m.policy_engine
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyEngine returns the old "policy_engine" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldPolicyEngine(ctx context.Context) (v *permissionpolicy.PolicyEngine, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyEngine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyEngine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyEngine: %w", err)
	}
	return oldValue.PolicyEngine, nil
}

// ResetPolicyEngine resets all changes to the "policy_engine" field.
func (m *PermissionPolicyMutation) ResetPolicyEngine() {
	m.policy_engine = nil
}

// SetDefinition sets the "definition" field.
func (m *PermissionPolicyMutation) SetDefinition(s string) {
	m.definition = &s
}

// Definition returns the value of the "definition" field in the mutation.
func (m *PermissionPolicyMutation) Definition() (r string, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinition returns the old "definition" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldDefinition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinition: %w", err)
	}
	return oldValue.Definition, nil
}

// ClearDefinition clears the value of the "definition" field.
func (m *PermissionPolicyMutation) ClearDefinition() {
	m.definition = nil
	m.clearedFields[permissionpolicy.FieldDefinition] = struct{}{}
}

// DefinitionCleared returns if the "definition" field was cleared in this mutation.
func (m *PermissionPolicyMutation) DefinitionCleared() bool {
	_, ok := m.clearedFields[permissionpolicy.FieldDefinition]
	return ok
}

// ResetDefinition resets all changes to the "definition" field.
func (m *PermissionPolicyMutation) ResetDefinition() {
	m.definition = nil
	delete(m.clearedFields, permissionpolicy.FieldDefinition)
}

// SetVersion sets the "version" field.
func (m *PermissionPolicyMutation) SetVersion(u uint32) {
	m.version = &u
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *PermissionPolicyMutation) Version() (r uint32, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldVersion(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds u to the "version" field.
func (m *PermissionPolicyMutation) AddVersion(u int32) {
	if m.addversion != nil {
		*m.addversion += u
	} else {
		m.addversion = &u
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *PermissionPolicyMutation) AddedVersion() (r int32, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *PermissionPolicyMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetEvalOrder sets the "eval_order" field.
func (m *PermissionPolicyMutation) SetEvalOrder(u uint32) {
	m.eval_order = &u
	m.addeval_order = nil
}

// EvalOrder returns the value of the "eval_order" field in the mutation.
func (m *PermissionPolicyMutation) EvalOrder() (r uint32, exists bool) {
	v := m.eval_order
	if v == nil {
		return
	}
	return *v, true
}

// OldEvalOrder returns the old "eval_order" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldEvalOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvalOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvalOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvalOrder: %w", err)
	}
	return oldValue.EvalOrder, nil
}

// AddEvalOrder adds u to the "eval_order" field.
func (m *PermissionPolicyMutation) AddEvalOrder(u int32) {
	if m.addeval_order != nil {
		*m.addeval_order += u
	} else {
		m.addeval_order = &u
	}
}

// AddedEvalOrder returns the value that was added to the "eval_order" field in this mutation.
func (m *PermissionPolicyMutation) AddedEvalOrder() (r int32, exists bool) {
	v := m.addeval_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetEvalOrder resets all changes to the "eval_order" field.
func (m *PermissionPolicyMutation) ResetEvalOrder() {
	m.eval_order = nil
	m.addeval_order = nil
}

// SetCacheTTL sets the "cache_ttl" field.
func (m *PermissionPolicyMutation) SetCacheTTL(u uint32) {
	m.cache_ttl = &u
	m.addcache_ttl = nil
}

// CacheTTL returns the value of the "cache_ttl" field in the mutation.
func (m *PermissionPolicyMutation) CacheTTL() (r uint32, exists bool) {
	v := m.cache_ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheTTL returns the old "cache_ttl" field's value of the PermissionPolicy entity.
// If the PermissionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionPolicyMutation) OldCacheTTL(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheTTL: %w", err)
	}
	return oldValue.CacheTTL, nil
}

// AddCacheTTL adds u to the "cache_ttl" field.
func (m *PermissionPolicyMutation) AddCacheTTL(u int32) {
	if m.addcache_ttl != nil {
		*m.addcache_ttl += u
	} else {
		m.addcache_ttl = &u
	}
}

// AddedCacheTTL returns the value that was added to the "cache_ttl" field in this mutation.
func (m *PermissionPolicyMutation) AddedCacheTTL() (r int32, exists bool) {
	v := m.addcache_ttl
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheTTL resets all changes to the "cache_ttl" field.
func (m *PermissionPolicyMutation) ResetCacheTTL() {
	m.cache_ttl = nil
	m.addcache_ttl = nil
}

// Where appends a list predicates to the PermissionPolicyMutation builder.
func (m *PermissionPolicyMutation) Where(ps ...predicate.PermissionPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionPolicy).
func (m *PermissionPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionPolicyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, permissionpolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permissionpolicy.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permissionpolicy.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, permissionpolicy.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, permissionpolicy.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, permissionpolicy.FieldDeletedBy)
	}
	if m.status != nil {
		fields = append(fields, permissionpolicy.FieldStatus)
	}
	if m.permission_id != nil {
		fields = append(fields, permissionpolicy.FieldPermissionID)
	}
	if m.policy_engine != nil {
		fields = append(fields, permissionpolicy.FieldPolicyEngine)
	}
	if m.definition != nil {
		fields = append(fields, permissionpolicy.FieldDefinition)
	}
	if m.version != nil {
		fields = append(fields, permissionpolicy.FieldVersion)
	}
	if m.eval_order != nil {
		fields = append(fields, permissionpolicy.FieldEvalOrder)
	}
	if m.cache_ttl != nil {
		fields = append(fields, permissionpolicy.FieldCacheTTL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case permissionpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case permissionpolicy.FieldDeletedAt:
		return m.DeletedAt()
	case permissionpolicy.FieldCreatedBy:
		return m.CreatedBy()
	case permissionpolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case permissionpolicy.FieldDeletedBy:
		return m.DeletedBy()
	case permissionpolicy.FieldStatus:
		return m.Status()
	case permissionpolicy.FieldPermissionID:
		return m.PermissionID()
	case permissionpolicy.FieldPolicyEngine:
		return m.PolicyEngine()
	case permissionpolicy.FieldDefinition:
		return m.Definition()
	case permissionpolicy.FieldVersion:
		return m.Version()
	case permissionpolicy.FieldEvalOrder:
		return m.EvalOrder()
	case permissionpolicy.FieldCacheTTL:
		return m.CacheTTL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissionpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permissionpolicy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permissionpolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permissionpolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permissionpolicy.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case permissionpolicy.FieldStatus:
		return m.OldStatus(ctx)
	case permissionpolicy.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case permissionpolicy.FieldPolicyEngine:
		return m.OldPolicyEngine(ctx)
	case permissionpolicy.FieldDefinition:
		return m.OldDefinition(ctx)
	case permissionpolicy.FieldVersion:
		return m.OldVersion(ctx)
	case permissionpolicy.FieldEvalOrder:
		return m.OldEvalOrder(ctx)
	case permissionpolicy.FieldCacheTTL:
		return m.OldCacheTTL(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissionpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permissionpolicy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permissionpolicy.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permissionpolicy.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permissionpolicy.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case permissionpolicy.FieldStatus:
		v, ok := value.(permissionpolicy.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case permissionpolicy.FieldPermissionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case permissionpolicy.FieldPolicyEngine:
		v, ok := value.(permissionpolicy.PolicyEngine)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyEngine(v)
		return nil
	case permissionpolicy.FieldDefinition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinition(v)
		return nil
	case permissionpolicy.FieldVersion:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case permissionpolicy.FieldEvalOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvalOrder(v)
		return nil
	case permissionpolicy.FieldCacheTTL:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheTTL(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permissionpolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permissionpolicy.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, permissionpolicy.FieldDeletedBy)
	}
	if m.addpermission_id != nil {
		fields = append(fields, permissionpolicy.FieldPermissionID)
	}
	if m.addversion != nil {
		fields = append(fields, permissionpolicy.FieldVersion)
	}
	if m.addeval_order != nil {
		fields = append(fields, permissionpolicy.FieldEvalOrder)
	}
	if m.addcache_ttl != nil {
		fields = append(fields, permissionpolicy.FieldCacheTTL)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissionpolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permissionpolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case permissionpolicy.FieldDeletedBy:
		return m.AddedDeletedBy()
	case permissionpolicy.FieldPermissionID:
		return m.AddedPermissionID()
	case permissionpolicy.FieldVersion:
		return m.AddedVersion()
	case permissionpolicy.FieldEvalOrder:
		return m.AddedEvalOrder()
	case permissionpolicy.FieldCacheTTL:
		return m.AddedCacheTTL()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissionpolicy.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permissionpolicy.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case permissionpolicy.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case permissionpolicy.FieldPermissionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPermissionID(v)
		return nil
	case permissionpolicy.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case permissionpolicy.FieldEvalOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEvalOrder(v)
		return nil
	case permissionpolicy.FieldCacheTTL:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheTTL(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissionpolicy.FieldCreatedAt) {
		fields = append(fields, permissionpolicy.FieldCreatedAt)
	}
	if m.FieldCleared(permissionpolicy.FieldUpdatedAt) {
		fields = append(fields, permissionpolicy.FieldUpdatedAt)
	}
	if m.FieldCleared(permissionpolicy.FieldDeletedAt) {
		fields = append(fields, permissionpolicy.FieldDeletedAt)
	}
	if m.FieldCleared(permissionpolicy.FieldCreatedBy) {
		fields = append(fields, permissionpolicy.FieldCreatedBy)
	}
	if m.FieldCleared(permissionpolicy.FieldUpdatedBy) {
		fields = append(fields, permissionpolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(permissionpolicy.FieldDeletedBy) {
		fields = append(fields, permissionpolicy.FieldDeletedBy)
	}
	if m.FieldCleared(permissionpolicy.FieldDefinition) {
		fields = append(fields, permissionpolicy.FieldDefinition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionPolicyMutation) ClearField(name string) error {
	switch name {
	case permissionpolicy.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case permissionpolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permissionpolicy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permissionpolicy.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case permissionpolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case permissionpolicy.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case permissionpolicy.FieldDefinition:
		m.ClearDefinition()
		return nil
	}
	return fmt.Errorf("unknown PermissionPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionPolicyMutation) ResetField(name string) error {
	switch name {
	case permissionpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissionpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permissionpolicy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permissionpolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permissionpolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permissionpolicy.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case permissionpolicy.FieldStatus:
		m.ResetStatus()
		return nil
	case permissionpolicy.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case permissionpolicy.FieldPolicyEngine:
		m.ResetPolicyEngine()
		return nil
	case permissionpolicy.FieldDefinition:
		m.ResetDefinition()
		return nil
	case permissionpolicy.FieldVersion:
		m.ResetVersion()
		return nil
	case permissionpolicy.FieldEvalOrder:
		m.ResetEvalOrder()
		return nil
	case permissionpolicy.FieldCacheTTL:
		m.ResetCacheTTL()
		return nil
	}
	return fmt.Errorf("unknown PermissionPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionPolicyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionPolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionPolicyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionPolicyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionPolicyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionPolicy edge %s", name)
}

// PolicyEvaluationLogMutation represents an operation that mutates the PolicyEvaluationLog nodes in the graph.
type PolicyEvaluationLogMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *time.Time
	tenant_id          *uint32
	addtenant_id       *int32
	user_id            *uint32
	adduser_id         *int32
	membership_id      *uint32
	addmembership_id   *int32
	permission_id      *uint32
	addpermission_id   *int32
	policy_id          *uint32
	addpolicy_id       *int32
	request_path       *string
	request_method     *string
	result             *bool
	effect_details     *string
	scope_sql          *string
	ip_address         *string
	trace_id           *string
	evaluation_context *string
	log_hash           *string
	signature          *[]byte
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*PolicyEvaluationLog, error)
	predicates         []predicate.PolicyEvaluationLog
}

var _ ent.Mutation = (*PolicyEvaluationLogMutation)(nil)

// policyevaluationlogOption allows management of the mutation configuration using functional options.
type policyevaluationlogOption func(*PolicyEvaluationLogMutation)

// newPolicyEvaluationLogMutation creates new mutation for the PolicyEvaluationLog entity.
func newPolicyEvaluationLogMutation(c config, op Op, opts ...policyevaluationlogOption) *PolicyEvaluationLogMutation {
	m := &PolicyEvaluationLogMutation{
		config:        c,
		op:            op,
		typ:           TypePolicyEvaluationLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPolicyEvaluationLogID sets the ID field of the mutation.
func withPolicyEvaluationLogID(id uint32) policyevaluationlogOption {
	return func(m *PolicyEvaluationLogMutation) {
		var (
			err   error
			once  sync.Once
			value *PolicyEvaluationLog
		)
		m.oldValue = func(ctx context.Context) (*PolicyEvaluationLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PolicyEvaluationLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPolicyEvaluationLog sets the old PolicyEvaluationLog of the mutation.
func withPolicyEvaluationLog(node *PolicyEvaluationLog) policyevaluationlogOption {
	return func(m *PolicyEvaluationLogMutation) {
		m.oldValue = func(context.Context) (*PolicyEvaluationLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PolicyEvaluationLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PolicyEvaluationLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PolicyEvaluationLog entities.
func (m *PolicyEvaluationLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PolicyEvaluationLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PolicyEvaluationLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PolicyEvaluationLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PolicyEvaluationLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PolicyEvaluationLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PolicyEvaluationLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[policyevaluationlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PolicyEvaluationLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, policyevaluationlog.FieldCreatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *PolicyEvaluationLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PolicyEvaluationLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *PolicyEvaluationLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *PolicyEvaluationLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PolicyEvaluationLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[policyevaluationlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PolicyEvaluationLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, policyevaluationlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *PolicyEvaluationLogMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PolicyEvaluationLogMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *PolicyEvaluationLogMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *PolicyEvaluationLogMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PolicyEvaluationLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetMembershipID sets the "membership_id" field.
func (m *PolicyEvaluationLogMutation) SetMembershipID(u uint32) {
	m.membership_id = &u
	m.addmembership_id = nil
}

// MembershipID returns the value of the "membership_id" field in the mutation.
func (m *PolicyEvaluationLogMutation) MembershipID() (r uint32, exists bool) {
	v := m.membership_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMembershipID returns the old "membership_id" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldMembershipID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembershipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembershipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembershipID: %w", err)
	}
	return oldValue.MembershipID, nil
}

// AddMembershipID adds u to the "membership_id" field.
func (m *PolicyEvaluationLogMutation) AddMembershipID(u int32) {
	if m.addmembership_id != nil {
		*m.addmembership_id += u
	} else {
		m.addmembership_id = &u
	}
}

// AddedMembershipID returns the value that was added to the "membership_id" field in this mutation.
func (m *PolicyEvaluationLogMutation) AddedMembershipID() (r int32, exists bool) {
	v := m.addmembership_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipID resets all changes to the "membership_id" field.
func (m *PolicyEvaluationLogMutation) ResetMembershipID() {
	m.membership_id = nil
	m.addmembership_id = nil
}

// SetPermissionID sets the "permission_id" field.
func (m *PolicyEvaluationLogMutation) SetPermissionID(u uint32) {
	m.permission_id = &u
	m.addpermission_id = nil
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *PolicyEvaluationLogMutation) PermissionID() (r uint32, exists bool) {
	v := m.permission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldPermissionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// AddPermissionID adds u to the "permission_id" field.
func (m *PolicyEvaluationLogMutation) AddPermissionID(u int32) {
	if m.addpermission_id != nil {
		*m.addpermission_id += u
	} else {
		m.addpermission_id = &u
	}
}

// AddedPermissionID returns the value that was added to the "permission_id" field in this mutation.
func (m *PolicyEvaluationLogMutation) AddedPermissionID() (r int32, exists bool) {
	v := m.addpermission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *PolicyEvaluationLogMutation) ResetPermissionID() {
	m.permission_id = nil
	m.addpermission_id = nil
}

// SetPolicyID sets the "policy_id" field.
func (m *PolicyEvaluationLogMutation) SetPolicyID(u uint32) {
	m.policy_id = &u
	m.addpolicy_id = nil
}

// PolicyID returns the value of the "policy_id" field in the mutation.
func (m *PolicyEvaluationLogMutation) PolicyID() (r uint32, exists bool) {
	v := m.policy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyID returns the old "policy_id" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldPolicyID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyID: %w", err)
	}
	return oldValue.PolicyID, nil
}

// AddPolicyID adds u to the "policy_id" field.
func (m *PolicyEvaluationLogMutation) AddPolicyID(u int32) {
	if m.addpolicy_id != nil {
		*m.addpolicy_id += u
	} else {
		m.addpolicy_id = &u
	}
}

// AddedPolicyID returns the value that was added to the "policy_id" field in this mutation.
func (m *PolicyEvaluationLogMutation) AddedPolicyID() (r int32, exists bool) {
	v := m.addpolicy_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPolicyID clears the value of the "policy_id" field.
func (m *PolicyEvaluationLogMutation) ClearPolicyID() {
	m.policy_id = nil
	m.addpolicy_id = nil
	m.clearedFields[policyevaluationlog.FieldPolicyID] = struct{}{}
}

// PolicyIDCleared returns if the "policy_id" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) PolicyIDCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldPolicyID]
	return ok
}

// ResetPolicyID resets all changes to the "policy_id" field.
func (m *PolicyEvaluationLogMutation) ResetPolicyID() {
	m.policy_id = nil
	m.addpolicy_id = nil
	delete(m.clearedFields, policyevaluationlog.FieldPolicyID)
}

// SetRequestPath sets the "request_path" field.
func (m *PolicyEvaluationLogMutation) SetRequestPath(s string) {
	m.request_path = &s
}

// RequestPath returns the value of the "request_path" field in the mutation.
func (m *PolicyEvaluationLogMutation) RequestPath() (r string, exists bool) {
	v := m.request_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestPath returns the old "request_path" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldRequestPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestPath: %w", err)
	}
	return oldValue.RequestPath, nil
}

// ClearRequestPath clears the value of the "request_path" field.
func (m *PolicyEvaluationLogMutation) ClearRequestPath() {
	m.request_path = nil
	m.clearedFields[policyevaluationlog.FieldRequestPath] = struct{}{}
}

// RequestPathCleared returns if the "request_path" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) RequestPathCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldRequestPath]
	return ok
}

// ResetRequestPath resets all changes to the "request_path" field.
func (m *PolicyEvaluationLogMutation) ResetRequestPath() {
	m.request_path = nil
	delete(m.clearedFields, policyevaluationlog.FieldRequestPath)
}

// SetRequestMethod sets the "request_method" field.
func (m *PolicyEvaluationLogMutation) SetRequestMethod(s string) {
	m.request_method = &s
}

// RequestMethod returns the value of the "request_method" field in the mutation.
func (m *PolicyEvaluationLogMutation) RequestMethod() (r string, exists bool) {
	v := m.request_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMethod returns the old "request_method" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldRequestMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMethod: %w", err)
	}
	return oldValue.RequestMethod, nil
}

// ClearRequestMethod clears the value of the "request_method" field.
func (m *PolicyEvaluationLogMutation) ClearRequestMethod() {
	m.request_method = nil
	m.clearedFields[policyevaluationlog.FieldRequestMethod] = struct{}{}
}

// RequestMethodCleared returns if the "request_method" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) RequestMethodCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldRequestMethod]
	return ok
}

// ResetRequestMethod resets all changes to the "request_method" field.
func (m *PolicyEvaluationLogMutation) ResetRequestMethod() {
	m.request_method = nil
	delete(m.clearedFields, policyevaluationlog.FieldRequestMethod)
}

// SetResult sets the "result" field.
func (m *PolicyEvaluationLogMutation) SetResult(b bool) {
	m.result = &b
}

// Result returns the value of the "result" field in the mutation.
func (m *PolicyEvaluationLogMutation) Result() (r bool, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldResult(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *PolicyEvaluationLogMutation) ResetResult() {
	m.result = nil
}

// SetEffectDetails sets the "effect_details" field.
func (m *PolicyEvaluationLogMutation) SetEffectDetails(s string) {
	m.effect_details = &s
}

// EffectDetails returns the value of the "effect_details" field in the mutation.
func (m *PolicyEvaluationLogMutation) EffectDetails() (r string, exists bool) {
	v := m.effect_details
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectDetails returns the old "effect_details" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldEffectDetails(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectDetails: %w", err)
	}
	return oldValue.EffectDetails, nil
}

// ClearEffectDetails clears the value of the "effect_details" field.
func (m *PolicyEvaluationLogMutation) ClearEffectDetails() {
	m.effect_details = nil
	m.clearedFields[policyevaluationlog.FieldEffectDetails] = struct{}{}
}

// EffectDetailsCleared returns if the "effect_details" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) EffectDetailsCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldEffectDetails]
	return ok
}

// ResetEffectDetails resets all changes to the "effect_details" field.
func (m *PolicyEvaluationLogMutation) ResetEffectDetails() {
	m.effect_details = nil
	delete(m.clearedFields, policyevaluationlog.FieldEffectDetails)
}

// SetScopeSQL sets the "scope_sql" field.
func (m *PolicyEvaluationLogMutation) SetScopeSQL(s string) {
	m.scope_sql = &s
}

// ScopeSQL returns the value of the "scope_sql" field in the mutation.
func (m *PolicyEvaluationLogMutation) ScopeSQL() (r string, exists bool) {
	v := m.scope_sql
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeSQL returns the old "scope_sql" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldScopeSQL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeSQL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeSQL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeSQL: %w", err)
	}
	return oldValue.ScopeSQL, nil
}

// ClearScopeSQL clears the value of the "scope_sql" field.
func (m *PolicyEvaluationLogMutation) ClearScopeSQL() {
	m.scope_sql = nil
	m.clearedFields[policyevaluationlog.FieldScopeSQL] = struct{}{}
}

// ScopeSQLCleared returns if the "scope_sql" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) ScopeSQLCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldScopeSQL]
	return ok
}

// ResetScopeSQL resets all changes to the "scope_sql" field.
func (m *PolicyEvaluationLogMutation) ResetScopeSQL() {
	m.scope_sql = nil
	delete(m.clearedFields, policyevaluationlog.FieldScopeSQL)
}

// SetIPAddress sets the "ip_address" field.
func (m *PolicyEvaluationLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *PolicyEvaluationLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *PolicyEvaluationLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[policyevaluationlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *PolicyEvaluationLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, policyevaluationlog.FieldIPAddress)
}

// SetTraceID sets the "trace_id" field.
func (m *PolicyEvaluationLogMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *PolicyEvaluationLogMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldTraceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *PolicyEvaluationLogMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[policyevaluationlog.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *PolicyEvaluationLogMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, policyevaluationlog.FieldTraceID)
}

// SetEvaluationContext sets the "evaluation_context" field.
func (m *PolicyEvaluationLogMutation) SetEvaluationContext(s string) {
	m.evaluation_context = &s
}

// EvaluationContext returns the value of the "evaluation_context" field in the mutation.
func (m *PolicyEvaluationLogMutation) EvaluationContext() (r string, exists bool) {
	v := m.evaluation_context
	if v == nil {
		return
	}
	return *v, true
}

// OldEvaluationContext returns the old "evaluation_context" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldEvaluationContext(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvaluationContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvaluationContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvaluationContext: %w", err)
	}
	return oldValue.EvaluationContext, nil
}

// ClearEvaluationContext clears the value of the "evaluation_context" field.
func (m *PolicyEvaluationLogMutation) ClearEvaluationContext() {
	m.evaluation_context = nil
	m.clearedFields[policyevaluationlog.FieldEvaluationContext] = struct{}{}
}

// EvaluationContextCleared returns if the "evaluation_context" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) EvaluationContextCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldEvaluationContext]
	return ok
}

// ResetEvaluationContext resets all changes to the "evaluation_context" field.
func (m *PolicyEvaluationLogMutation) ResetEvaluationContext() {
	m.evaluation_context = nil
	delete(m.clearedFields, policyevaluationlog.FieldEvaluationContext)
}

// SetLogHash sets the "log_hash" field.
func (m *PolicyEvaluationLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *PolicyEvaluationLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldLogHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *PolicyEvaluationLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[policyevaluationlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *PolicyEvaluationLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, policyevaluationlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *PolicyEvaluationLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *PolicyEvaluationLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the PolicyEvaluationLog entity.
// If the PolicyEvaluationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PolicyEvaluationLogMutation) OldSignature(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *PolicyEvaluationLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[policyevaluationlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[policyevaluationlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *PolicyEvaluationLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, policyevaluationlog.FieldSignature)
}

// Where appends a list predicates to the PolicyEvaluationLogMutation builder.
func (m *PolicyEvaluationLogMutation) Where(ps ...predicate.PolicyEvaluationLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PolicyEvaluationLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PolicyEvaluationLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PolicyEvaluationLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PolicyEvaluationLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PolicyEvaluationLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PolicyEvaluationLog).
func (m *PolicyEvaluationLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PolicyEvaluationLogMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, policyevaluationlog.FieldCreatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, policyevaluationlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, policyevaluationlog.FieldUserID)
	}
	if m.membership_id != nil {
		fields = append(fields, policyevaluationlog.FieldMembershipID)
	}
	if m.permission_id != nil {
		fields = append(fields, policyevaluationlog.FieldPermissionID)
	}
	if m.policy_id != nil {
		fields = append(fields, policyevaluationlog.FieldPolicyID)
	}
	if m.request_path != nil {
		fields = append(fields, policyevaluationlog.FieldRequestPath)
	}
	if m.request_method != nil {
		fields = append(fields, policyevaluationlog.FieldRequestMethod)
	}
	if m.result != nil {
		fields = append(fields, policyevaluationlog.FieldResult)
	}
	if m.effect_details != nil {
		fields = append(fields, policyevaluationlog.FieldEffectDetails)
	}
	if m.scope_sql != nil {
		fields = append(fields, policyevaluationlog.FieldScopeSQL)
	}
	if m.ip_address != nil {
		fields = append(fields, policyevaluationlog.FieldIPAddress)
	}
	if m.trace_id != nil {
		fields = append(fields, policyevaluationlog.FieldTraceID)
	}
	if m.evaluation_context != nil {
		fields = append(fields, policyevaluationlog.FieldEvaluationContext)
	}
	if m.log_hash != nil {
		fields = append(fields, policyevaluationlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, policyevaluationlog.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PolicyEvaluationLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case policyevaluationlog.FieldCreatedAt:
		return m.CreatedAt()
	case policyevaluationlog.FieldTenantID:
		return m.TenantID()
	case policyevaluationlog.FieldUserID:
		return m.UserID()
	case policyevaluationlog.FieldMembershipID:
		return m.MembershipID()
	case policyevaluationlog.FieldPermissionID:
		return m.PermissionID()
	case policyevaluationlog.FieldPolicyID:
		return m.PolicyID()
	case policyevaluationlog.FieldRequestPath:
		return m.RequestPath()
	case policyevaluationlog.FieldRequestMethod:
		return m.RequestMethod()
	case policyevaluationlog.FieldResult:
		return m.Result()
	case policyevaluationlog.FieldEffectDetails:
		return m.EffectDetails()
	case policyevaluationlog.FieldScopeSQL:
		return m.ScopeSQL()
	case policyevaluationlog.FieldIPAddress:
		return m.IPAddress()
	case policyevaluationlog.FieldTraceID:
		return m.TraceID()
	case policyevaluationlog.FieldEvaluationContext:
		return m.EvaluationContext()
	case policyevaluationlog.FieldLogHash:
		return m.LogHash()
	case policyevaluationlog.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PolicyEvaluationLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case policyevaluationlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case policyevaluationlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case policyevaluationlog.FieldUserID:
		return m.OldUserID(ctx)
	case policyevaluationlog.FieldMembershipID:
		return m.OldMembershipID(ctx)
	case policyevaluationlog.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case policyevaluationlog.FieldPolicyID:
		return m.OldPolicyID(ctx)
	case policyevaluationlog.FieldRequestPath:
		return m.OldRequestPath(ctx)
	case policyevaluationlog.FieldRequestMethod:
		return m.OldRequestMethod(ctx)
	case policyevaluationlog.FieldResult:
		return m.OldResult(ctx)
	case policyevaluationlog.FieldEffectDetails:
		return m.OldEffectDetails(ctx)
	case policyevaluationlog.FieldScopeSQL:
		return m.OldScopeSQL(ctx)
	case policyevaluationlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case policyevaluationlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case policyevaluationlog.FieldEvaluationContext:
		return m.OldEvaluationContext(ctx)
	case policyevaluationlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case policyevaluationlog.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown PolicyEvaluationLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PolicyEvaluationLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case policyevaluationlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case policyevaluationlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case policyevaluationlog.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case policyevaluationlog.FieldMembershipID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipID(v)
		return nil
	case policyevaluationlog.FieldPermissionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case policyevaluationlog.FieldPolicyID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyID(v)
		return nil
	case policyevaluationlog.FieldRequestPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestPath(v)
		return nil
	case policyevaluationlog.FieldRequestMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMethod(v)
		return nil
	case policyevaluationlog.FieldResult:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case policyevaluationlog.FieldEffectDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectDetails(v)
		return nil
	case policyevaluationlog.FieldScopeSQL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeSQL(v)
		return nil
	case policyevaluationlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case policyevaluationlog.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case policyevaluationlog.FieldEvaluationContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvaluationContext(v)
		return nil
	case policyevaluationlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case policyevaluationlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown PolicyEvaluationLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PolicyEvaluationLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, policyevaluationlog.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, policyevaluationlog.FieldUserID)
	}
	if m.addmembership_id != nil {
		fields = append(fields, policyevaluationlog.FieldMembershipID)
	}
	if m.addpermission_id != nil {
		fields = append(fields, policyevaluationlog.FieldPermissionID)
	}
	if m.addpolicy_id != nil {
		fields = append(fields, policyevaluationlog.FieldPolicyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PolicyEvaluationLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case policyevaluationlog.FieldTenantID:
		return m.AddedTenantID()
	case policyevaluationlog.FieldUserID:
		return m.AddedUserID()
	case policyevaluationlog.FieldMembershipID:
		return m.AddedMembershipID()
	case policyevaluationlog.FieldPermissionID:
		return m.AddedPermissionID()
	case policyevaluationlog.FieldPolicyID:
		return m.AddedPolicyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PolicyEvaluationLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case policyevaluationlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case policyevaluationlog.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case policyevaluationlog.FieldMembershipID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMembershipID(v)
		return nil
	case policyevaluationlog.FieldPermissionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPermissionID(v)
		return nil
	case policyevaluationlog.FieldPolicyID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPolicyID(v)
		return nil
	}
	return fmt.Errorf("unknown PolicyEvaluationLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PolicyEvaluationLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(policyevaluationlog.FieldCreatedAt) {
		fields = append(fields, policyevaluationlog.FieldCreatedAt)
	}
	if m.FieldCleared(policyevaluationlog.FieldTenantID) {
		fields = append(fields, policyevaluationlog.FieldTenantID)
	}
	if m.FieldCleared(policyevaluationlog.FieldPolicyID) {
		fields = append(fields, policyevaluationlog.FieldPolicyID)
	}
	if m.FieldCleared(policyevaluationlog.FieldRequestPath) {
		fields = append(fields, policyevaluationlog.FieldRequestPath)
	}
	if m.FieldCleared(policyevaluationlog.FieldRequestMethod) {
		fields = append(fields, policyevaluationlog.FieldRequestMethod)
	}
	if m.FieldCleared(policyevaluationlog.FieldEffectDetails) {
		fields = append(fields, policyevaluationlog.FieldEffectDetails)
	}
	if m.FieldCleared(policyevaluationlog.FieldScopeSQL) {
		fields = append(fields, policyevaluationlog.FieldScopeSQL)
	}
	if m.FieldCleared(policyevaluationlog.FieldIPAddress) {
		fields = append(fields, policyevaluationlog.FieldIPAddress)
	}
	if m.FieldCleared(policyevaluationlog.FieldTraceID) {
		fields = append(fields, policyevaluationlog.FieldTraceID)
	}
	if m.FieldCleared(policyevaluationlog.FieldEvaluationContext) {
		fields = append(fields, policyevaluationlog.FieldEvaluationContext)
	}
	if m.FieldCleared(policyevaluationlog.FieldLogHash) {
		fields = append(fields, policyevaluationlog.FieldLogHash)
	}
	if m.FieldCleared(policyevaluationlog.FieldSignature) {
		fields = append(fields, policyevaluationlog.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PolicyEvaluationLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PolicyEvaluationLogMutation) ClearField(name string) error {
	switch name {
	case policyevaluationlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case policyevaluationlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case policyevaluationlog.FieldPolicyID:
		m.ClearPolicyID()
		return nil
	case policyevaluationlog.FieldRequestPath:
		m.ClearRequestPath()
		return nil
	case policyevaluationlog.FieldRequestMethod:
		m.ClearRequestMethod()
		return nil
	case policyevaluationlog.FieldEffectDetails:
		m.ClearEffectDetails()
		return nil
	case policyevaluationlog.FieldScopeSQL:
		m.ClearScopeSQL()
		return nil
	case policyevaluationlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case policyevaluationlog.FieldTraceID:
		m.ClearTraceID()
		return nil
	case policyevaluationlog.FieldEvaluationContext:
		m.ClearEvaluationContext()
		return nil
	case policyevaluationlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case policyevaluationlog.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown PolicyEvaluationLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PolicyEvaluationLogMutation) ResetField(name string) error {
	switch name {
	case policyevaluationlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case policyevaluationlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case policyevaluationlog.FieldUserID:
		m.ResetUserID()
		return nil
	case policyevaluationlog.FieldMembershipID:
		m.ResetMembershipID()
		return nil
	case policyevaluationlog.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case policyevaluationlog.FieldPolicyID:
		m.ResetPolicyID()
		return nil
	case policyevaluationlog.FieldRequestPath:
		m.ResetRequestPath()
		return nil
	case policyevaluationlog.FieldRequestMethod:
		m.ResetRequestMethod()
		return nil
	case policyevaluationlog.FieldResult:
		m.ResetResult()
		return nil
	case policyevaluationlog.FieldEffectDetails:
		m.ResetEffectDetails()
		return nil
	case policyevaluationlog.FieldScopeSQL:
		m.ResetScopeSQL()
		return nil
	case policyevaluationlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case policyevaluationlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case policyevaluationlog.FieldEvaluationContext:
		m.ResetEvaluationContext()
		return nil
	case policyevaluationlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case policyevaluationlog.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown PolicyEvaluationLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PolicyEvaluationLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PolicyEvaluationLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PolicyEvaluationLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PolicyEvaluationLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PolicyEvaluationLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PolicyEvaluationLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PolicyEvaluationLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PolicyEvaluationLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PolicyEvaluationLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PolicyEvaluationLog edge %s", name)
}

// PositionMutation represents an operation that mutates the Position nodes in the graph.
type PositionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	created_by                *uint32
	addcreated_by             *int32
	updated_by                *uint32
	addupdated_by             *int32
	deleted_by                *uint32
	adddeleted_by             *int32
	sort_order                *uint32
	addsort_order             *int32
	remark                    *string
	tenant_id                 *uint32
	addtenant_id              *int32
	status                    *position.Status
	name                      *string
	code                      *string
	org_unit_id               *uint32
	addorg_unit_id            *int32
	reports_to_position_id    *uint32
	addreports_to_position_id *int32
	description               *string
	job_family                *string
	job_grade                 *string
	level                     *int32
	addlevel                  *int32
	headcount                 *uint32
	addheadcount              *int32
	is_key_position           *bool
	_type                     *position.Type
	start_at                  *time.Time
	end_at                    *time.Time
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Position, error)
	predicates                []predicate.Position
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows management of the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for the Position entity.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the ID field of the mutation.
func withPositionID(id uint32) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Position entities.
func (m *PositionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Position.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PositionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[position.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PositionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[position.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, position.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PositionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[position.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PositionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[position.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, position.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PositionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PositionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PositionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[position.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PositionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[position.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PositionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, position.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PositionMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PositionMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *PositionMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PositionMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PositionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[position.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PositionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[position.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PositionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, position.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PositionMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PositionMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *PositionMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PositionMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PositionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[position.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PositionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[position.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PositionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, position.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PositionMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PositionMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *PositionMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PositionMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PositionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[position.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PositionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[position.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PositionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, position.FieldDeletedBy)
}

// SetSortOrder sets the "sort_order" field.
func (m *PositionMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *PositionMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *PositionMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *PositionMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *PositionMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[position.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *PositionMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[position.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *PositionMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, position.FieldSortOrder)
}

// SetRemark sets the "remark" field.
func (m *PositionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PositionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PositionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[position.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PositionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[position.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PositionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, position.FieldRemark)
}

// SetTenantID sets the "tenant_id" field.
func (m *PositionMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PositionMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *PositionMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *PositionMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PositionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[position.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PositionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[position.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PositionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, position.FieldTenantID)
}

// SetStatus sets the "status" field.
func (m *PositionMutation) SetStatus(po position.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PositionMutation) Status() (r position.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldStatus(ctx context.Context) (v *position.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PositionMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *PositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PositionMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *PositionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PositionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PositionMutation) ResetCode() {
	m.code = nil
}

// SetOrgUnitID sets the "org_unit_id" field.
func (m *PositionMutation) SetOrgUnitID(u uint32) {
	m.org_unit_id = &u
	m.addorg_unit_id = nil
}

// OrgUnitID returns the value of the "org_unit_id" field in the mutation.
func (m *PositionMutation) OrgUnitID() (r uint32, exists bool) {
	v := m.org_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitID returns the old "org_unit_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldOrgUnitID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitID: %w", err)
	}
	return oldValue.OrgUnitID, nil
}

// AddOrgUnitID adds u to the "org_unit_id" field.
func (m *PositionMutation) AddOrgUnitID(u int32) {
	if m.addorg_unit_id != nil {
		*m.addorg_unit_id += u
	} else {
		m.addorg_unit_id = &u
	}
}

// AddedOrgUnitID returns the value that was added to the "org_unit_id" field in this mutation.
func (m *PositionMutation) AddedOrgUnitID() (r int32, exists bool) {
	v := m.addorg_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgUnitID resets all changes to the "org_unit_id" field.
func (m *PositionMutation) ResetOrgUnitID() {
	m.org_unit_id = nil
	m.addorg_unit_id = nil
}

// SetReportsToPositionID sets the "reports_to_position_id" field.
func (m *PositionMutation) SetReportsToPositionID(u uint32) {
	m.reports_to_position_id = &u
	m.addreports_to_position_id = nil
}

// ReportsToPositionID returns the value of the "reports_to_position_id" field in the mutation.
func (m *PositionMutation) ReportsToPositionID() (r uint32, exists bool) {
	v := m.reports_to_position_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReportsToPositionID returns the old "reports_to_position_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldReportsToPositionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportsToPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportsToPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportsToPositionID: %w", err)
	}
	return oldValue.ReportsToPositionID, nil
}

// AddReportsToPositionID adds u to the "reports_to_position_id" field.
func (m *PositionMutation) AddReportsToPositionID(u int32) {
	if m.addreports_to_position_id != nil {
		*m.addreports_to_position_id += u
	} else {
		m.addreports_to_position_id = &u
	}
}

// AddedReportsToPositionID returns the value that was added to the "reports_to_position_id" field in this mutation.
func (m *PositionMutation) AddedReportsToPositionID() (r int32, exists bool) {
	v := m.addreports_to_position_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReportsToPositionID clears the value of the "reports_to_position_id" field.
func (m *PositionMutation) ClearReportsToPositionID() {
	m.reports_to_position_id = nil
	m.addreports_to_position_id = nil
	m.clearedFields[position.FieldReportsToPositionID] = struct{}{}
}

// ReportsToPositionIDCleared returns if the "reports_to_position_id" field was cleared in this mutation.
func (m *PositionMutation) ReportsToPositionIDCleared() bool {
	_, ok := m.clearedFields[position.FieldReportsToPositionID]
	return ok
}

// ResetReportsToPositionID resets all changes to the "reports_to_position_id" field.
func (m *PositionMutation) ResetReportsToPositionID() {
	m.reports_to_position_id = nil
	m.addreports_to_position_id = nil
	delete(m.clearedFields, position.FieldReportsToPositionID)
}

// SetDescription sets the "description" field.
func (m *PositionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PositionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PositionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[position.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PositionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[position.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PositionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, position.FieldDescription)
}

// SetJobFamily sets the "job_family" field.
func (m *PositionMutation) SetJobFamily(s string) {
	m.job_family = &s
}

// JobFamily returns the value of the "job_family" field in the mutation.
func (m *PositionMutation) JobFamily() (r string, exists bool) {
	v := m.job_family
	if v == nil {
		return
	}
	return *v, true
}

// OldJobFamily returns the old "job_family" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldJobFamily(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobFamily: %w", err)
	}
	return oldValue.JobFamily, nil
}

// ClearJobFamily clears the value of the "job_family" field.
func (m *PositionMutation) ClearJobFamily() {
	m.job_family = nil
	m.clearedFields[position.FieldJobFamily] = struct{}{}
}

// JobFamilyCleared returns if the "job_family" field was cleared in this mutation.
func (m *PositionMutation) JobFamilyCleared() bool {
	_, ok := m.clearedFields[position.FieldJobFamily]
	return ok
}

// ResetJobFamily resets all changes to the "job_family" field.
func (m *PositionMutation) ResetJobFamily() {
	m.job_family = nil
	delete(m.clearedFields, position.FieldJobFamily)
}

// SetJobGrade sets the "job_grade" field.
func (m *PositionMutation) SetJobGrade(s string) {
	m.job_grade = &s
}

// JobGrade returns the value of the "job_grade" field in the mutation.
func (m *PositionMutation) JobGrade() (r string, exists bool) {
	v := m.job_grade
	if v == nil {
		return
	}
	return *v, true
}

// OldJobGrade returns the old "job_grade" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldJobGrade(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobGrade: %w", err)
	}
	return oldValue.JobGrade, nil
}

// ClearJobGrade clears the value of the "job_grade" field.
func (m *PositionMutation) ClearJobGrade() {
	m.job_grade = nil
	m.clearedFields[position.FieldJobGrade] = struct{}{}
}

// JobGradeCleared returns if the "job_grade" field was cleared in this mutation.
func (m *PositionMutation) JobGradeCleared() bool {
	_, ok := m.clearedFields[position.FieldJobGrade]
	return ok
}

// ResetJobGrade resets all changes to the "job_grade" field.
func (m *PositionMutation) ResetJobGrade() {
	m.job_grade = nil
	delete(m.clearedFields, position.FieldJobGrade)
}

// SetLevel sets the "level" field.
func (m *PositionMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *PositionMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldLevel(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *PositionMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *PositionMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *PositionMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[position.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *PositionMutation) LevelCleared() bool {
	_, ok := m.clearedFields[position.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *PositionMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, position.FieldLevel)
}

// SetHeadcount sets the "headcount" field.
func (m *PositionMutation) SetHeadcount(u uint32) {
	m.headcount = &u
	m.addheadcount = nil
}

// Headcount returns the value of the "headcount" field in the mutation.
func (m *PositionMutation) Headcount() (r uint32, exists bool) {
	v := m.headcount
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadcount returns the old "headcount" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldHeadcount(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeadcount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeadcount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadcount: %w", err)
	}
	return oldValue.Headcount, nil
}

// AddHeadcount adds u to the "headcount" field.
func (m *PositionMutation) AddHeadcount(u int32) {
	if m.addheadcount != nil {
		*m.addheadcount += u
	} else {
		m.addheadcount = &u
	}
}

// AddedHeadcount returns the value that was added to the "headcount" field in this mutation.
func (m *PositionMutation) AddedHeadcount() (r int32, exists bool) {
	v := m.addheadcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeadcount resets all changes to the "headcount" field.
func (m *PositionMutation) ResetHeadcount() {
	m.headcount = nil
	m.addheadcount = nil
}

// SetIsKeyPosition sets the "is_key_position" field.
func (m *PositionMutation) SetIsKeyPosition(b bool) {
	m.is_key_position = &b
}

// IsKeyPosition returns the value of the "is_key_position" field in the mutation.
func (m *PositionMutation) IsKeyPosition() (r bool, exists bool) {
	v := m.is_key_position
	if v == nil {
		return
	}
	return *v, true
}

// OldIsKeyPosition returns the old "is_key_position" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldIsKeyPosition(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsKeyPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsKeyPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsKeyPosition: %w", err)
	}
	return oldValue.IsKeyPosition, nil
}

// ResetIsKeyPosition resets all changes to the "is_key_position" field.
func (m *PositionMutation) ResetIsKeyPosition() {
	m.is_key_position = nil
}

// SetType sets the "type" field.
func (m *PositionMutation) SetType(po position.Type) {
	m._type = &po
}

// GetType returns the value of the "type" field in the mutation.
func (m *PositionMutation) GetType() (r position.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldType(ctx context.Context) (v position.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PositionMutation) ResetType() {
	m._type = nil
}

// SetStartAt sets the "start_at" field.
func (m *PositionMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *PositionMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *PositionMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[position.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *PositionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[position.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *PositionMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, position.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *PositionMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *PositionMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *PositionMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[position.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *PositionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[position.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *PositionMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, position.FieldEndAt)
}

// Where appends a list predicates to the PositionMutation builder.
func (m *PositionMutation) Where(ps ...predicate.Position) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Position, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, position.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, position.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, position.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, position.FieldDeletedBy)
	}
	if m.sort_order != nil {
		fields = append(fields, position.FieldSortOrder)
	}
	if m.remark != nil {
		fields = append(fields, position.FieldRemark)
	}
	if m.tenant_id != nil {
		fields = append(fields, position.FieldTenantID)
	}
	if m.status != nil {
		fields = append(fields, position.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, position.FieldName)
	}
	if m.code != nil {
		fields = append(fields, position.FieldCode)
	}
	if m.org_unit_id != nil {
		fields = append(fields, position.FieldOrgUnitID)
	}
	if m.reports_to_position_id != nil {
		fields = append(fields, position.FieldReportsToPositionID)
	}
	if m.description != nil {
		fields = append(fields, position.FieldDescription)
	}
	if m.job_family != nil {
		fields = append(fields, position.FieldJobFamily)
	}
	if m.job_grade != nil {
		fields = append(fields, position.FieldJobGrade)
	}
	if m.level != nil {
		fields = append(fields, position.FieldLevel)
	}
	if m.headcount != nil {
		fields = append(fields, position.FieldHeadcount)
	}
	if m.is_key_position != nil {
		fields = append(fields, position.FieldIsKeyPosition)
	}
	if m._type != nil {
		fields = append(fields, position.FieldType)
	}
	if m.start_at != nil {
		fields = append(fields, position.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, position.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldCreatedAt:
		return m.CreatedAt()
	case position.FieldUpdatedAt:
		return m.UpdatedAt()
	case position.FieldDeletedAt:
		return m.DeletedAt()
	case position.FieldCreatedBy:
		return m.CreatedBy()
	case position.FieldUpdatedBy:
		return m.UpdatedBy()
	case position.FieldDeletedBy:
		return m.DeletedBy()
	case position.FieldSortOrder:
		return m.SortOrder()
	case position.FieldRemark:
		return m.Remark()
	case position.FieldTenantID:
		return m.TenantID()
	case position.FieldStatus:
		return m.Status()
	case position.FieldName:
		return m.Name()
	case position.FieldCode:
		return m.Code()
	case position.FieldOrgUnitID:
		return m.OrgUnitID()
	case position.FieldReportsToPositionID:
		return m.ReportsToPositionID()
	case position.FieldDescription:
		return m.Description()
	case position.FieldJobFamily:
		return m.JobFamily()
	case position.FieldJobGrade:
		return m.JobGrade()
	case position.FieldLevel:
		return m.Level()
	case position.FieldHeadcount:
		return m.Headcount()
	case position.FieldIsKeyPosition:
		return m.IsKeyPosition()
	case position.FieldType:
		return m.GetType()
	case position.FieldStartAt:
		return m.StartAt()
	case position.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case position.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case position.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case position.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case position.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case position.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case position.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case position.FieldRemark:
		return m.OldRemark(ctx)
	case position.FieldTenantID:
		return m.OldTenantID(ctx)
	case position.FieldStatus:
		return m.OldStatus(ctx)
	case position.FieldName:
		return m.OldName(ctx)
	case position.FieldCode:
		return m.OldCode(ctx)
	case position.FieldOrgUnitID:
		return m.OldOrgUnitID(ctx)
	case position.FieldReportsToPositionID:
		return m.OldReportsToPositionID(ctx)
	case position.FieldDescription:
		return m.OldDescription(ctx)
	case position.FieldJobFamily:
		return m.OldJobFamily(ctx)
	case position.FieldJobGrade:
		return m.OldJobGrade(ctx)
	case position.FieldLevel:
		return m.OldLevel(ctx)
	case position.FieldHeadcount:
		return m.OldHeadcount(ctx)
	case position.FieldIsKeyPosition:
		return m.OldIsKeyPosition(ctx)
	case position.FieldType:
		return m.OldType(ctx)
	case position.FieldStartAt:
		return m.OldStartAt(ctx)
	case position.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case position.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case position.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case position.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case position.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case position.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case position.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case position.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case position.FieldStatus:
		v, ok := value.(position.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case position.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case position.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case position.FieldOrgUnitID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitID(v)
		return nil
	case position.FieldReportsToPositionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportsToPositionID(v)
		return nil
	case position.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case position.FieldJobFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobFamily(v)
		return nil
	case position.FieldJobGrade:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobGrade(v)
		return nil
	case position.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case position.FieldHeadcount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadcount(v)
		return nil
	case position.FieldIsKeyPosition:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsKeyPosition(v)
		return nil
	case position.FieldType:
		v, ok := value.(position.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case position.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case position.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, position.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, position.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, position.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, position.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, position.FieldTenantID)
	}
	if m.addorg_unit_id != nil {
		fields = append(fields, position.FieldOrgUnitID)
	}
	if m.addreports_to_position_id != nil {
		fields = append(fields, position.FieldReportsToPositionID)
	}
	if m.addlevel != nil {
		fields = append(fields, position.FieldLevel)
	}
	if m.addheadcount != nil {
		fields = append(fields, position.FieldHeadcount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case position.FieldCreatedBy:
		return m.AddedCreatedBy()
	case position.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case position.FieldDeletedBy:
		return m.AddedDeletedBy()
	case position.FieldSortOrder:
		return m.AddedSortOrder()
	case position.FieldTenantID:
		return m.AddedTenantID()
	case position.FieldOrgUnitID:
		return m.AddedOrgUnitID()
	case position.FieldReportsToPositionID:
		return m.AddedReportsToPositionID()
	case position.FieldLevel:
		return m.AddedLevel()
	case position.FieldHeadcount:
		return m.AddedHeadcount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case position.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case position.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case position.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case position.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case position.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case position.FieldOrgUnitID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgUnitID(v)
		return nil
	case position.FieldReportsToPositionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReportsToPositionID(v)
		return nil
	case position.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case position.FieldHeadcount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeadcount(v)
		return nil
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(position.FieldCreatedAt) {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.FieldCleared(position.FieldUpdatedAt) {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.FieldCleared(position.FieldDeletedAt) {
		fields = append(fields, position.FieldDeletedAt)
	}
	if m.FieldCleared(position.FieldCreatedBy) {
		fields = append(fields, position.FieldCreatedBy)
	}
	if m.FieldCleared(position.FieldUpdatedBy) {
		fields = append(fields, position.FieldUpdatedBy)
	}
	if m.FieldCleared(position.FieldDeletedBy) {
		fields = append(fields, position.FieldDeletedBy)
	}
	if m.FieldCleared(position.FieldSortOrder) {
		fields = append(fields, position.FieldSortOrder)
	}
	if m.FieldCleared(position.FieldRemark) {
		fields = append(fields, position.FieldRemark)
	}
	if m.FieldCleared(position.FieldTenantID) {
		fields = append(fields, position.FieldTenantID)
	}
	if m.FieldCleared(position.FieldReportsToPositionID) {
		fields = append(fields, position.FieldReportsToPositionID)
	}
	if m.FieldCleared(position.FieldDescription) {
		fields = append(fields, position.FieldDescription)
	}
	if m.FieldCleared(position.FieldJobFamily) {
		fields = append(fields, position.FieldJobFamily)
	}
	if m.FieldCleared(position.FieldJobGrade) {
		fields = append(fields, position.FieldJobGrade)
	}
	if m.FieldCleared(position.FieldLevel) {
		fields = append(fields, position.FieldLevel)
	}
	if m.FieldCleared(position.FieldStartAt) {
		fields = append(fields, position.FieldStartAt)
	}
	if m.FieldCleared(position.FieldEndAt) {
		fields = append(fields, position.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	switch name {
	case position.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case position.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case position.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case position.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case position.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case position.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case position.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case position.FieldRemark:
		m.ClearRemark()
		return nil
	case position.FieldTenantID:
		m.ClearTenantID()
		return nil
	case position.FieldReportsToPositionID:
		m.ClearReportsToPositionID()
		return nil
	case position.FieldDescription:
		m.ClearDescription()
		return nil
	case position.FieldJobFamily:
		m.ClearJobFamily()
		return nil
	case position.FieldJobGrade:
		m.ClearJobGrade()
		return nil
	case position.FieldLevel:
		m.ClearLevel()
		return nil
	case position.FieldStartAt:
		m.ClearStartAt()
		return nil
	case position.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case position.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case position.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case position.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case position.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case position.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case position.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case position.FieldRemark:
		m.ResetRemark()
		return nil
	case position.FieldTenantID:
		m.ResetTenantID()
		return nil
	case position.FieldStatus:
		m.ResetStatus()
		return nil
	case position.FieldName:
		m.ResetName()
		return nil
	case position.FieldCode:
		m.ResetCode()
		return nil
	case position.FieldOrgUnitID:
		m.ResetOrgUnitID()
		return nil
	case position.FieldReportsToPositionID:
		m.ResetReportsToPositionID()
		return nil
	case position.FieldDescription:
		m.ResetDescription()
		return nil
	case position.FieldJobFamily:
		m.ResetJobFamily()
		return nil
	case position.FieldJobGrade:
		m.ResetJobGrade()
		return nil
	case position.FieldLevel:
		m.ResetLevel()
		return nil
	case position.FieldHeadcount:
		m.ResetHeadcount()
		return nil
	case position.FieldIsKeyPosition:
		m.ResetIsKeyPosition()
		return nil
	case position.FieldType:
		m.ResetType()
		return nil
	case position.FieldStartAt:
		m.ResetStartAt()
		return nil
	case position.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Position edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	updated_by    *uint32
	addupdated_by *int32
	deleted_by    *uint32
	adddeleted_by *int32
	remark        *string
	description   *string
	sort_order    *uint32
	addsort_order *int32
	tenant_id     *uint32
	addtenant_id  *int32
	status        *role.Status
	name          *string
	code          *string
	is_protected  *bool
	is_system     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uint32) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[role.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, role.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[role.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, role.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *RoleMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RoleMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[role.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, role.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RoleMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RoleMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *RoleMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RoleMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[role.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, role.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RoleMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RoleMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *RoleMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *RoleMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RoleMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[role.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RoleMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RoleMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, role.FieldDeletedBy)
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *RoleMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[role.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *RoleMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[role.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, role.FieldRemark)
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetSortOrder sets the "sort_order" field.
func (m *RoleMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *RoleMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSortOrder(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *RoleMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *RoleMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *RoleMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[role.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *RoleMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[role.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *RoleMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, role.FieldSortOrder)
}

// SetTenantID sets the "tenant_id" field.
func (m *RoleMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RoleMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *RoleMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *RoleMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *RoleMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[role.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *RoleMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[role.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RoleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, role.FieldTenantID)
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(r role.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r role.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v *role.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *RoleMutation) ClearName() {
	m.name = nil
	m.clearedFields[role.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *RoleMutation) NameCleared() bool {
	_, ok := m.clearedFields[role.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, role.FieldName)
}

// SetCode sets the "code" field.
func (m *RoleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RoleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *RoleMutation) ClearCode() {
	m.code = nil
	m.clearedFields[role.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *RoleMutation) CodeCleared() bool {
	_, ok := m.clearedFields[role.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *RoleMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, role.FieldCode)
}

// SetIsProtected sets the "is_protected" field.
func (m *RoleMutation) SetIsProtected(b bool) {
	m.is_protected = &b
}

// IsProtected returns the value of the "is_protected" field in the mutation.
func (m *RoleMutation) IsProtected() (r bool, exists bool) {
	v := m.is_protected
	if v == nil {
		return
	}
	return *v, true
}

// OldIsProtected returns the old "is_protected" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsProtected(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsProtected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsProtected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsProtected: %w", err)
	}
	return oldValue.IsProtected, nil
}

// ResetIsProtected resets all changes to the "is_protected" field.
func (m *RoleMutation) ResetIsProtected() {
	m.is_protected = nil
}

// SetIsSystem sets the "is_system" field.
func (m *RoleMutation) SetIsSystem(b bool) {
	m.is_system = &b
}

// IsSystem returns the value of the "is_system" field in the mutation.
func (m *RoleMutation) IsSystem() (r bool, exists bool) {
	v := m.is_system
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSystem returns the old "is_system" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsSystem(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSystem: %w", err)
	}
	return oldValue.IsSystem, nil
}

// ResetIsSystem resets all changes to the "is_system" field.
func (m *RoleMutation) ResetIsSystem() {
	m.is_system = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, role.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, role.FieldDeletedBy)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.sort_order != nil {
		fields = append(fields, role.FieldSortOrder)
	}
	if m.tenant_id != nil {
		fields = append(fields, role.FieldTenantID)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.code != nil {
		fields = append(fields, role.FieldCode)
	}
	if m.is_protected != nil {
		fields = append(fields, role.FieldIsProtected)
	}
	if m.is_system != nil {
		fields = append(fields, role.FieldIsSystem)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldCreatedBy:
		return m.CreatedBy()
	case role.FieldUpdatedBy:
		return m.UpdatedBy()
	case role.FieldDeletedBy:
		return m.DeletedBy()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldDescription:
		return m.Description()
	case role.FieldSortOrder:
		return m.SortOrder()
	case role.FieldTenantID:
		return m.TenantID()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldCode:
		return m.Code()
	case role.FieldIsProtected:
		return m.IsProtected()
	case role.FieldIsSystem:
		return m.IsSystem()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case role.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case role.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case role.FieldTenantID:
		return m.OldTenantID(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCode:
		return m.OldCode(ctx)
	case role.FieldIsProtected:
		return m.OldIsProtected(ctx)
	case role.FieldIsSystem:
		return m.OldIsSystem(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case role.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case role.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case role.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(role.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case role.FieldIsProtected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsProtected(v)
		return nil
	case role.FieldIsSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSystem(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, role.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, role.FieldDeletedBy)
	}
	if m.addsort_order != nil {
		fields = append(fields, role.FieldSortOrder)
	}
	if m.addtenant_id != nil {
		fields = append(fields, role.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedBy:
		return m.AddedCreatedBy()
	case role.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case role.FieldDeletedBy:
		return m.AddedDeletedBy()
	case role.FieldSortOrder:
		return m.AddedSortOrder()
	case role.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case role.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case role.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case role.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case role.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldCreatedAt) {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.FieldCleared(role.FieldUpdatedAt) {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.FieldCleared(role.FieldCreatedBy) {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.FieldCleared(role.FieldUpdatedBy) {
		fields = append(fields, role.FieldUpdatedBy)
	}
	if m.FieldCleared(role.FieldDeletedBy) {
		fields = append(fields, role.FieldDeletedBy)
	}
	if m.FieldCleared(role.FieldRemark) {
		fields = append(fields, role.FieldRemark)
	}
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldSortOrder) {
		fields = append(fields, role.FieldSortOrder)
	}
	if m.FieldCleared(role.FieldTenantID) {
		fields = append(fields, role.FieldTenantID)
	}
	if m.FieldCleared(role.FieldName) {
		fields = append(fields, role.FieldName)
	}
	if m.FieldCleared(role.FieldCode) {
		fields = append(fields, role.FieldCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case role.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case role.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case role.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case role.FieldRemark:
		m.ClearRemark()
		return nil
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case role.FieldTenantID:
		m.ClearTenantID()
		return nil
	case role.FieldName:
		m.ClearName()
		return nil
	case role.FieldCode:
		m.ClearCode()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case role.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case role.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case role.FieldTenantID:
		m.ResetTenantID()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCode:
		m.ResetCode()
		return nil
	case role.FieldIsProtected:
		m.ResetIsProtected()
		return nil
	case role.FieldIsSystem:
		m.ResetIsSystem()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoleMetadataMutation represents an operation that mutates the RoleMetadata nodes in the graph.
type RoleMetadataMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint32
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	created_by             *uint32
	addcreated_by          *int32
	updated_by             *uint32
	addupdated_by          *int32
	deleted_by             *uint32
	adddeleted_by          *int32
	tenant_id              *uint32
	addtenant_id           *int32
	role_id                *uint32
	addrole_id             *int32
	is_template            *bool
	template_for           *string
	template_version       *int32
	addtemplate_version    *int32
	last_synced_version    *int32
	addlast_synced_version *int32
	last_synced_at         *time.Time
	sync_policy            *rolemetadata.SyncPolicy
	scope                  *rolemetadata.Scope
	custom_overrides       **servicev1.RoleOverride
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*RoleMetadata, error)
	predicates             []predicate.RoleMetadata
}

var _ ent.Mutation = (*RoleMetadataMutation)(nil)

// rolemetadataOption allows management of the mutation configuration using functional options.
type rolemetadataOption func(*RoleMetadataMutation)

// newRoleMetadataMutation creates new mutation for the RoleMetadata entity.
func newRoleMetadataMutation(c config, op Op, opts ...rolemetadataOption) *RoleMetadataMutation {
	m := &RoleMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleMetadataID sets the ID field of the mutation.
func withRoleMetadataID(id uint32) rolemetadataOption {
	return func(m *RoleMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleMetadata
		)
		m.oldValue = func(ctx context.Context) (*RoleMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleMetadata sets the old RoleMetadata of the mutation.
func withRoleMetadata(node *RoleMetadata) rolemetadataOption {
	return func(m *RoleMetadataMutation) {
		m.oldValue = func(context.Context) (*RoleMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoleMetadata entities.
func (m *RoleMetadataMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMetadataMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMetadataMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RoleMetadataMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[rolemetadata.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RoleMetadataMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMetadataMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, rolemetadata.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMetadataMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[rolemetadata.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMetadataMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, rolemetadata.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMetadataMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMetadataMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMetadataMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[rolemetadata.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMetadataMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMetadataMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, rolemetadata.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleMetadataMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleMetadataMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *RoleMetadataMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RoleMetadataMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RoleMetadataMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[rolemetadata.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RoleMetadataMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleMetadataMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, rolemetadata.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RoleMetadataMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RoleMetadataMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *RoleMetadataMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RoleMetadataMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RoleMetadataMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[rolemetadata.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RoleMetadataMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RoleMetadataMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, rolemetadata.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RoleMetadataMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RoleMetadataMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *RoleMetadataMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *RoleMetadataMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RoleMetadataMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[rolemetadata.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RoleMetadataMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RoleMetadataMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, rolemetadata.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *RoleMetadataMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RoleMetadataMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *RoleMetadataMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *RoleMetadataMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *RoleMetadataMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[rolemetadata.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *RoleMetadataMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RoleMetadataMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, rolemetadata.FieldTenantID)
}

// SetRoleID sets the "role_id" field.
func (m *RoleMetadataMutation) SetRoleID(u uint32) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleMetadataMutation) RoleID() (r uint32, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldRoleID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *RoleMetadataMutation) AddRoleID(u int32) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *RoleMetadataMutation) AddedRoleID() (r int32, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *RoleMetadataMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[rolemetadata.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *RoleMetadataMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleMetadataMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, rolemetadata.FieldRoleID)
}

// SetIsTemplate sets the "is_template" field.
func (m *RoleMetadataMutation) SetIsTemplate(b bool) {
	m.is_template = &b
}

// IsTemplate returns the value of the "is_template" field in the mutation.
func (m *RoleMetadataMutation) IsTemplate() (r bool, exists bool) {
	v := m.is_template
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTemplate returns the old "is_template" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldIsTemplate(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTemplate: %w", err)
	}
	return oldValue.IsTemplate, nil
}

// ClearIsTemplate clears the value of the "is_template" field.
func (m *RoleMetadataMutation) ClearIsTemplate() {
	m.is_template = nil
	m.clearedFields[rolemetadata.FieldIsTemplate] = struct{}{}
}

// IsTemplateCleared returns if the "is_template" field was cleared in this mutation.
func (m *RoleMetadataMutation) IsTemplateCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldIsTemplate]
	return ok
}

// ResetIsTemplate resets all changes to the "is_template" field.
func (m *RoleMetadataMutation) ResetIsTemplate() {
	m.is_template = nil
	delete(m.clearedFields, rolemetadata.FieldIsTemplate)
}

// SetTemplateFor sets the "template_for" field.
func (m *RoleMetadataMutation) SetTemplateFor(s string) {
	m.template_for = &s
}

// TemplateFor returns the value of the "template_for" field in the mutation.
func (m *RoleMetadataMutation) TemplateFor() (r string, exists bool) {
	v := m.template_for
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateFor returns the old "template_for" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldTemplateFor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateFor: %w", err)
	}
	return oldValue.TemplateFor, nil
}

// ClearTemplateFor clears the value of the "template_for" field.
func (m *RoleMetadataMutation) ClearTemplateFor() {
	m.template_for = nil
	m.clearedFields[rolemetadata.FieldTemplateFor] = struct{}{}
}

// TemplateForCleared returns if the "template_for" field was cleared in this mutation.
func (m *RoleMetadataMutation) TemplateForCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldTemplateFor]
	return ok
}

// ResetTemplateFor resets all changes to the "template_for" field.
func (m *RoleMetadataMutation) ResetTemplateFor() {
	m.template_for = nil
	delete(m.clearedFields, rolemetadata.FieldTemplateFor)
}

// SetTemplateVersion sets the "template_version" field.
func (m *RoleMetadataMutation) SetTemplateVersion(i int32) {
	m.template_version = &i
	m.addtemplate_version = nil
}

// TemplateVersion returns the value of the "template_version" field in the mutation.
func (m *RoleMetadataMutation) TemplateVersion() (r int32, exists bool) {
	v := m.template_version
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateVersion returns the old "template_version" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldTemplateVersion(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateVersion: %w", err)
	}
	return oldValue.TemplateVersion, nil
}

// AddTemplateVersion adds i to the "template_version" field.
func (m *RoleMetadataMutation) AddTemplateVersion(i int32) {
	if m.addtemplate_version != nil {
		*m.addtemplate_version += i
	} else {
		m.addtemplate_version = &i
	}
}

// AddedTemplateVersion returns the value that was added to the "template_version" field in this mutation.
func (m *RoleMetadataMutation) AddedTemplateVersion() (r int32, exists bool) {
	v := m.addtemplate_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearTemplateVersion clears the value of the "template_version" field.
func (m *RoleMetadataMutation) ClearTemplateVersion() {
	m.template_version = nil
	m.addtemplate_version = nil
	m.clearedFields[rolemetadata.FieldTemplateVersion] = struct{}{}
}

// TemplateVersionCleared returns if the "template_version" field was cleared in this mutation.
func (m *RoleMetadataMutation) TemplateVersionCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldTemplateVersion]
	return ok
}

// ResetTemplateVersion resets all changes to the "template_version" field.
func (m *RoleMetadataMutation) ResetTemplateVersion() {
	m.template_version = nil
	m.addtemplate_version = nil
	delete(m.clearedFields, rolemetadata.FieldTemplateVersion)
}

// SetLastSyncedVersion sets the "last_synced_version" field.
func (m *RoleMetadataMutation) SetLastSyncedVersion(i int32) {
	m.last_synced_version = &i
	m.addlast_synced_version = nil
}

// LastSyncedVersion returns the value of the "last_synced_version" field in the mutation.
func (m *RoleMetadataMutation) LastSyncedVersion() (r int32, exists bool) {
	v := m.last_synced_version
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncedVersion returns the old "last_synced_version" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldLastSyncedVersion(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncedVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncedVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncedVersion: %w", err)
	}
	return oldValue.LastSyncedVersion, nil
}

// AddLastSyncedVersion adds i to the "last_synced_version" field.
func (m *RoleMetadataMutation) AddLastSyncedVersion(i int32) {
	if m.addlast_synced_version != nil {
		*m.addlast_synced_version += i
	} else {
		m.addlast_synced_version = &i
	}
}

// AddedLastSyncedVersion returns the value that was added to the "last_synced_version" field in this mutation.
func (m *RoleMetadataMutation) AddedLastSyncedVersion() (r int32, exists bool) {
	v := m.addlast_synced_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastSyncedVersion clears the value of the "last_synced_version" field.
func (m *RoleMetadataMutation) ClearLastSyncedVersion() {
	m.last_synced_version = nil
	m.addlast_synced_version = nil
	m.clearedFields[rolemetadata.FieldLastSyncedVersion] = struct{}{}
}

// LastSyncedVersionCleared returns if the "last_synced_version" field was cleared in this mutation.
func (m *RoleMetadataMutation) LastSyncedVersionCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldLastSyncedVersion]
	return ok
}

// ResetLastSyncedVersion resets all changes to the "last_synced_version" field.
func (m *RoleMetadataMutation) ResetLastSyncedVersion() {
	m.last_synced_version = nil
	m.addlast_synced_version = nil
	delete(m.clearedFields, rolemetadata.FieldLastSyncedVersion)
}

// SetLastSyncedAt sets the "last_synced_at" field.
func (m *RoleMetadataMutation) SetLastSyncedAt(t time.Time) {
	m.last_synced_at = &t
}

// LastSyncedAt returns the value of the "last_synced_at" field in the mutation.
func (m *RoleMetadataMutation) LastSyncedAt() (r time.Time, exists bool) {
	v := m.last_synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncedAt returns the old "last_synced_at" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldLastSyncedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncedAt: %w", err)
	}
	return oldValue.LastSyncedAt, nil
}

// ClearLastSyncedAt clears the value of the "last_synced_at" field.
func (m *RoleMetadataMutation) ClearLastSyncedAt() {
	m.last_synced_at = nil
	m.clearedFields[rolemetadata.FieldLastSyncedAt] = struct{}{}
}

// LastSyncedAtCleared returns if the "last_synced_at" field was cleared in this mutation.
func (m *RoleMetadataMutation) LastSyncedAtCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldLastSyncedAt]
	return ok
}

// ResetLastSyncedAt resets all changes to the "last_synced_at" field.
func (m *RoleMetadataMutation) ResetLastSyncedAt() {
	m.last_synced_at = nil
	delete(m.clearedFields, rolemetadata.FieldLastSyncedAt)
}

// SetSyncPolicy sets the "sync_policy" field.
func (m *RoleMetadataMutation) SetSyncPolicy(rp rolemetadata.SyncPolicy) {
	m.sync_policy = &rp
}

// SyncPolicy returns the value of the "sync_policy" field in the mutation.
func (m *RoleMetadataMutation) SyncPolicy() (r rolemetadata.SyncPolicy, exists bool) {
	v := m.sync_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncPolicy returns the old "sync_policy" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldSyncPolicy(ctx context.Context) (v *rolemetadata.SyncPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncPolicy: %w", err)
	}
	return oldValue.SyncPolicy, nil
}

// ClearSyncPolicy clears the value of the "sync_policy" field.
func (m *RoleMetadataMutation) ClearSyncPolicy() {
	m.sync_policy = nil
	m.clearedFields[rolemetadata.FieldSyncPolicy] = struct{}{}
}

// SyncPolicyCleared returns if the "sync_policy" field was cleared in this mutation.
func (m *RoleMetadataMutation) SyncPolicyCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldSyncPolicy]
	return ok
}

// ResetSyncPolicy resets all changes to the "sync_policy" field.
func (m *RoleMetadataMutation) ResetSyncPolicy() {
	m.sync_policy = nil
	delete(m.clearedFields, rolemetadata.FieldSyncPolicy)
}

// SetScope sets the "scope" field.
func (m *RoleMetadataMutation) SetScope(r rolemetadata.Scope) {
	m.scope = &r
}

// Scope returns the value of the "scope" field in the mutation.
func (m *RoleMetadataMutation) Scope() (r rolemetadata.Scope, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldScope(ctx context.Context) (v *rolemetadata.Scope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ClearScope clears the value of the "scope" field.
func (m *RoleMetadataMutation) ClearScope() {
	m.scope = nil
	m.clearedFields[rolemetadata.FieldScope] = struct{}{}
}

// ScopeCleared returns if the "scope" field was cleared in this mutation.
func (m *RoleMetadataMutation) ScopeCleared() bool {
	_, ok := m.clearedFields[rolemetadata.FieldScope]
	return ok
}

// ResetScope resets all changes to the "scope" field.
func (m *RoleMetadataMutation) ResetScope() {
	m.scope = nil
	delete(m.clearedFields, rolemetadata.FieldScope)
}

// SetCustomOverrides sets the "custom_overrides" field.
func (m *RoleMetadataMutation) SetCustomOverrides(so *servicev1.RoleOverride) {
	m.custom_overrides = &so
}

// CustomOverrides returns the value of the "custom_overrides" field in the mutation.
func (m *RoleMetadataMutation) CustomOverrides() (r *servicev1.RoleOverride, exists bool) {
	v := m.custom_overrides
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomOverrides returns the old "custom_overrides" field's value of the RoleMetadata entity.
// If the RoleMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMetadataMutation) OldCustomOverrides(ctx context.Context) (v *servicev1.RoleOverride, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomOverrides is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomOverrides requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomOverrides: %w", err)
	}
	return oldValue.CustomOverrides, nil
}

// ResetCustomOverrides resets all changes to the "custom_overrides" field.
func (m *RoleMetadataMutation) ResetCustomOverrides() {
	m.custom_overrides = nil
}

// Where appends a list predicates to the RoleMetadataMutation builder.
func (m *RoleMetadataMutation) Where(ps ...predicate.RoleMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleMetadata).
func (m *RoleMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMetadataMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, rolemetadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rolemetadata.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rolemetadata.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, rolemetadata.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rolemetadata.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, rolemetadata.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, rolemetadata.FieldTenantID)
	}
	if m.role_id != nil {
		fields = append(fields, rolemetadata.FieldRoleID)
	}
	if m.is_template != nil {
		fields = append(fields, rolemetadata.FieldIsTemplate)
	}
	if m.template_for != nil {
		fields = append(fields, rolemetadata.FieldTemplateFor)
	}
	if m.template_version != nil {
		fields = append(fields, rolemetadata.FieldTemplateVersion)
	}
	if m.last_synced_version != nil {
		fields = append(fields, rolemetadata.FieldLastSyncedVersion)
	}
	if m.last_synced_at != nil {
		fields = append(fields, rolemetadata.FieldLastSyncedAt)
	}
	if m.sync_policy != nil {
		fields = append(fields, rolemetadata.FieldSyncPolicy)
	}
	if m.scope != nil {
		fields = append(fields, rolemetadata.FieldScope)
	}
	if m.custom_overrides != nil {
		fields = append(fields, rolemetadata.FieldCustomOverrides)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolemetadata.FieldCreatedAt:
		return m.CreatedAt()
	case rolemetadata.FieldUpdatedAt:
		return m.UpdatedAt()
	case rolemetadata.FieldDeletedAt:
		return m.DeletedAt()
	case rolemetadata.FieldCreatedBy:
		return m.CreatedBy()
	case rolemetadata.FieldUpdatedBy:
		return m.UpdatedBy()
	case rolemetadata.FieldDeletedBy:
		return m.DeletedBy()
	case rolemetadata.FieldTenantID:
		return m.TenantID()
	case rolemetadata.FieldRoleID:
		return m.RoleID()
	case rolemetadata.FieldIsTemplate:
		return m.IsTemplate()
	case rolemetadata.FieldTemplateFor:
		return m.TemplateFor()
	case rolemetadata.FieldTemplateVersion:
		return m.TemplateVersion()
	case rolemetadata.FieldLastSyncedVersion:
		return m.LastSyncedVersion()
	case rolemetadata.FieldLastSyncedAt:
		return m.LastSyncedAt()
	case rolemetadata.FieldSyncPolicy:
		return m.SyncPolicy()
	case rolemetadata.FieldScope:
		return m.Scope()
	case rolemetadata.FieldCustomOverrides:
		return m.CustomOverrides()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolemetadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rolemetadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rolemetadata.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rolemetadata.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rolemetadata.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rolemetadata.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case rolemetadata.FieldTenantID:
		return m.OldTenantID(ctx)
	case rolemetadata.FieldRoleID:
		return m.OldRoleID(ctx)
	case rolemetadata.FieldIsTemplate:
		return m.OldIsTemplate(ctx)
	case rolemetadata.FieldTemplateFor:
		return m.OldTemplateFor(ctx)
	case rolemetadata.FieldTemplateVersion:
		return m.OldTemplateVersion(ctx)
	case rolemetadata.FieldLastSyncedVersion:
		return m.OldLastSyncedVersion(ctx)
	case rolemetadata.FieldLastSyncedAt:
		return m.OldLastSyncedAt(ctx)
	case rolemetadata.FieldSyncPolicy:
		return m.OldSyncPolicy(ctx)
	case rolemetadata.FieldScope:
		return m.OldScope(ctx)
	case rolemetadata.FieldCustomOverrides:
		return m.OldCustomOverrides(ctx)
	}
	return nil, fmt.Errorf("unknown RoleMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolemetadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rolemetadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rolemetadata.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rolemetadata.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rolemetadata.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rolemetadata.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case rolemetadata.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case rolemetadata.FieldRoleID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case rolemetadata.FieldIsTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTemplate(v)
		return nil
	case rolemetadata.FieldTemplateFor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateFor(v)
		return nil
	case rolemetadata.FieldTemplateVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateVersion(v)
		return nil
	case rolemetadata.FieldLastSyncedVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncedVersion(v)
		return nil
	case rolemetadata.FieldLastSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncedAt(v)
		return nil
	case rolemetadata.FieldSyncPolicy:
		v, ok := value.(rolemetadata.SyncPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncPolicy(v)
		return nil
	case rolemetadata.FieldScope:
		v, ok := value.(rolemetadata.Scope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case rolemetadata.FieldCustomOverrides:
		v, ok := value.(*servicev1.RoleOverride)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomOverrides(v)
		return nil
	}
	return fmt.Errorf("unknown RoleMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMetadataMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rolemetadata.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rolemetadata.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, rolemetadata.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, rolemetadata.FieldTenantID)
	}
	if m.addrole_id != nil {
		fields = append(fields, rolemetadata.FieldRoleID)
	}
	if m.addtemplate_version != nil {
		fields = append(fields, rolemetadata.FieldTemplateVersion)
	}
	if m.addlast_synced_version != nil {
		fields = append(fields, rolemetadata.FieldLastSyncedVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rolemetadata.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rolemetadata.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rolemetadata.FieldDeletedBy:
		return m.AddedDeletedBy()
	case rolemetadata.FieldTenantID:
		return m.AddedTenantID()
	case rolemetadata.FieldRoleID:
		return m.AddedRoleID()
	case rolemetadata.FieldTemplateVersion:
		return m.AddedTemplateVersion()
	case rolemetadata.FieldLastSyncedVersion:
		return m.AddedLastSyncedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rolemetadata.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rolemetadata.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rolemetadata.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case rolemetadata.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case rolemetadata.FieldRoleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case rolemetadata.FieldTemplateVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemplateVersion(v)
		return nil
	case rolemetadata.FieldLastSyncedVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastSyncedVersion(v)
		return nil
	}
	return fmt.Errorf("unknown RoleMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rolemetadata.FieldCreatedAt) {
		fields = append(fields, rolemetadata.FieldCreatedAt)
	}
	if m.FieldCleared(rolemetadata.FieldUpdatedAt) {
		fields = append(fields, rolemetadata.FieldUpdatedAt)
	}
	if m.FieldCleared(rolemetadata.FieldDeletedAt) {
		fields = append(fields, rolemetadata.FieldDeletedAt)
	}
	if m.FieldCleared(rolemetadata.FieldCreatedBy) {
		fields = append(fields, rolemetadata.FieldCreatedBy)
	}
	if m.FieldCleared(rolemetadata.FieldUpdatedBy) {
		fields = append(fields, rolemetadata.FieldUpdatedBy)
	}
	if m.FieldCleared(rolemetadata.FieldDeletedBy) {
		fields = append(fields, rolemetadata.FieldDeletedBy)
	}
	if m.FieldCleared(rolemetadata.FieldTenantID) {
		fields = append(fields, rolemetadata.FieldTenantID)
	}
	if m.FieldCleared(rolemetadata.FieldRoleID) {
		fields = append(fields, rolemetadata.FieldRoleID)
	}
	if m.FieldCleared(rolemetadata.FieldIsTemplate) {
		fields = append(fields, rolemetadata.FieldIsTemplate)
	}
	if m.FieldCleared(rolemetadata.FieldTemplateFor) {
		fields = append(fields, rolemetadata.FieldTemplateFor)
	}
	if m.FieldCleared(rolemetadata.FieldTemplateVersion) {
		fields = append(fields, rolemetadata.FieldTemplateVersion)
	}
	if m.FieldCleared(rolemetadata.FieldLastSyncedVersion) {
		fields = append(fields, rolemetadata.FieldLastSyncedVersion)
	}
	if m.FieldCleared(rolemetadata.FieldLastSyncedAt) {
		fields = append(fields, rolemetadata.FieldLastSyncedAt)
	}
	if m.FieldCleared(rolemetadata.FieldSyncPolicy) {
		fields = append(fields, rolemetadata.FieldSyncPolicy)
	}
	if m.FieldCleared(rolemetadata.FieldScope) {
		fields = append(fields, rolemetadata.FieldScope)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMetadataMutation) ClearField(name string) error {
	switch name {
	case rolemetadata.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case rolemetadata.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case rolemetadata.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case rolemetadata.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case rolemetadata.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case rolemetadata.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case rolemetadata.FieldTenantID:
		m.ClearTenantID()
		return nil
	case rolemetadata.FieldRoleID:
		m.ClearRoleID()
		return nil
	case rolemetadata.FieldIsTemplate:
		m.ClearIsTemplate()
		return nil
	case rolemetadata.FieldTemplateFor:
		m.ClearTemplateFor()
		return nil
	case rolemetadata.FieldTemplateVersion:
		m.ClearTemplateVersion()
		return nil
	case rolemetadata.FieldLastSyncedVersion:
		m.ClearLastSyncedVersion()
		return nil
	case rolemetadata.FieldLastSyncedAt:
		m.ClearLastSyncedAt()
		return nil
	case rolemetadata.FieldSyncPolicy:
		m.ClearSyncPolicy()
		return nil
	case rolemetadata.FieldScope:
		m.ClearScope()
		return nil
	}
	return fmt.Errorf("unknown RoleMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMetadataMutation) ResetField(name string) error {
	switch name {
	case rolemetadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rolemetadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rolemetadata.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rolemetadata.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rolemetadata.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rolemetadata.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case rolemetadata.FieldTenantID:
		m.ResetTenantID()
		return nil
	case rolemetadata.FieldRoleID:
		m.ResetRoleID()
		return nil
	case rolemetadata.FieldIsTemplate:
		m.ResetIsTemplate()
		return nil
	case rolemetadata.FieldTemplateFor:
		m.ResetTemplateFor()
		return nil
	case rolemetadata.FieldTemplateVersion:
		m.ResetTemplateVersion()
		return nil
	case rolemetadata.FieldLastSyncedVersion:
		m.ResetLastSyncedVersion()
		return nil
	case rolemetadata.FieldLastSyncedAt:
		m.ResetLastSyncedAt()
		return nil
	case rolemetadata.FieldSyncPolicy:
		m.ResetSyncPolicy()
		return nil
	case rolemetadata.FieldScope:
		m.ResetScope()
		return nil
	case rolemetadata.FieldCustomOverrides:
		m.ResetCustomOverrides()
		return nil
	}
	return fmt.Errorf("unknown RoleMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMetadataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMetadataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMetadataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RoleMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMetadataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RoleMetadata edge %s", name)
}

// RolePermissionMutation represents an operation that mutates the RolePermission nodes in the graph.
type RolePermissionMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *uint32
	addcreated_by    *int32
	updated_by       *uint32
	addupdated_by    *int32
	deleted_by       *uint32
	adddeleted_by    *int32
	tenant_id        *uint32
	addtenant_id     *int32
	status           *rolepermission.Status
	role_id          *uint32
	addrole_id       *int32
	permission_id    *uint32
	addpermission_id *int32
	effect           *rolepermission.Effect
	priority         *int32
	addpriority      *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RolePermission, error)
	predicates       []predicate.RolePermission
}

var _ ent.Mutation = (*RolePermissionMutation)(nil)

// rolepermissionOption allows management of the mutation configuration using functional options.
type rolepermissionOption func(*RolePermissionMutation)

// newRolePermissionMutation creates new mutation for the RolePermission entity.
func newRolePermissionMutation(c config, op Op, opts ...rolepermissionOption) *RolePermissionMutation {
	m := &RolePermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeRolePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRolePermissionID sets the ID field of the mutation.
func withRolePermissionID(id uint32) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *RolePermission
		)
		m.oldValue = func(ctx context.Context) (*RolePermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RolePermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRolePermission sets the old RolePermission of the mutation.
func withRolePermission(node *RolePermission) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		m.oldValue = func(context.Context) (*RolePermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RolePermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RolePermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RolePermission entities.
func (m *RolePermissionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RolePermissionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RolePermissionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RolePermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RolePermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RolePermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RolePermissionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[rolepermission.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RolePermissionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RolePermissionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, rolepermission.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RolePermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RolePermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RolePermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[rolepermission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RolePermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RolePermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, rolepermission.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RolePermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RolePermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RolePermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[rolepermission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RolePermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RolePermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, rolepermission.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RolePermissionMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RolePermissionMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *RolePermissionMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RolePermissionMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RolePermissionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[rolepermission.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RolePermissionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RolePermissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, rolepermission.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RolePermissionMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RolePermissionMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *RolePermissionMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RolePermissionMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RolePermissionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[rolepermission.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RolePermissionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RolePermissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, rolepermission.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RolePermissionMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RolePermissionMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *RolePermissionMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *RolePermissionMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RolePermissionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[rolepermission.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RolePermissionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RolePermissionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, rolepermission.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *RolePermissionMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RolePermissionMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *RolePermissionMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *RolePermissionMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *RolePermissionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[rolepermission.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *RolePermissionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RolePermissionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, rolepermission.FieldTenantID)
}

// SetStatus sets the "status" field.
func (m *RolePermissionMutation) SetStatus(r rolepermission.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RolePermissionMutation) Status() (r rolepermission.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldStatus(ctx context.Context) (v *rolepermission.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RolePermissionMutation) ResetStatus() {
	m.status = nil
}

// SetRoleID sets the "role_id" field.
func (m *RolePermissionMutation) SetRoleID(u uint32) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RolePermissionMutation) RoleID() (r uint32, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldRoleID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *RolePermissionMutation) AddRoleID(u int32) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *RolePermissionMutation) AddedRoleID() (r int32, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RolePermissionMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetPermissionID sets the "permission_id" field.
func (m *RolePermissionMutation) SetPermissionID(u uint32) {
	m.permission_id = &u
	m.addpermission_id = nil
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *RolePermissionMutation) PermissionID() (r uint32, exists bool) {
	v := m.permission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldPermissionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// AddPermissionID adds u to the "permission_id" field.
func (m *RolePermissionMutation) AddPermissionID(u int32) {
	if m.addpermission_id != nil {
		*m.addpermission_id += u
	} else {
		m.addpermission_id = &u
	}
}

// AddedPermissionID returns the value that was added to the "permission_id" field in this mutation.
func (m *RolePermissionMutation) AddedPermissionID() (r int32, exists bool) {
	v := m.addpermission_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *RolePermissionMutation) ResetPermissionID() {
	m.permission_id = nil
	m.addpermission_id = nil
}

// SetEffect sets the "effect" field.
func (m *RolePermissionMutation) SetEffect(r rolepermission.Effect) {
	m.effect = &r
}

// Effect returns the value of the "effect" field in the mutation.
func (m *RolePermissionMutation) Effect() (r rolepermission.Effect, exists bool) {
	v := m.effect
	if v == nil {
		return
	}
	return *v, true
}

// OldEffect returns the old "effect" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldEffect(ctx context.Context) (v *rolepermission.Effect, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffect: %w", err)
	}
	return oldValue.Effect, nil
}

// ClearEffect clears the value of the "effect" field.
func (m *RolePermissionMutation) ClearEffect() {
	m.effect = nil
	m.clearedFields[rolepermission.FieldEffect] = struct{}{}
}

// EffectCleared returns if the "effect" field was cleared in this mutation.
func (m *RolePermissionMutation) EffectCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldEffect]
	return ok
}

// ResetEffect resets all changes to the "effect" field.
func (m *RolePermissionMutation) ResetEffect() {
	m.effect = nil
	delete(m.clearedFields, rolepermission.FieldEffect)
}

// SetPriority sets the "priority" field.
func (m *RolePermissionMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *RolePermissionMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldPriority(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *RolePermissionMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *RolePermissionMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *RolePermissionMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[rolepermission.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *RolePermissionMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *RolePermissionMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, rolepermission.FieldPriority)
}

// Where appends a list predicates to the RolePermissionMutation builder.
func (m *RolePermissionMutation) Where(ps ...predicate.RolePermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RolePermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RolePermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RolePermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RolePermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RolePermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RolePermission).
func (m *RolePermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RolePermissionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, rolepermission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rolepermission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rolepermission.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, rolepermission.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rolepermission.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, rolepermission.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, rolepermission.FieldTenantID)
	}
	if m.status != nil {
		fields = append(fields, rolepermission.FieldStatus)
	}
	if m.role_id != nil {
		fields = append(fields, rolepermission.FieldRoleID)
	}
	if m.permission_id != nil {
		fields = append(fields, rolepermission.FieldPermissionID)
	}
	if m.effect != nil {
		fields = append(fields, rolepermission.FieldEffect)
	}
	if m.priority != nil {
		fields = append(fields, rolepermission.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RolePermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolepermission.FieldCreatedAt:
		return m.CreatedAt()
	case rolepermission.FieldUpdatedAt:
		return m.UpdatedAt()
	case rolepermission.FieldDeletedAt:
		return m.DeletedAt()
	case rolepermission.FieldCreatedBy:
		return m.CreatedBy()
	case rolepermission.FieldUpdatedBy:
		return m.UpdatedBy()
	case rolepermission.FieldDeletedBy:
		return m.DeletedBy()
	case rolepermission.FieldTenantID:
		return m.TenantID()
	case rolepermission.FieldStatus:
		return m.Status()
	case rolepermission.FieldRoleID:
		return m.RoleID()
	case rolepermission.FieldPermissionID:
		return m.PermissionID()
	case rolepermission.FieldEffect:
		return m.Effect()
	case rolepermission.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RolePermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolepermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rolepermission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rolepermission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rolepermission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rolepermission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rolepermission.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case rolepermission.FieldTenantID:
		return m.OldTenantID(ctx)
	case rolepermission.FieldStatus:
		return m.OldStatus(ctx)
	case rolepermission.FieldRoleID:
		return m.OldRoleID(ctx)
	case rolepermission.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case rolepermission.FieldEffect:
		return m.OldEffect(ctx)
	case rolepermission.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown RolePermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolepermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rolepermission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rolepermission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rolepermission.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rolepermission.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rolepermission.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case rolepermission.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case rolepermission.FieldStatus:
		v, ok := value.(rolepermission.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rolepermission.FieldRoleID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case rolepermission.FieldPermissionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case rolepermission.FieldEffect:
		v, ok := value.(rolepermission.Effect)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffect(v)
		return nil
	case rolepermission.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RolePermissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, rolepermission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, rolepermission.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, rolepermission.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, rolepermission.FieldTenantID)
	}
	if m.addrole_id != nil {
		fields = append(fields, rolepermission.FieldRoleID)
	}
	if m.addpermission_id != nil {
		fields = append(fields, rolepermission.FieldPermissionID)
	}
	if m.addpriority != nil {
		fields = append(fields, rolepermission.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RolePermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rolepermission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case rolepermission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case rolepermission.FieldDeletedBy:
		return m.AddedDeletedBy()
	case rolepermission.FieldTenantID:
		return m.AddedTenantID()
	case rolepermission.FieldRoleID:
		return m.AddedRoleID()
	case rolepermission.FieldPermissionID:
		return m.AddedPermissionID()
	case rolepermission.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rolepermission.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case rolepermission.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case rolepermission.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case rolepermission.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case rolepermission.FieldRoleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case rolepermission.FieldPermissionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPermissionID(v)
		return nil
	case rolepermission.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown RolePermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RolePermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rolepermission.FieldCreatedAt) {
		fields = append(fields, rolepermission.FieldCreatedAt)
	}
	if m.FieldCleared(rolepermission.FieldUpdatedAt) {
		fields = append(fields, rolepermission.FieldUpdatedAt)
	}
	if m.FieldCleared(rolepermission.FieldDeletedAt) {
		fields = append(fields, rolepermission.FieldDeletedAt)
	}
	if m.FieldCleared(rolepermission.FieldCreatedBy) {
		fields = append(fields, rolepermission.FieldCreatedBy)
	}
	if m.FieldCleared(rolepermission.FieldUpdatedBy) {
		fields = append(fields, rolepermission.FieldUpdatedBy)
	}
	if m.FieldCleared(rolepermission.FieldDeletedBy) {
		fields = append(fields, rolepermission.FieldDeletedBy)
	}
	if m.FieldCleared(rolepermission.FieldTenantID) {
		fields = append(fields, rolepermission.FieldTenantID)
	}
	if m.FieldCleared(rolepermission.FieldEffect) {
		fields = append(fields, rolepermission.FieldEffect)
	}
	if m.FieldCleared(rolepermission.FieldPriority) {
		fields = append(fields, rolepermission.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RolePermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RolePermissionMutation) ClearField(name string) error {
	switch name {
	case rolepermission.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case rolepermission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case rolepermission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case rolepermission.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case rolepermission.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case rolepermission.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case rolepermission.FieldTenantID:
		m.ClearTenantID()
		return nil
	case rolepermission.FieldEffect:
		m.ClearEffect()
		return nil
	case rolepermission.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown RolePermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RolePermissionMutation) ResetField(name string) error {
	switch name {
	case rolepermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rolepermission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rolepermission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rolepermission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rolepermission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rolepermission.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case rolepermission.FieldTenantID:
		m.ResetTenantID()
		return nil
	case rolepermission.FieldStatus:
		m.ResetStatus()
		return nil
	case rolepermission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case rolepermission.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case rolepermission.FieldEffect:
		m.ResetEffect()
		return nil
	case rolepermission.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RolePermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RolePermissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RolePermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RolePermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RolePermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RolePermissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RolePermissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RolePermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RolePermissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RolePermission edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	updated_by    *uint32
	addupdated_by *int32
	deleted_by    *uint32
	adddeleted_by *int32
	remark        *string
	tenant_id     *uint32
	addtenant_id  *int32
	_type         *task.Type
	type_name     *string
	task_payload  *string
	cron_spec     *string
	task_options  **taskpb.TaskOption
	enable        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Task, error)
	predicates    []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uint32) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[task.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, task.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[task.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, task.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[task.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, task.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *TaskMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TaskMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[task.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, task.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *TaskMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TaskMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[task.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, task.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TaskMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TaskMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *TaskMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TaskMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TaskMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[task.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TaskMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TaskMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, task.FieldDeletedBy)
}

// SetRemark sets the "remark" field.
func (m *TaskMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TaskMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TaskMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[task.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TaskMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[task.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TaskMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, task.FieldRemark)
}

// SetTenantID sets the "tenant_id" field.
func (m *TaskMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TaskMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *TaskMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TaskMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TaskMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[task.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TaskMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[task.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TaskMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, task.FieldTenantID)
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(t task.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r task.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v *task.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *TaskMutation) ClearType() {
	m._type = nil
	m.clearedFields[task.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TaskMutation) TypeCleared() bool {
	_, ok := m.clearedFields[task.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, task.FieldType)
}

// SetTypeName sets the "type_name" field.
func (m *TaskMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *TaskMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTypeName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ClearTypeName clears the value of the "type_name" field.
func (m *TaskMutation) ClearTypeName() {
	m.type_name = nil
	m.clearedFields[task.FieldTypeName] = struct{}{}
}

// TypeNameCleared returns if the "type_name" field was cleared in this mutation.
func (m *TaskMutation) TypeNameCleared() bool {
	_, ok := m.clearedFields[task.FieldTypeName]
	return ok
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *TaskMutation) ResetTypeName() {
	m.type_name = nil
	delete(m.clearedFields, task.FieldTypeName)
}

// SetTaskPayload sets the "task_payload" field.
func (m *TaskMutation) SetTaskPayload(s string) {
	m.task_payload = &s
}

// TaskPayload returns the value of the "task_payload" field in the mutation.
func (m *TaskMutation) TaskPayload() (r string, exists bool) {
	v := m.task_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskPayload returns the old "task_payload" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskPayload(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskPayload: %w", err)
	}
	return oldValue.TaskPayload, nil
}

// ClearTaskPayload clears the value of the "task_payload" field.
func (m *TaskMutation) ClearTaskPayload() {
	m.task_payload = nil
	m.clearedFields[task.FieldTaskPayload] = struct{}{}
}

// TaskPayloadCleared returns if the "task_payload" field was cleared in this mutation.
func (m *TaskMutation) TaskPayloadCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskPayload]
	return ok
}

// ResetTaskPayload resets all changes to the "task_payload" field.
func (m *TaskMutation) ResetTaskPayload() {
	m.task_payload = nil
	delete(m.clearedFields, task.FieldTaskPayload)
}

// SetCronSpec sets the "cron_spec" field.
func (m *TaskMutation) SetCronSpec(s string) {
	m.cron_spec = &s
}

// CronSpec returns the value of the "cron_spec" field in the mutation.
func (m *TaskMutation) CronSpec() (r string, exists bool) {
	v := m.cron_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldCronSpec returns the old "cron_spec" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCronSpec(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCronSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCronSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCronSpec: %w", err)
	}
	return oldValue.CronSpec, nil
}

// ClearCronSpec clears the value of the "cron_spec" field.
func (m *TaskMutation) ClearCronSpec() {
	m.cron_spec = nil
	m.clearedFields[task.FieldCronSpec] = struct{}{}
}

// CronSpecCleared returns if the "cron_spec" field was cleared in this mutation.
func (m *TaskMutation) CronSpecCleared() bool {
	_, ok := m.clearedFields[task.FieldCronSpec]
	return ok
}

// ResetCronSpec resets all changes to the "cron_spec" field.
func (m *TaskMutation) ResetCronSpec() {
	m.cron_spec = nil
	delete(m.clearedFields, task.FieldCronSpec)
}

// SetTaskOptions sets the "task_options" field.
func (m *TaskMutation) SetTaskOptions(to *taskpb.TaskOption) {
	m.task_options = &to
}

// TaskOptions returns the value of the "task_options" field in the mutation.
func (m *TaskMutation) TaskOptions() (r *taskpb.TaskOption, exists bool) {
	v := m.task_options
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskOptions returns the old "task_options" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskOptions(ctx context.Context) (v *taskpb.TaskOption, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskOptions: %w", err)
	}
	return oldValue.TaskOptions, nil
}

// ClearTaskOptions clears the value of the "task_options" field.
func (m *TaskMutation) ClearTaskOptions() {
	m.task_options = nil
	m.clearedFields[task.FieldTaskOptions] = struct{}{}
}

// TaskOptionsCleared returns if the "task_options" field was cleared in this mutation.
func (m *TaskMutation) TaskOptionsCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskOptions]
	return ok
}

// ResetTaskOptions resets all changes to the "task_options" field.
func (m *TaskMutation) ResetTaskOptions() {
	m.task_options = nil
	delete(m.clearedFields, task.FieldTaskOptions)
}

// SetEnable sets the "enable" field.
func (m *TaskMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *TaskMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEnable(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ClearEnable clears the value of the "enable" field.
func (m *TaskMutation) ClearEnable() {
	m.enable = nil
	m.clearedFields[task.FieldEnable] = struct{}{}
}

// EnableCleared returns if the "enable" field was cleared in this mutation.
func (m *TaskMutation) EnableCleared() bool {
	_, ok := m.clearedFields[task.FieldEnable]
	return ok
}

// ResetEnable resets all changes to the "enable" field.
func (m *TaskMutation) ResetEnable() {
	m.enable = nil
	delete(m.clearedFields, task.FieldEnable)
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.remark != nil {
		fields = append(fields, task.FieldRemark)
	}
	if m.tenant_id != nil {
		fields = append(fields, task.FieldTenantID)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.type_name != nil {
		fields = append(fields, task.FieldTypeName)
	}
	if m.task_payload != nil {
		fields = append(fields, task.FieldTaskPayload)
	}
	if m.cron_spec != nil {
		fields = append(fields, task.FieldCronSpec)
	}
	if m.task_options != nil {
		fields = append(fields, task.FieldTaskOptions)
	}
	if m.enable != nil {
		fields = append(fields, task.FieldEnable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldDeletedAt:
		return m.DeletedAt()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldUpdatedBy:
		return m.UpdatedBy()
	case task.FieldDeletedBy:
		return m.DeletedBy()
	case task.FieldRemark:
		return m.Remark()
	case task.FieldTenantID:
		return m.TenantID()
	case task.FieldType:
		return m.GetType()
	case task.FieldTypeName:
		return m.TypeName()
	case task.FieldTaskPayload:
		return m.TaskPayload()
	case task.FieldCronSpec:
		return m.CronSpec()
	case task.FieldTaskOptions:
		return m.TaskOptions()
	case task.FieldEnable:
		return m.Enable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case task.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case task.FieldRemark:
		return m.OldRemark(ctx)
	case task.FieldTenantID:
		return m.OldTenantID(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldTypeName:
		return m.OldTypeName(ctx)
	case task.FieldTaskPayload:
		return m.OldTaskPayload(ctx)
	case task.FieldCronSpec:
		return m.OldCronSpec(ctx)
	case task.FieldTaskOptions:
		return m.OldTaskOptions(ctx)
	case task.FieldEnable:
		return m.OldEnable(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case task.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case task.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case task.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case task.FieldType:
		v, ok := value.(task.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case task.FieldTaskPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskPayload(v)
		return nil
	case task.FieldCronSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCronSpec(v)
		return nil
	case task.FieldTaskOptions:
		v, ok := value.(*taskpb.TaskOption)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskOptions(v)
		return nil
	case task.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, task.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedBy:
		return m.AddedCreatedBy()
	case task.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case task.FieldDeletedBy:
		return m.AddedDeletedBy()
	case task.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case task.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case task.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldCreatedAt) {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.FieldCleared(task.FieldUpdatedAt) {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.FieldCleared(task.FieldDeletedAt) {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.FieldCleared(task.FieldCreatedBy) {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.FieldCleared(task.FieldUpdatedBy) {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.FieldCleared(task.FieldDeletedBy) {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.FieldCleared(task.FieldRemark) {
		fields = append(fields, task.FieldRemark)
	}
	if m.FieldCleared(task.FieldTenantID) {
		fields = append(fields, task.FieldTenantID)
	}
	if m.FieldCleared(task.FieldType) {
		fields = append(fields, task.FieldType)
	}
	if m.FieldCleared(task.FieldTypeName) {
		fields = append(fields, task.FieldTypeName)
	}
	if m.FieldCleared(task.FieldTaskPayload) {
		fields = append(fields, task.FieldTaskPayload)
	}
	if m.FieldCleared(task.FieldCronSpec) {
		fields = append(fields, task.FieldCronSpec)
	}
	if m.FieldCleared(task.FieldTaskOptions) {
		fields = append(fields, task.FieldTaskOptions)
	}
	if m.FieldCleared(task.FieldEnable) {
		fields = append(fields, task.FieldEnable)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case task.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case task.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case task.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case task.FieldRemark:
		m.ClearRemark()
		return nil
	case task.FieldTenantID:
		m.ClearTenantID()
		return nil
	case task.FieldType:
		m.ClearType()
		return nil
	case task.FieldTypeName:
		m.ClearTypeName()
		return nil
	case task.FieldTaskPayload:
		m.ClearTaskPayload()
		return nil
	case task.FieldCronSpec:
		m.ClearCronSpec()
		return nil
	case task.FieldTaskOptions:
		m.ClearTaskOptions()
		return nil
	case task.FieldEnable:
		m.ClearEnable()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case task.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case task.FieldRemark:
		m.ResetRemark()
		return nil
	case task.FieldTenantID:
		m.ResetTenantID()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldTypeName:
		m.ResetTypeName()
		return nil
	case task.FieldTaskPayload:
		m.ResetTaskPayload()
		return nil
	case task.FieldCronSpec:
		m.ResetCronSpec()
		return nil
	case task.FieldTaskOptions:
		m.ResetTaskOptions()
		return nil
	case task.FieldEnable:
		m.ResetEnable()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	created_by        *uint32
	addcreated_by     *int32
	updated_by        *uint32
	addupdated_by     *int32
	deleted_by        *uint32
	adddeleted_by     *int32
	remark            *string
	name              *string
	code              *string
	logo_url          *string
	domain            *string
	industry          *string
	admin_user_id     *uint32
	addadmin_user_id  *int32
	status            *tenant.Status
	_type             *tenant.Type
	audit_status      *tenant.AuditStatus
	subscription_at   *time.Time
	unsubscribe_at    *time.Time
	subscription_plan *string
	expired_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Tenant, error)
	predicates        []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id uint32) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TenantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tenant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TenantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tenant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TenantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tenant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TenantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tenant.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TenantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TenantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TenantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tenant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TenantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TenantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tenant.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *TenantMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TenantMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[tenant.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, tenant.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *TenantMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TenantMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[tenant.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, tenant.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TenantMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TenantMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *TenantMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TenantMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TenantMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[tenant.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TenantMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TenantMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, tenant.FieldDeletedBy)
}

// SetRemark sets the "remark" field.
func (m *TenantMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TenantMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TenantMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[tenant.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TenantMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[tenant.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TenantMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, tenant.FieldRemark)
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TenantMutation) ClearName() {
	m.name = nil
	m.clearedFields[tenant.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TenantMutation) NameCleared() bool {
	_, ok := m.clearedFields[tenant.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, tenant.FieldName)
}

// SetCode sets the "code" field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *TenantMutation) ClearCode() {
	m.code = nil
	m.clearedFields[tenant.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *TenantMutation) CodeCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, tenant.FieldCode)
}

// SetLogoURL sets the "logo_url" field.
func (m *TenantMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *TenantMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldLogoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *TenantMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[tenant.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *TenantMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[tenant.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *TenantMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, tenant.FieldLogoURL)
}

// SetDomain sets the "domain" field.
func (m *TenantMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TenantMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDomain(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *TenantMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[tenant.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *TenantMutation) DomainCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *TenantMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, tenant.FieldDomain)
}

// SetIndustry sets the "industry" field.
func (m *TenantMutation) SetIndustry(s string) {
	m.industry = &s
}

// Industry returns the value of the "industry" field in the mutation.
func (m *TenantMutation) Industry() (r string, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldIndustry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ClearIndustry clears the value of the "industry" field.
func (m *TenantMutation) ClearIndustry() {
	m.industry = nil
	m.clearedFields[tenant.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *TenantMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[tenant.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *TenantMutation) ResetIndustry() {
	m.industry = nil
	delete(m.clearedFields, tenant.FieldIndustry)
}

// SetAdminUserID sets the "admin_user_id" field.
func (m *TenantMutation) SetAdminUserID(u uint32) {
	m.admin_user_id = &u
	m.addadmin_user_id = nil
}

// AdminUserID returns the value of the "admin_user_id" field in the mutation.
func (m *TenantMutation) AdminUserID() (r uint32, exists bool) {
	v := m.admin_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminUserID returns the old "admin_user_id" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldAdminUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminUserID: %w", err)
	}
	return oldValue.AdminUserID, nil
}

// AddAdminUserID adds u to the "admin_user_id" field.
func (m *TenantMutation) AddAdminUserID(u int32) {
	if m.addadmin_user_id != nil {
		*m.addadmin_user_id += u
	} else {
		m.addadmin_user_id = &u
	}
}

// AddedAdminUserID returns the value that was added to the "admin_user_id" field in this mutation.
func (m *TenantMutation) AddedAdminUserID() (r int32, exists bool) {
	v := m.addadmin_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAdminUserID clears the value of the "admin_user_id" field.
func (m *TenantMutation) ClearAdminUserID() {
	m.admin_user_id = nil
	m.addadmin_user_id = nil
	m.clearedFields[tenant.FieldAdminUserID] = struct{}{}
}

// AdminUserIDCleared returns if the "admin_user_id" field was cleared in this mutation.
func (m *TenantMutation) AdminUserIDCleared() bool {
	_, ok := m.clearedFields[tenant.FieldAdminUserID]
	return ok
}

// ResetAdminUserID resets all changes to the "admin_user_id" field.
func (m *TenantMutation) ResetAdminUserID() {
	m.admin_user_id = nil
	m.addadmin_user_id = nil
	delete(m.clearedFields, tenant.FieldAdminUserID)
}

// SetStatus sets the "status" field.
func (m *TenantMutation) SetStatus(t tenant.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantMutation) Status() (r tenant.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStatus(ctx context.Context) (v *tenant.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TenantMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[tenant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TenantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[tenant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, tenant.FieldStatus)
}

// SetType sets the "type" field.
func (m *TenantMutation) SetType(t tenant.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TenantMutation) GetType() (r tenant.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldType(ctx context.Context) (v *tenant.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *TenantMutation) ClearType() {
	m._type = nil
	m.clearedFields[tenant.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TenantMutation) TypeCleared() bool {
	_, ok := m.clearedFields[tenant.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TenantMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, tenant.FieldType)
}

// SetAuditStatus sets the "audit_status" field.
func (m *TenantMutation) SetAuditStatus(ts tenant.AuditStatus) {
	m.audit_status = &ts
}

// AuditStatus returns the value of the "audit_status" field in the mutation.
func (m *TenantMutation) AuditStatus() (r tenant.AuditStatus, exists bool) {
	v := m.audit_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditStatus returns the old "audit_status" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldAuditStatus(ctx context.Context) (v *tenant.AuditStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditStatus: %w", err)
	}
	return oldValue.AuditStatus, nil
}

// ClearAuditStatus clears the value of the "audit_status" field.
func (m *TenantMutation) ClearAuditStatus() {
	m.audit_status = nil
	m.clearedFields[tenant.FieldAuditStatus] = struct{}{}
}

// AuditStatusCleared returns if the "audit_status" field was cleared in this mutation.
func (m *TenantMutation) AuditStatusCleared() bool {
	_, ok := m.clearedFields[tenant.FieldAuditStatus]
	return ok
}

// ResetAuditStatus resets all changes to the "audit_status" field.
func (m *TenantMutation) ResetAuditStatus() {
	m.audit_status = nil
	delete(m.clearedFields, tenant.FieldAuditStatus)
}

// SetSubscriptionAt sets the "subscription_at" field.
func (m *TenantMutation) SetSubscriptionAt(t time.Time) {
	m.subscription_at = &t
}

// SubscriptionAt returns the value of the "subscription_at" field in the mutation.
func (m *TenantMutation) SubscriptionAt() (r time.Time, exists bool) {
	v := m.subscription_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionAt returns the old "subscription_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldSubscriptionAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionAt: %w", err)
	}
	return oldValue.SubscriptionAt, nil
}

// ClearSubscriptionAt clears the value of the "subscription_at" field.
func (m *TenantMutation) ClearSubscriptionAt() {
	m.subscription_at = nil
	m.clearedFields[tenant.FieldSubscriptionAt] = struct{}{}
}

// SubscriptionAtCleared returns if the "subscription_at" field was cleared in this mutation.
func (m *TenantMutation) SubscriptionAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldSubscriptionAt]
	return ok
}

// ResetSubscriptionAt resets all changes to the "subscription_at" field.
func (m *TenantMutation) ResetSubscriptionAt() {
	m.subscription_at = nil
	delete(m.clearedFields, tenant.FieldSubscriptionAt)
}

// SetUnsubscribeAt sets the "unsubscribe_at" field.
func (m *TenantMutation) SetUnsubscribeAt(t time.Time) {
	m.unsubscribe_at = &t
}

// UnsubscribeAt returns the value of the "unsubscribe_at" field in the mutation.
func (m *TenantMutation) UnsubscribeAt() (r time.Time, exists bool) {
	v := m.unsubscribe_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnsubscribeAt returns the old "unsubscribe_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUnsubscribeAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnsubscribeAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnsubscribeAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnsubscribeAt: %w", err)
	}
	return oldValue.UnsubscribeAt, nil
}

// ClearUnsubscribeAt clears the value of the "unsubscribe_at" field.
func (m *TenantMutation) ClearUnsubscribeAt() {
	m.unsubscribe_at = nil
	m.clearedFields[tenant.FieldUnsubscribeAt] = struct{}{}
}

// UnsubscribeAtCleared returns if the "unsubscribe_at" field was cleared in this mutation.
func (m *TenantMutation) UnsubscribeAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldUnsubscribeAt]
	return ok
}

// ResetUnsubscribeAt resets all changes to the "unsubscribe_at" field.
func (m *TenantMutation) ResetUnsubscribeAt() {
	m.unsubscribe_at = nil
	delete(m.clearedFields, tenant.FieldUnsubscribeAt)
}

// SetSubscriptionPlan sets the "subscription_plan" field.
func (m *TenantMutation) SetSubscriptionPlan(s string) {
	m.subscription_plan = &s
}

// SubscriptionPlan returns the value of the "subscription_plan" field in the mutation.
func (m *TenantMutation) SubscriptionPlan() (r string, exists bool) {
	v := m.subscription_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPlan returns the old "subscription_plan" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldSubscriptionPlan(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPlan: %w", err)
	}
	return oldValue.SubscriptionPlan, nil
}

// ClearSubscriptionPlan clears the value of the "subscription_plan" field.
func (m *TenantMutation) ClearSubscriptionPlan() {
	m.subscription_plan = nil
	m.clearedFields[tenant.FieldSubscriptionPlan] = struct{}{}
}

// SubscriptionPlanCleared returns if the "subscription_plan" field was cleared in this mutation.
func (m *TenantMutation) SubscriptionPlanCleared() bool {
	_, ok := m.clearedFields[tenant.FieldSubscriptionPlan]
	return ok
}

// ResetSubscriptionPlan resets all changes to the "subscription_plan" field.
func (m *TenantMutation) ResetSubscriptionPlan() {
	m.subscription_plan = nil
	delete(m.clearedFields, tenant.FieldSubscriptionPlan)
}

// SetExpiredAt sets the "expired_at" field.
func (m *TenantMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TenantMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *TenantMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[tenant.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *TenantMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TenantMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, tenant.FieldExpiredAt)
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, tenant.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	if m.remark != nil {
		fields = append(fields, tenant.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	if m.logo_url != nil {
		fields = append(fields, tenant.FieldLogoURL)
	}
	if m.domain != nil {
		fields = append(fields, tenant.FieldDomain)
	}
	if m.industry != nil {
		fields = append(fields, tenant.FieldIndustry)
	}
	if m.admin_user_id != nil {
		fields = append(fields, tenant.FieldAdminUserID)
	}
	if m.status != nil {
		fields = append(fields, tenant.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, tenant.FieldType)
	}
	if m.audit_status != nil {
		fields = append(fields, tenant.FieldAuditStatus)
	}
	if m.subscription_at != nil {
		fields = append(fields, tenant.FieldSubscriptionAt)
	}
	if m.unsubscribe_at != nil {
		fields = append(fields, tenant.FieldUnsubscribeAt)
	}
	if m.subscription_plan != nil {
		fields = append(fields, tenant.FieldSubscriptionPlan)
	}
	if m.expired_at != nil {
		fields = append(fields, tenant.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenant.FieldDeletedAt:
		return m.DeletedAt()
	case tenant.FieldCreatedBy:
		return m.CreatedBy()
	case tenant.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenant.FieldDeletedBy:
		return m.DeletedBy()
	case tenant.FieldRemark:
		return m.Remark()
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldCode:
		return m.Code()
	case tenant.FieldLogoURL:
		return m.LogoURL()
	case tenant.FieldDomain:
		return m.Domain()
	case tenant.FieldIndustry:
		return m.Industry()
	case tenant.FieldAdminUserID:
		return m.AdminUserID()
	case tenant.FieldStatus:
		return m.Status()
	case tenant.FieldType:
		return m.GetType()
	case tenant.FieldAuditStatus:
		return m.AuditStatus()
	case tenant.FieldSubscriptionAt:
		return m.SubscriptionAt()
	case tenant.FieldUnsubscribeAt:
		return m.UnsubscribeAt()
	case tenant.FieldSubscriptionPlan:
		return m.SubscriptionPlan()
	case tenant.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tenant.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenant.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenant.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case tenant.FieldRemark:
		return m.OldRemark(ctx)
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldCode:
		return m.OldCode(ctx)
	case tenant.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case tenant.FieldDomain:
		return m.OldDomain(ctx)
	case tenant.FieldIndustry:
		return m.OldIndustry(ctx)
	case tenant.FieldAdminUserID:
		return m.OldAdminUserID(ctx)
	case tenant.FieldStatus:
		return m.OldStatus(ctx)
	case tenant.FieldType:
		return m.OldType(ctx)
	case tenant.FieldAuditStatus:
		return m.OldAuditStatus(ctx)
	case tenant.FieldSubscriptionAt:
		return m.OldSubscriptionAt(ctx)
	case tenant.FieldUnsubscribeAt:
		return m.OldUnsubscribeAt(ctx)
	case tenant.FieldSubscriptionPlan:
		return m.OldSubscriptionPlan(ctx)
	case tenant.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tenant.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenant.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenant.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case tenant.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tenant.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case tenant.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tenant.FieldIndustry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case tenant.FieldAdminUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminUserID(v)
		return nil
	case tenant.FieldStatus:
		v, ok := value.(tenant.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenant.FieldType:
		v, ok := value.(tenant.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tenant.FieldAuditStatus:
		v, ok := value.(tenant.AuditStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditStatus(v)
		return nil
	case tenant.FieldSubscriptionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionAt(v)
		return nil
	case tenant.FieldUnsubscribeAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnsubscribeAt(v)
		return nil
	case tenant.FieldSubscriptionPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPlan(v)
		return nil
	case tenant.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, tenant.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	if m.addadmin_user_id != nil {
		fields = append(fields, tenant.FieldAdminUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCreatedBy:
		return m.AddedCreatedBy()
	case tenant.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case tenant.FieldDeletedBy:
		return m.AddedDeletedBy()
	case tenant.FieldAdminUserID:
		return m.AddedAdminUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case tenant.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case tenant.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case tenant.FieldAdminUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdminUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldCreatedAt) {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.FieldCleared(tenant.FieldUpdatedAt) {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	if m.FieldCleared(tenant.FieldDeletedAt) {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.FieldCleared(tenant.FieldCreatedBy) {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	if m.FieldCleared(tenant.FieldUpdatedBy) {
		fields = append(fields, tenant.FieldUpdatedBy)
	}
	if m.FieldCleared(tenant.FieldDeletedBy) {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	if m.FieldCleared(tenant.FieldRemark) {
		fields = append(fields, tenant.FieldRemark)
	}
	if m.FieldCleared(tenant.FieldName) {
		fields = append(fields, tenant.FieldName)
	}
	if m.FieldCleared(tenant.FieldCode) {
		fields = append(fields, tenant.FieldCode)
	}
	if m.FieldCleared(tenant.FieldLogoURL) {
		fields = append(fields, tenant.FieldLogoURL)
	}
	if m.FieldCleared(tenant.FieldDomain) {
		fields = append(fields, tenant.FieldDomain)
	}
	if m.FieldCleared(tenant.FieldIndustry) {
		fields = append(fields, tenant.FieldIndustry)
	}
	if m.FieldCleared(tenant.FieldAdminUserID) {
		fields = append(fields, tenant.FieldAdminUserID)
	}
	if m.FieldCleared(tenant.FieldStatus) {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.FieldCleared(tenant.FieldType) {
		fields = append(fields, tenant.FieldType)
	}
	if m.FieldCleared(tenant.FieldAuditStatus) {
		fields = append(fields, tenant.FieldAuditStatus)
	}
	if m.FieldCleared(tenant.FieldSubscriptionAt) {
		fields = append(fields, tenant.FieldSubscriptionAt)
	}
	if m.FieldCleared(tenant.FieldUnsubscribeAt) {
		fields = append(fields, tenant.FieldUnsubscribeAt)
	}
	if m.FieldCleared(tenant.FieldSubscriptionPlan) {
		fields = append(fields, tenant.FieldSubscriptionPlan)
	}
	if m.FieldCleared(tenant.FieldExpiredAt) {
		fields = append(fields, tenant.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tenant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tenant.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenant.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenant.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case tenant.FieldRemark:
		m.ClearRemark()
		return nil
	case tenant.FieldName:
		m.ClearName()
		return nil
	case tenant.FieldCode:
		m.ClearCode()
		return nil
	case tenant.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case tenant.FieldDomain:
		m.ClearDomain()
		return nil
	case tenant.FieldIndustry:
		m.ClearIndustry()
		return nil
	case tenant.FieldAdminUserID:
		m.ClearAdminUserID()
		return nil
	case tenant.FieldStatus:
		m.ClearStatus()
		return nil
	case tenant.FieldType:
		m.ClearType()
		return nil
	case tenant.FieldAuditStatus:
		m.ClearAuditStatus()
		return nil
	case tenant.FieldSubscriptionAt:
		m.ClearSubscriptionAt()
		return nil
	case tenant.FieldUnsubscribeAt:
		m.ClearUnsubscribeAt()
		return nil
	case tenant.FieldSubscriptionPlan:
		m.ClearSubscriptionPlan()
		return nil
	case tenant.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tenant.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenant.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenant.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case tenant.FieldRemark:
		m.ResetRemark()
		return nil
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	case tenant.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case tenant.FieldDomain:
		m.ResetDomain()
		return nil
	case tenant.FieldIndustry:
		m.ResetIndustry()
		return nil
	case tenant.FieldAdminUserID:
		m.ResetAdminUserID()
		return nil
	case tenant.FieldStatus:
		m.ResetStatus()
		return nil
	case tenant.FieldType:
		m.ResetType()
		return nil
	case tenant.FieldAuditStatus:
		m.ResetAuditStatus()
		return nil
	case tenant.FieldSubscriptionAt:
		m.ResetSubscriptionAt()
		return nil
	case tenant.FieldUnsubscribeAt:
		m.ResetUnsubscribeAt()
		return nil
	case tenant.FieldSubscriptionPlan:
		m.ResetSubscriptionPlan()
		return nil
	case tenant.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_by    *uint32
	addcreated_by *int32
	updated_by    *uint32
	addupdated_by *int32
	deleted_by    *uint32
	adddeleted_by *int32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	remark        *string
	tenant_id     *uint32
	addtenant_id  *int32
	username      *string
	nickname      *string
	realname      *string
	email         *string
	mobile        *string
	telephone     *string
	avatar        *string
	address       *string
	region        *string
	description   *string
	gender        *user.Gender
	last_login_at *time.Time
	last_login_ip *string
	locked_until  *time.Time
	status        *user.Status
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *UserMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[user.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, user.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[user.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, user.FieldDeletedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetRemark sets the "remark" field.
func (m *UserMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *UserMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *UserMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[user.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *UserMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[user.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *UserMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, user.FieldRemark)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *UserMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UserMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[user.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UserMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[user.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, user.FieldTenantID)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetRealname sets the "realname" field.
func (m *UserMutation) SetRealname(s string) {
	m.realname = &s
}

// Realname returns the value of the "realname" field in the mutation.
func (m *UserMutation) Realname() (r string, exists bool) {
	v := m.realname
	if v == nil {
		return
	}
	return *v, true
}

// OldRealname returns the old "realname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRealname(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealname: %w", err)
	}
	return oldValue.Realname, nil
}

// ClearRealname clears the value of the "realname" field.
func (m *UserMutation) ClearRealname() {
	m.realname = nil
	m.clearedFields[user.FieldRealname] = struct{}{}
}

// RealnameCleared returns if the "realname" field was cleared in this mutation.
func (m *UserMutation) RealnameCleared() bool {
	_, ok := m.clearedFields[user.FieldRealname]
	return ok
}

// ResetRealname resets all changes to the "realname" field.
func (m *UserMutation) ResetRealname() {
	m.realname = nil
	delete(m.clearedFields, user.FieldRealname)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *UserMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[user.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *UserMutation) MobileCleared() bool {
	_, ok := m.clearedFields[user.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, user.FieldMobile)
}

// SetTelephone sets the "telephone" field.
func (m *UserMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the value of the "telephone" field in the mutation.
func (m *UserMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old "telephone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTelephone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ClearTelephone clears the value of the "telephone" field.
func (m *UserMutation) ClearTelephone() {
	m.telephone = nil
	m.clearedFields[user.FieldTelephone] = struct{}{}
}

// TelephoneCleared returns if the "telephone" field was cleared in this mutation.
func (m *UserMutation) TelephoneCleared() bool {
	_, ok := m.clearedFields[user.FieldTelephone]
	return ok
}

// ResetTelephone resets all changes to the "telephone" field.
func (m *UserMutation) ResetTelephone() {
	m.telephone = nil
	delete(m.clearedFields, user.FieldTelephone)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *UserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[user.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *UserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[user.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, user.FieldAddress)
}

// SetRegion sets the "region" field.
func (m *UserMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *UserMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *UserMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[user.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *UserMutation) RegionCleared() bool {
	_, ok := m.clearedFields[user.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *UserMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, user.FieldRegion)
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[user.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[user.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, user.FieldDescription)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(u user.Gender) {
	m.gender = &u
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r user.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v *user.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIP(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[user.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, user.FieldLastLoginIP)
}

// SetLockedUntil sets the "locked_until" field.
func (m *UserMutation) SetLockedUntil(t time.Time) {
	m.locked_until = &t
}

// LockedUntil returns the value of the "locked_until" field in the mutation.
func (m *UserMutation) LockedUntil() (r time.Time, exists bool) {
	v := m.locked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedUntil returns the old "locked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedUntil: %w", err)
	}
	return oldValue.LockedUntil, nil
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (m *UserMutation) ClearLockedUntil() {
	m.locked_until = nil
	m.clearedFields[user.FieldLockedUntil] = struct{}{}
}

// LockedUntilCleared returns if the "locked_until" field was cleared in this mutation.
func (m *UserMutation) LockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldLockedUntil]
	return ok
}

// ResetLockedUntil resets all changes to the "locked_until" field.
func (m *UserMutation) ResetLockedUntil() {
	m.locked_until = nil
	delete(m.clearedFields, user.FieldLockedUntil)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v *user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, user.FieldStatus)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.remark != nil {
		fields = append(fields, user.FieldRemark)
	}
	if m.tenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.realname != nil {
		fields = append(fields, user.FieldRealname)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.telephone != nil {
		fields = append(fields, user.FieldTelephone)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.region != nil {
		fields = append(fields, user.FieldRegion)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.last_login_ip != nil {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.locked_until != nil {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldRemark:
		return m.Remark()
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldUsername:
		return m.Username()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldRealname:
		return m.Realname()
	case user.FieldEmail:
		return m.Email()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldTelephone:
		return m.Telephone()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldAddress:
		return m.Address()
	case user.FieldRegion:
		return m.Region()
	case user.FieldDescription:
		return m.Description()
	case user.FieldGender:
		return m.Gender()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldLastLoginIP:
		return m.LastLoginIP()
	case user.FieldLockedUntil:
		return m.LockedUntil()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldRemark:
		return m.OldRemark(ctx)
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldRealname:
		return m.OldRealname(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldTelephone:
		return m.OldTelephone(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldRegion:
		return m.OldRegion(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case user.FieldLockedUntil:
		return m.OldLockedUntil(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case user.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldRealname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealname(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case user.FieldGender:
		v, ok := value.(user.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case user.FieldLockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedUntil(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	case user.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case user.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedBy) {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldDeletedBy) {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldRemark) {
		fields = append(fields, user.FieldRemark)
	}
	if m.FieldCleared(user.FieldTenantID) {
		fields = append(fields, user.FieldTenantID)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldRealname) {
		fields = append(fields, user.FieldRealname)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldMobile) {
		fields = append(fields, user.FieldMobile)
	}
	if m.FieldCleared(user.FieldTelephone) {
		fields = append(fields, user.FieldTelephone)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldAddress) {
		fields = append(fields, user.FieldAddress)
	}
	if m.FieldCleared(user.FieldRegion) {
		fields = append(fields, user.FieldRegion)
	}
	if m.FieldCleared(user.FieldDescription) {
		fields = append(fields, user.FieldDescription)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldLastLoginIP) {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.FieldCleared(user.FieldLockedUntil) {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldRemark:
		m.ClearRemark()
		return nil
	case user.FieldTenantID:
		m.ClearTenantID()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldRealname:
		m.ClearRealname()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldMobile:
		m.ClearMobile()
		return nil
	case user.FieldTelephone:
		m.ClearTelephone()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldAddress:
		m.ClearAddress()
		return nil
	case user.FieldRegion:
		m.ClearRegion()
		return nil
	case user.FieldDescription:
		m.ClearDescription()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case user.FieldLockedUntil:
		m.ClearLockedUntil()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldRemark:
		m.ResetRemark()
		return nil
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldRealname:
		m.ResetRealname()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldTelephone:
		m.ResetTelephone()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldRegion:
		m.ResetRegion()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case user.FieldLockedUntil:
		m.ResetLockedUntil()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserCredentialMutation represents an operation that mutates the UserCredential nodes in the graph.
type UserCredentialMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	tenant_id                 *uint32
	addtenant_id              *int32
	user_id                   *uint32
	adduser_id                *int32
	identity_type             *usercredential.IdentityType
	identifier                *string
	credential_type           *usercredential.CredentialType
	credential                *string
	is_primary                *bool
	status                    *usercredential.Status
	extra_info                *string
	provider                  *string
	provider_account_id       *string
	activate_token_hash       *string
	activate_token_expires_at *time.Time
	activate_token_used_at    *time.Time
	reset_token_hash          *string
	reset_token_expires_at    *time.Time
	reset_token_used_at       *time.Time
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*UserCredential, error)
	predicates                []predicate.UserCredential
}

var _ ent.Mutation = (*UserCredentialMutation)(nil)

// usercredentialOption allows management of the mutation configuration using functional options.
type usercredentialOption func(*UserCredentialMutation)

// newUserCredentialMutation creates new mutation for the UserCredential entity.
func newUserCredentialMutation(c config, op Op, opts ...usercredentialOption) *UserCredentialMutation {
	m := &UserCredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCredentialID sets the ID field of the mutation.
func withUserCredentialID(id uint32) usercredentialOption {
	return func(m *UserCredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCredential
		)
		m.oldValue = func(ctx context.Context) (*UserCredential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCredential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCredential sets the old UserCredential of the mutation.
func withUserCredential(node *UserCredential) usercredentialOption {
	return func(m *UserCredentialMutation) {
		m.oldValue = func(context.Context) (*UserCredential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserCredential entities.
func (m *UserCredentialMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCredentialMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCredentialMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCredential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserCredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserCredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserCredentialMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usercredential.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserCredentialMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserCredentialMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usercredential.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserCredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserCredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserCredentialMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usercredential.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserCredentialMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserCredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usercredential.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserCredentialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserCredentialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserCredentialMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usercredential.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserCredentialMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserCredentialMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usercredential.FieldDeletedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserCredentialMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserCredentialMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *UserCredentialMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserCredentialMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UserCredentialMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[usercredential.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UserCredentialMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserCredentialMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, usercredential.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *UserCredentialMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserCredentialMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserCredentialMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserCredentialMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserCredentialMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[usercredential.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserCredentialMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserCredentialMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, usercredential.FieldUserID)
}

// SetIdentityType sets the "identity_type" field.
func (m *UserCredentialMutation) SetIdentityType(ut usercredential.IdentityType) {
	m.identity_type = &ut
}

// IdentityType returns the value of the "identity_type" field in the mutation.
func (m *UserCredentialMutation) IdentityType() (r usercredential.IdentityType, exists bool) {
	v := m.identity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityType returns the old "identity_type" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldIdentityType(ctx context.Context) (v *usercredential.IdentityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityType: %w", err)
	}
	return oldValue.IdentityType, nil
}

// ClearIdentityType clears the value of the "identity_type" field.
func (m *UserCredentialMutation) ClearIdentityType() {
	m.identity_type = nil
	m.clearedFields[usercredential.FieldIdentityType] = struct{}{}
}

// IdentityTypeCleared returns if the "identity_type" field was cleared in this mutation.
func (m *UserCredentialMutation) IdentityTypeCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldIdentityType]
	return ok
}

// ResetIdentityType resets all changes to the "identity_type" field.
func (m *UserCredentialMutation) ResetIdentityType() {
	m.identity_type = nil
	delete(m.clearedFields, usercredential.FieldIdentityType)
}

// SetIdentifier sets the "identifier" field.
func (m *UserCredentialMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *UserCredentialMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldIdentifier(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ClearIdentifier clears the value of the "identifier" field.
func (m *UserCredentialMutation) ClearIdentifier() {
	m.identifier = nil
	m.clearedFields[usercredential.FieldIdentifier] = struct{}{}
}

// IdentifierCleared returns if the "identifier" field was cleared in this mutation.
func (m *UserCredentialMutation) IdentifierCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldIdentifier]
	return ok
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *UserCredentialMutation) ResetIdentifier() {
	m.identifier = nil
	delete(m.clearedFields, usercredential.FieldIdentifier)
}

// SetCredentialType sets the "credential_type" field.
func (m *UserCredentialMutation) SetCredentialType(ut usercredential.CredentialType) {
	m.credential_type = &ut
}

// CredentialType returns the value of the "credential_type" field in the mutation.
func (m *UserCredentialMutation) CredentialType() (r usercredential.CredentialType, exists bool) {
	v := m.credential_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialType returns the old "credential_type" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldCredentialType(ctx context.Context) (v *usercredential.CredentialType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialType: %w", err)
	}
	return oldValue.CredentialType, nil
}

// ClearCredentialType clears the value of the "credential_type" field.
func (m *UserCredentialMutation) ClearCredentialType() {
	m.credential_type = nil
	m.clearedFields[usercredential.FieldCredentialType] = struct{}{}
}

// CredentialTypeCleared returns if the "credential_type" field was cleared in this mutation.
func (m *UserCredentialMutation) CredentialTypeCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldCredentialType]
	return ok
}

// ResetCredentialType resets all changes to the "credential_type" field.
func (m *UserCredentialMutation) ResetCredentialType() {
	m.credential_type = nil
	delete(m.clearedFields, usercredential.FieldCredentialType)
}

// SetCredential sets the "credential" field.
func (m *UserCredentialMutation) SetCredential(s string) {
	m.credential = &s
}

// Credential returns the value of the "credential" field in the mutation.
func (m *UserCredentialMutation) Credential() (r string, exists bool) {
	v := m.credential
	if v == nil {
		return
	}
	return *v, true
}

// OldCredential returns the old "credential" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldCredential(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredential is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredential requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredential: %w", err)
	}
	return oldValue.Credential, nil
}

// ClearCredential clears the value of the "credential" field.
func (m *UserCredentialMutation) ClearCredential() {
	m.credential = nil
	m.clearedFields[usercredential.FieldCredential] = struct{}{}
}

// CredentialCleared returns if the "credential" field was cleared in this mutation.
func (m *UserCredentialMutation) CredentialCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldCredential]
	return ok
}

// ResetCredential resets all changes to the "credential" field.
func (m *UserCredentialMutation) ResetCredential() {
	m.credential = nil
	delete(m.clearedFields, usercredential.FieldCredential)
}

// SetIsPrimary sets the "is_primary" field.
func (m *UserCredentialMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *UserCredentialMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ClearIsPrimary clears the value of the "is_primary" field.
func (m *UserCredentialMutation) ClearIsPrimary() {
	m.is_primary = nil
	m.clearedFields[usercredential.FieldIsPrimary] = struct{}{}
}

// IsPrimaryCleared returns if the "is_primary" field was cleared in this mutation.
func (m *UserCredentialMutation) IsPrimaryCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldIsPrimary]
	return ok
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *UserCredentialMutation) ResetIsPrimary() {
	m.is_primary = nil
	delete(m.clearedFields, usercredential.FieldIsPrimary)
}

// SetStatus sets the "status" field.
func (m *UserCredentialMutation) SetStatus(u usercredential.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserCredentialMutation) Status() (r usercredential.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldStatus(ctx context.Context) (v *usercredential.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserCredentialMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[usercredential.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserCredentialMutation) StatusCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserCredentialMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, usercredential.FieldStatus)
}

// SetExtraInfo sets the "extra_info" field.
func (m *UserCredentialMutation) SetExtraInfo(s string) {
	m.extra_info = &s
}

// ExtraInfo returns the value of the "extra_info" field in the mutation.
func (m *UserCredentialMutation) ExtraInfo() (r string, exists bool) {
	v := m.extra_info
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraInfo returns the old "extra_info" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldExtraInfo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraInfo: %w", err)
	}
	return oldValue.ExtraInfo, nil
}

// ClearExtraInfo clears the value of the "extra_info" field.
func (m *UserCredentialMutation) ClearExtraInfo() {
	m.extra_info = nil
	m.clearedFields[usercredential.FieldExtraInfo] = struct{}{}
}

// ExtraInfoCleared returns if the "extra_info" field was cleared in this mutation.
func (m *UserCredentialMutation) ExtraInfoCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldExtraInfo]
	return ok
}

// ResetExtraInfo resets all changes to the "extra_info" field.
func (m *UserCredentialMutation) ResetExtraInfo() {
	m.extra_info = nil
	delete(m.clearedFields, usercredential.FieldExtraInfo)
}

// SetProvider sets the "provider" field.
func (m *UserCredentialMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *UserCredentialMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldProvider(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *UserCredentialMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[usercredential.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *UserCredentialMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *UserCredentialMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, usercredential.FieldProvider)
}

// SetProviderAccountID sets the "provider_account_id" field.
func (m *UserCredentialMutation) SetProviderAccountID(s string) {
	m.provider_account_id = &s
}

// ProviderAccountID returns the value of the "provider_account_id" field in the mutation.
func (m *UserCredentialMutation) ProviderAccountID() (r string, exists bool) {
	v := m.provider_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderAccountID returns the old "provider_account_id" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldProviderAccountID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderAccountID: %w", err)
	}
	return oldValue.ProviderAccountID, nil
}

// ClearProviderAccountID clears the value of the "provider_account_id" field.
func (m *UserCredentialMutation) ClearProviderAccountID() {
	m.provider_account_id = nil
	m.clearedFields[usercredential.FieldProviderAccountID] = struct{}{}
}

// ProviderAccountIDCleared returns if the "provider_account_id" field was cleared in this mutation.
func (m *UserCredentialMutation) ProviderAccountIDCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldProviderAccountID]
	return ok
}

// ResetProviderAccountID resets all changes to the "provider_account_id" field.
func (m *UserCredentialMutation) ResetProviderAccountID() {
	m.provider_account_id = nil
	delete(m.clearedFields, usercredential.FieldProviderAccountID)
}

// SetActivateTokenHash sets the "activate_token_hash" field.
func (m *UserCredentialMutation) SetActivateTokenHash(s string) {
	m.activate_token_hash = &s
}

// ActivateTokenHash returns the value of the "activate_token_hash" field in the mutation.
func (m *UserCredentialMutation) ActivateTokenHash() (r string, exists bool) {
	v := m.activate_token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldActivateTokenHash returns the old "activate_token_hash" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldActivateTokenHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivateTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivateTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivateTokenHash: %w", err)
	}
	return oldValue.ActivateTokenHash, nil
}

// ClearActivateTokenHash clears the value of the "activate_token_hash" field.
func (m *UserCredentialMutation) ClearActivateTokenHash() {
	m.activate_token_hash = nil
	m.clearedFields[usercredential.FieldActivateTokenHash] = struct{}{}
}

// ActivateTokenHashCleared returns if the "activate_token_hash" field was cleared in this mutation.
func (m *UserCredentialMutation) ActivateTokenHashCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldActivateTokenHash]
	return ok
}

// ResetActivateTokenHash resets all changes to the "activate_token_hash" field.
func (m *UserCredentialMutation) ResetActivateTokenHash() {
	m.activate_token_hash = nil
	delete(m.clearedFields, usercredential.FieldActivateTokenHash)
}

// SetActivateTokenExpiresAt sets the "activate_token_expires_at" field.
func (m *UserCredentialMutation) SetActivateTokenExpiresAt(t time.Time) {
	m.activate_token_expires_at = &t
}

// ActivateTokenExpiresAt returns the value of the "activate_token_expires_at" field in the mutation.
func (m *UserCredentialMutation) ActivateTokenExpiresAt() (r time.Time, exists bool) {
	v := m.activate_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldActivateTokenExpiresAt returns the old "activate_token_expires_at" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldActivateTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivateTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivateTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivateTokenExpiresAt: %w", err)
	}
	return oldValue.ActivateTokenExpiresAt, nil
}

// ClearActivateTokenExpiresAt clears the value of the "activate_token_expires_at" field.
func (m *UserCredentialMutation) ClearActivateTokenExpiresAt() {
	m.activate_token_expires_at = nil
	m.clearedFields[usercredential.FieldActivateTokenExpiresAt] = struct{}{}
}

// ActivateTokenExpiresAtCleared returns if the "activate_token_expires_at" field was cleared in this mutation.
func (m *UserCredentialMutation) ActivateTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldActivateTokenExpiresAt]
	return ok
}

// ResetActivateTokenExpiresAt resets all changes to the "activate_token_expires_at" field.
func (m *UserCredentialMutation) ResetActivateTokenExpiresAt() {
	m.activate_token_expires_at = nil
	delete(m.clearedFields, usercredential.FieldActivateTokenExpiresAt)
}

// SetActivateTokenUsedAt sets the "activate_token_used_at" field.
func (m *UserCredentialMutation) SetActivateTokenUsedAt(t time.Time) {
	m.activate_token_used_at = &t
}

// ActivateTokenUsedAt returns the value of the "activate_token_used_at" field in the mutation.
func (m *UserCredentialMutation) ActivateTokenUsedAt() (r time.Time, exists bool) {
	v := m.activate_token_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldActivateTokenUsedAt returns the old "activate_token_used_at" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldActivateTokenUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivateTokenUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivateTokenUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivateTokenUsedAt: %w", err)
	}
	return oldValue.ActivateTokenUsedAt, nil
}

// ClearActivateTokenUsedAt clears the value of the "activate_token_used_at" field.
func (m *UserCredentialMutation) ClearActivateTokenUsedAt() {
	m.activate_token_used_at = nil
	m.clearedFields[usercredential.FieldActivateTokenUsedAt] = struct{}{}
}

// ActivateTokenUsedAtCleared returns if the "activate_token_used_at" field was cleared in this mutation.
func (m *UserCredentialMutation) ActivateTokenUsedAtCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldActivateTokenUsedAt]
	return ok
}

// ResetActivateTokenUsedAt resets all changes to the "activate_token_used_at" field.
func (m *UserCredentialMutation) ResetActivateTokenUsedAt() {
	m.activate_token_used_at = nil
	delete(m.clearedFields, usercredential.FieldActivateTokenUsedAt)
}

// SetResetTokenHash sets the "reset_token_hash" field.
func (m *UserCredentialMutation) SetResetTokenHash(s string) {
	m.reset_token_hash = &s
}

// ResetTokenHash returns the value of the "reset_token_hash" field in the mutation.
func (m *UserCredentialMutation) ResetTokenHash() (r string, exists bool) {
	v := m.reset_token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTokenHash returns the old "reset_token_hash" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldResetTokenHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTokenHash: %w", err)
	}
	return oldValue.ResetTokenHash, nil
}

// ClearResetTokenHash clears the value of the "reset_token_hash" field.
func (m *UserCredentialMutation) ClearResetTokenHash() {
	m.reset_token_hash = nil
	m.clearedFields[usercredential.FieldResetTokenHash] = struct{}{}
}

// ResetTokenHashCleared returns if the "reset_token_hash" field was cleared in this mutation.
func (m *UserCredentialMutation) ResetTokenHashCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldResetTokenHash]
	return ok
}

// ResetResetTokenHash resets all changes to the "reset_token_hash" field.
func (m *UserCredentialMutation) ResetResetTokenHash() {
	m.reset_token_hash = nil
	delete(m.clearedFields, usercredential.FieldResetTokenHash)
}

// SetResetTokenExpiresAt sets the "reset_token_expires_at" field.
func (m *UserCredentialMutation) SetResetTokenExpiresAt(t time.Time) {
	m.reset_token_expires_at = &t
}

// ResetTokenExpiresAt returns the value of the "reset_token_expires_at" field in the mutation.
func (m *UserCredentialMutation) ResetTokenExpiresAt() (r time.Time, exists bool) {
	v := m.reset_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTokenExpiresAt returns the old "reset_token_expires_at" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldResetTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTokenExpiresAt: %w", err)
	}
	return oldValue.ResetTokenExpiresAt, nil
}

// ClearResetTokenExpiresAt clears the value of the "reset_token_expires_at" field.
func (m *UserCredentialMutation) ClearResetTokenExpiresAt() {
	m.reset_token_expires_at = nil
	m.clearedFields[usercredential.FieldResetTokenExpiresAt] = struct{}{}
}

// ResetTokenExpiresAtCleared returns if the "reset_token_expires_at" field was cleared in this mutation.
func (m *UserCredentialMutation) ResetTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldResetTokenExpiresAt]
	return ok
}

// ResetResetTokenExpiresAt resets all changes to the "reset_token_expires_at" field.
func (m *UserCredentialMutation) ResetResetTokenExpiresAt() {
	m.reset_token_expires_at = nil
	delete(m.clearedFields, usercredential.FieldResetTokenExpiresAt)
}

// SetResetTokenUsedAt sets the "reset_token_used_at" field.
func (m *UserCredentialMutation) SetResetTokenUsedAt(t time.Time) {
	m.reset_token_used_at = &t
}

// ResetTokenUsedAt returns the value of the "reset_token_used_at" field in the mutation.
func (m *UserCredentialMutation) ResetTokenUsedAt() (r time.Time, exists bool) {
	v := m.reset_token_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTokenUsedAt returns the old "reset_token_used_at" field's value of the UserCredential entity.
// If the UserCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCredentialMutation) OldResetTokenUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTokenUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTokenUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTokenUsedAt: %w", err)
	}
	return oldValue.ResetTokenUsedAt, nil
}

// ClearResetTokenUsedAt clears the value of the "reset_token_used_at" field.
func (m *UserCredentialMutation) ClearResetTokenUsedAt() {
	m.reset_token_used_at = nil
	m.clearedFields[usercredential.FieldResetTokenUsedAt] = struct{}{}
}

// ResetTokenUsedAtCleared returns if the "reset_token_used_at" field was cleared in this mutation.
func (m *UserCredentialMutation) ResetTokenUsedAtCleared() bool {
	_, ok := m.clearedFields[usercredential.FieldResetTokenUsedAt]
	return ok
}

// ResetResetTokenUsedAt resets all changes to the "reset_token_used_at" field.
func (m *UserCredentialMutation) ResetResetTokenUsedAt() {
	m.reset_token_used_at = nil
	delete(m.clearedFields, usercredential.FieldResetTokenUsedAt)
}

// Where appends a list predicates to the UserCredentialMutation builder.
func (m *UserCredentialMutation) Where(ps ...predicate.UserCredential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCredential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCredential).
func (m *UserCredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCredentialMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, usercredential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usercredential.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usercredential.FieldDeletedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, usercredential.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, usercredential.FieldUserID)
	}
	if m.identity_type != nil {
		fields = append(fields, usercredential.FieldIdentityType)
	}
	if m.identifier != nil {
		fields = append(fields, usercredential.FieldIdentifier)
	}
	if m.credential_type != nil {
		fields = append(fields, usercredential.FieldCredentialType)
	}
	if m.credential != nil {
		fields = append(fields, usercredential.FieldCredential)
	}
	if m.is_primary != nil {
		fields = append(fields, usercredential.FieldIsPrimary)
	}
	if m.status != nil {
		fields = append(fields, usercredential.FieldStatus)
	}
	if m.extra_info != nil {
		fields = append(fields, usercredential.FieldExtraInfo)
	}
	if m.provider != nil {
		fields = append(fields, usercredential.FieldProvider)
	}
	if m.provider_account_id != nil {
		fields = append(fields, usercredential.FieldProviderAccountID)
	}
	if m.activate_token_hash != nil {
		fields = append(fields, usercredential.FieldActivateTokenHash)
	}
	if m.activate_token_expires_at != nil {
		fields = append(fields, usercredential.FieldActivateTokenExpiresAt)
	}
	if m.activate_token_used_at != nil {
		fields = append(fields, usercredential.FieldActivateTokenUsedAt)
	}
	if m.reset_token_hash != nil {
		fields = append(fields, usercredential.FieldResetTokenHash)
	}
	if m.reset_token_expires_at != nil {
		fields = append(fields, usercredential.FieldResetTokenExpiresAt)
	}
	if m.reset_token_used_at != nil {
		fields = append(fields, usercredential.FieldResetTokenUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercredential.FieldCreatedAt:
		return m.CreatedAt()
	case usercredential.FieldUpdatedAt:
		return m.UpdatedAt()
	case usercredential.FieldDeletedAt:
		return m.DeletedAt()
	case usercredential.FieldTenantID:
		return m.TenantID()
	case usercredential.FieldUserID:
		return m.UserID()
	case usercredential.FieldIdentityType:
		return m.IdentityType()
	case usercredential.FieldIdentifier:
		return m.Identifier()
	case usercredential.FieldCredentialType:
		return m.CredentialType()
	case usercredential.FieldCredential:
		return m.Credential()
	case usercredential.FieldIsPrimary:
		return m.IsPrimary()
	case usercredential.FieldStatus:
		return m.Status()
	case usercredential.FieldExtraInfo:
		return m.ExtraInfo()
	case usercredential.FieldProvider:
		return m.Provider()
	case usercredential.FieldProviderAccountID:
		return m.ProviderAccountID()
	case usercredential.FieldActivateTokenHash:
		return m.ActivateTokenHash()
	case usercredential.FieldActivateTokenExpiresAt:
		return m.ActivateTokenExpiresAt()
	case usercredential.FieldActivateTokenUsedAt:
		return m.ActivateTokenUsedAt()
	case usercredential.FieldResetTokenHash:
		return m.ResetTokenHash()
	case usercredential.FieldResetTokenExpiresAt:
		return m.ResetTokenExpiresAt()
	case usercredential.FieldResetTokenUsedAt:
		return m.ResetTokenUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercredential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usercredential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usercredential.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usercredential.FieldTenantID:
		return m.OldTenantID(ctx)
	case usercredential.FieldUserID:
		return m.OldUserID(ctx)
	case usercredential.FieldIdentityType:
		return m.OldIdentityType(ctx)
	case usercredential.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case usercredential.FieldCredentialType:
		return m.OldCredentialType(ctx)
	case usercredential.FieldCredential:
		return m.OldCredential(ctx)
	case usercredential.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case usercredential.FieldStatus:
		return m.OldStatus(ctx)
	case usercredential.FieldExtraInfo:
		return m.OldExtraInfo(ctx)
	case usercredential.FieldProvider:
		return m.OldProvider(ctx)
	case usercredential.FieldProviderAccountID:
		return m.OldProviderAccountID(ctx)
	case usercredential.FieldActivateTokenHash:
		return m.OldActivateTokenHash(ctx)
	case usercredential.FieldActivateTokenExpiresAt:
		return m.OldActivateTokenExpiresAt(ctx)
	case usercredential.FieldActivateTokenUsedAt:
		return m.OldActivateTokenUsedAt(ctx)
	case usercredential.FieldResetTokenHash:
		return m.OldResetTokenHash(ctx)
	case usercredential.FieldResetTokenExpiresAt:
		return m.OldResetTokenExpiresAt(ctx)
	case usercredential.FieldResetTokenUsedAt:
		return m.OldResetTokenUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserCredential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercredential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usercredential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usercredential.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usercredential.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case usercredential.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercredential.FieldIdentityType:
		v, ok := value.(usercredential.IdentityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityType(v)
		return nil
	case usercredential.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case usercredential.FieldCredentialType:
		v, ok := value.(usercredential.CredentialType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialType(v)
		return nil
	case usercredential.FieldCredential:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredential(v)
		return nil
	case usercredential.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case usercredential.FieldStatus:
		v, ok := value.(usercredential.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usercredential.FieldExtraInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraInfo(v)
		return nil
	case usercredential.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case usercredential.FieldProviderAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderAccountID(v)
		return nil
	case usercredential.FieldActivateTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivateTokenHash(v)
		return nil
	case usercredential.FieldActivateTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivateTokenExpiresAt(v)
		return nil
	case usercredential.FieldActivateTokenUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivateTokenUsedAt(v)
		return nil
	case usercredential.FieldResetTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTokenHash(v)
		return nil
	case usercredential.FieldResetTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTokenExpiresAt(v)
		return nil
	case usercredential.FieldResetTokenUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTokenUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCredential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCredentialMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, usercredential.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, usercredential.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usercredential.FieldTenantID:
		return m.AddedTenantID()
	case usercredential.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usercredential.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case usercredential.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserCredential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usercredential.FieldCreatedAt) {
		fields = append(fields, usercredential.FieldCreatedAt)
	}
	if m.FieldCleared(usercredential.FieldUpdatedAt) {
		fields = append(fields, usercredential.FieldUpdatedAt)
	}
	if m.FieldCleared(usercredential.FieldDeletedAt) {
		fields = append(fields, usercredential.FieldDeletedAt)
	}
	if m.FieldCleared(usercredential.FieldTenantID) {
		fields = append(fields, usercredential.FieldTenantID)
	}
	if m.FieldCleared(usercredential.FieldUserID) {
		fields = append(fields, usercredential.FieldUserID)
	}
	if m.FieldCleared(usercredential.FieldIdentityType) {
		fields = append(fields, usercredential.FieldIdentityType)
	}
	if m.FieldCleared(usercredential.FieldIdentifier) {
		fields = append(fields, usercredential.FieldIdentifier)
	}
	if m.FieldCleared(usercredential.FieldCredentialType) {
		fields = append(fields, usercredential.FieldCredentialType)
	}
	if m.FieldCleared(usercredential.FieldCredential) {
		fields = append(fields, usercredential.FieldCredential)
	}
	if m.FieldCleared(usercredential.FieldIsPrimary) {
		fields = append(fields, usercredential.FieldIsPrimary)
	}
	if m.FieldCleared(usercredential.FieldStatus) {
		fields = append(fields, usercredential.FieldStatus)
	}
	if m.FieldCleared(usercredential.FieldExtraInfo) {
		fields = append(fields, usercredential.FieldExtraInfo)
	}
	if m.FieldCleared(usercredential.FieldProvider) {
		fields = append(fields, usercredential.FieldProvider)
	}
	if m.FieldCleared(usercredential.FieldProviderAccountID) {
		fields = append(fields, usercredential.FieldProviderAccountID)
	}
	if m.FieldCleared(usercredential.FieldActivateTokenHash) {
		fields = append(fields, usercredential.FieldActivateTokenHash)
	}
	if m.FieldCleared(usercredential.FieldActivateTokenExpiresAt) {
		fields = append(fields, usercredential.FieldActivateTokenExpiresAt)
	}
	if m.FieldCleared(usercredential.FieldActivateTokenUsedAt) {
		fields = append(fields, usercredential.FieldActivateTokenUsedAt)
	}
	if m.FieldCleared(usercredential.FieldResetTokenHash) {
		fields = append(fields, usercredential.FieldResetTokenHash)
	}
	if m.FieldCleared(usercredential.FieldResetTokenExpiresAt) {
		fields = append(fields, usercredential.FieldResetTokenExpiresAt)
	}
	if m.FieldCleared(usercredential.FieldResetTokenUsedAt) {
		fields = append(fields, usercredential.FieldResetTokenUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCredentialMutation) ClearField(name string) error {
	switch name {
	case usercredential.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usercredential.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case usercredential.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usercredential.FieldTenantID:
		m.ClearTenantID()
		return nil
	case usercredential.FieldUserID:
		m.ClearUserID()
		return nil
	case usercredential.FieldIdentityType:
		m.ClearIdentityType()
		return nil
	case usercredential.FieldIdentifier:
		m.ClearIdentifier()
		return nil
	case usercredential.FieldCredentialType:
		m.ClearCredentialType()
		return nil
	case usercredential.FieldCredential:
		m.ClearCredential()
		return nil
	case usercredential.FieldIsPrimary:
		m.ClearIsPrimary()
		return nil
	case usercredential.FieldStatus:
		m.ClearStatus()
		return nil
	case usercredential.FieldExtraInfo:
		m.ClearExtraInfo()
		return nil
	case usercredential.FieldProvider:
		m.ClearProvider()
		return nil
	case usercredential.FieldProviderAccountID:
		m.ClearProviderAccountID()
		return nil
	case usercredential.FieldActivateTokenHash:
		m.ClearActivateTokenHash()
		return nil
	case usercredential.FieldActivateTokenExpiresAt:
		m.ClearActivateTokenExpiresAt()
		return nil
	case usercredential.FieldActivateTokenUsedAt:
		m.ClearActivateTokenUsedAt()
		return nil
	case usercredential.FieldResetTokenHash:
		m.ClearResetTokenHash()
		return nil
	case usercredential.FieldResetTokenExpiresAt:
		m.ClearResetTokenExpiresAt()
		return nil
	case usercredential.FieldResetTokenUsedAt:
		m.ClearResetTokenUsedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCredential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCredentialMutation) ResetField(name string) error {
	switch name {
	case usercredential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usercredential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usercredential.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usercredential.FieldTenantID:
		m.ResetTenantID()
		return nil
	case usercredential.FieldUserID:
		m.ResetUserID()
		return nil
	case usercredential.FieldIdentityType:
		m.ResetIdentityType()
		return nil
	case usercredential.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case usercredential.FieldCredentialType:
		m.ResetCredentialType()
		return nil
	case usercredential.FieldCredential:
		m.ResetCredential()
		return nil
	case usercredential.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case usercredential.FieldStatus:
		m.ResetStatus()
		return nil
	case usercredential.FieldExtraInfo:
		m.ResetExtraInfo()
		return nil
	case usercredential.FieldProvider:
		m.ResetProvider()
		return nil
	case usercredential.FieldProviderAccountID:
		m.ResetProviderAccountID()
		return nil
	case usercredential.FieldActivateTokenHash:
		m.ResetActivateTokenHash()
		return nil
	case usercredential.FieldActivateTokenExpiresAt:
		m.ResetActivateTokenExpiresAt()
		return nil
	case usercredential.FieldActivateTokenUsedAt:
		m.ResetActivateTokenUsedAt()
		return nil
	case usercredential.FieldResetTokenHash:
		m.ResetResetTokenHash()
		return nil
	case usercredential.FieldResetTokenExpiresAt:
		m.ResetResetTokenExpiresAt()
		return nil
	case usercredential.FieldResetTokenUsedAt:
		m.ResetResetTokenUsedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCredential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCredentialMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCredentialMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCredentialMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserCredential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCredentialMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserCredential edge %s", name)
}

// UserOrgUnitMutation represents an operation that mutates the UserOrgUnit nodes in the graph.
type UserOrgUnitMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	created_by     *uint32
	addcreated_by  *int32
	updated_by     *uint32
	addupdated_by  *int32
	deleted_by     *uint32
	adddeleted_by  *int32
	tenant_id      *uint32
	addtenant_id   *int32
	remark         *string
	user_id        *uint32
	adduser_id     *int32
	org_unit_id    *uint32
	addorg_unit_id *int32
	position_id    *uint32
	addposition_id *int32
	start_at       *time.Time
	end_at         *time.Time
	assigned_at    *time.Time
	assigned_by    *uint32
	addassigned_by *int32
	is_primary     *bool
	status         *userorgunit.Status
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UserOrgUnit, error)
	predicates     []predicate.UserOrgUnit
}

var _ ent.Mutation = (*UserOrgUnitMutation)(nil)

// userorgunitOption allows management of the mutation configuration using functional options.
type userorgunitOption func(*UserOrgUnitMutation)

// newUserOrgUnitMutation creates new mutation for the UserOrgUnit entity.
func newUserOrgUnitMutation(c config, op Op, opts ...userorgunitOption) *UserOrgUnitMutation {
	m := &UserOrgUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeUserOrgUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserOrgUnitID sets the ID field of the mutation.
func withUserOrgUnitID(id uint32) userorgunitOption {
	return func(m *UserOrgUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *UserOrgUnit
		)
		m.oldValue = func(ctx context.Context) (*UserOrgUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserOrgUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserOrgUnit sets the old UserOrgUnit of the mutation.
func withUserOrgUnit(node *UserOrgUnit) userorgunitOption {
	return func(m *UserOrgUnitMutation) {
		m.oldValue = func(context.Context) (*UserOrgUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserOrgUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserOrgUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserOrgUnit entities.
func (m *UserOrgUnitMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserOrgUnitMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserOrgUnitMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserOrgUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserOrgUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserOrgUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserOrgUnitMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userorgunit.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserOrgUnitMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserOrgUnitMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userorgunit.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserOrgUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserOrgUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserOrgUnitMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userorgunit.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserOrgUnitMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserOrgUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userorgunit.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserOrgUnitMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserOrgUnitMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserOrgUnitMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userorgunit.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserOrgUnitMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserOrgUnitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userorgunit.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserOrgUnitMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserOrgUnitMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *UserOrgUnitMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserOrgUnitMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserOrgUnitMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[userorgunit.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserOrgUnitMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserOrgUnitMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, userorgunit.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserOrgUnitMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserOrgUnitMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *UserOrgUnitMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserOrgUnitMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserOrgUnitMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userorgunit.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserOrgUnitMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserOrgUnitMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userorgunit.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserOrgUnitMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserOrgUnitMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *UserOrgUnitMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserOrgUnitMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserOrgUnitMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[userorgunit.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserOrgUnitMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserOrgUnitMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, userorgunit.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserOrgUnitMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserOrgUnitMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *UserOrgUnitMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserOrgUnitMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UserOrgUnitMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[userorgunit.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UserOrgUnitMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserOrgUnitMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, userorgunit.FieldTenantID)
}

// SetRemark sets the "remark" field.
func (m *UserOrgUnitMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *UserOrgUnitMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *UserOrgUnitMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[userorgunit.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *UserOrgUnitMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *UserOrgUnitMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, userorgunit.FieldRemark)
}

// SetUserID sets the "user_id" field.
func (m *UserOrgUnitMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserOrgUnitMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserOrgUnitMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserOrgUnitMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserOrgUnitMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOrgUnitID sets the "org_unit_id" field.
func (m *UserOrgUnitMutation) SetOrgUnitID(u uint32) {
	m.org_unit_id = &u
	m.addorg_unit_id = nil
}

// OrgUnitID returns the value of the "org_unit_id" field in the mutation.
func (m *UserOrgUnitMutation) OrgUnitID() (r uint32, exists bool) {
	v := m.org_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitID returns the old "org_unit_id" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldOrgUnitID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitID: %w", err)
	}
	return oldValue.OrgUnitID, nil
}

// AddOrgUnitID adds u to the "org_unit_id" field.
func (m *UserOrgUnitMutation) AddOrgUnitID(u int32) {
	if m.addorg_unit_id != nil {
		*m.addorg_unit_id += u
	} else {
		m.addorg_unit_id = &u
	}
}

// AddedOrgUnitID returns the value that was added to the "org_unit_id" field in this mutation.
func (m *UserOrgUnitMutation) AddedOrgUnitID() (r int32, exists bool) {
	v := m.addorg_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgUnitID resets all changes to the "org_unit_id" field.
func (m *UserOrgUnitMutation) ResetOrgUnitID() {
	m.org_unit_id = nil
	m.addorg_unit_id = nil
}

// SetPositionID sets the "position_id" field.
func (m *UserOrgUnitMutation) SetPositionID(u uint32) {
	m.position_id = &u
	m.addposition_id = nil
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *UserOrgUnitMutation) PositionID() (r uint32, exists bool) {
	v := m.position_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldPositionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// AddPositionID adds u to the "position_id" field.
func (m *UserOrgUnitMutation) AddPositionID(u int32) {
	if m.addposition_id != nil {
		*m.addposition_id += u
	} else {
		m.addposition_id = &u
	}
}

// AddedPositionID returns the value that was added to the "position_id" field in this mutation.
func (m *UserOrgUnitMutation) AddedPositionID() (r int32, exists bool) {
	v := m.addposition_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPositionID clears the value of the "position_id" field.
func (m *UserOrgUnitMutation) ClearPositionID() {
	m.position_id = nil
	m.addposition_id = nil
	m.clearedFields[userorgunit.FieldPositionID] = struct{}{}
}

// PositionIDCleared returns if the "position_id" field was cleared in this mutation.
func (m *UserOrgUnitMutation) PositionIDCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldPositionID]
	return ok
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *UserOrgUnitMutation) ResetPositionID() {
	m.position_id = nil
	m.addposition_id = nil
	delete(m.clearedFields, userorgunit.FieldPositionID)
}

// SetStartAt sets the "start_at" field.
func (m *UserOrgUnitMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *UserOrgUnitMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *UserOrgUnitMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[userorgunit.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *UserOrgUnitMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *UserOrgUnitMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, userorgunit.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *UserOrgUnitMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *UserOrgUnitMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *UserOrgUnitMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[userorgunit.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *UserOrgUnitMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *UserOrgUnitMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, userorgunit.FieldEndAt)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserOrgUnitMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserOrgUnitMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ClearAssignedAt clears the value of the "assigned_at" field.
func (m *UserOrgUnitMutation) ClearAssignedAt() {
	m.assigned_at = nil
	m.clearedFields[userorgunit.FieldAssignedAt] = struct{}{}
}

// AssignedAtCleared returns if the "assigned_at" field was cleared in this mutation.
func (m *UserOrgUnitMutation) AssignedAtCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldAssignedAt]
	return ok
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserOrgUnitMutation) ResetAssignedAt() {
	m.assigned_at = nil
	delete(m.clearedFields, userorgunit.FieldAssignedAt)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserOrgUnitMutation) SetAssignedBy(u uint32) {
	m.assigned_by = &u
	m.addassigned_by = nil
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserOrgUnitMutation) AssignedBy() (r uint32, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldAssignedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// AddAssignedBy adds u to the "assigned_by" field.
func (m *UserOrgUnitMutation) AddAssignedBy(u int32) {
	if m.addassigned_by != nil {
		*m.addassigned_by += u
	} else {
		m.addassigned_by = &u
	}
}

// AddedAssignedBy returns the value that was added to the "assigned_by" field in this mutation.
func (m *UserOrgUnitMutation) AddedAssignedBy() (r int32, exists bool) {
	v := m.addassigned_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserOrgUnitMutation) ClearAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	m.clearedFields[userorgunit.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserOrgUnitMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserOrgUnitMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	delete(m.clearedFields, userorgunit.FieldAssignedBy)
}

// SetIsPrimary sets the "is_primary" field.
func (m *UserOrgUnitMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *UserOrgUnitMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *UserOrgUnitMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetStatus sets the "status" field.
func (m *UserOrgUnitMutation) SetStatus(u userorgunit.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserOrgUnitMutation) Status() (r userorgunit.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserOrgUnit entity.
// If the UserOrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOrgUnitMutation) OldStatus(ctx context.Context) (v *userorgunit.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserOrgUnitMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[userorgunit.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserOrgUnitMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userorgunit.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserOrgUnitMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, userorgunit.FieldStatus)
}

// Where appends a list predicates to the UserOrgUnitMutation builder.
func (m *UserOrgUnitMutation) Where(ps ...predicate.UserOrgUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserOrgUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserOrgUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserOrgUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserOrgUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserOrgUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserOrgUnit).
func (m *UserOrgUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserOrgUnitMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, userorgunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userorgunit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userorgunit.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userorgunit.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userorgunit.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, userorgunit.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, userorgunit.FieldTenantID)
	}
	if m.remark != nil {
		fields = append(fields, userorgunit.FieldRemark)
	}
	if m.user_id != nil {
		fields = append(fields, userorgunit.FieldUserID)
	}
	if m.org_unit_id != nil {
		fields = append(fields, userorgunit.FieldOrgUnitID)
	}
	if m.position_id != nil {
		fields = append(fields, userorgunit.FieldPositionID)
	}
	if m.start_at != nil {
		fields = append(fields, userorgunit.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, userorgunit.FieldEndAt)
	}
	if m.assigned_at != nil {
		fields = append(fields, userorgunit.FieldAssignedAt)
	}
	if m.assigned_by != nil {
		fields = append(fields, userorgunit.FieldAssignedBy)
	}
	if m.is_primary != nil {
		fields = append(fields, userorgunit.FieldIsPrimary)
	}
	if m.status != nil {
		fields = append(fields, userorgunit.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserOrgUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userorgunit.FieldCreatedAt:
		return m.CreatedAt()
	case userorgunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case userorgunit.FieldDeletedAt:
		return m.DeletedAt()
	case userorgunit.FieldCreatedBy:
		return m.CreatedBy()
	case userorgunit.FieldUpdatedBy:
		return m.UpdatedBy()
	case userorgunit.FieldDeletedBy:
		return m.DeletedBy()
	case userorgunit.FieldTenantID:
		return m.TenantID()
	case userorgunit.FieldRemark:
		return m.Remark()
	case userorgunit.FieldUserID:
		return m.UserID()
	case userorgunit.FieldOrgUnitID:
		return m.OrgUnitID()
	case userorgunit.FieldPositionID:
		return m.PositionID()
	case userorgunit.FieldStartAt:
		return m.StartAt()
	case userorgunit.FieldEndAt:
		return m.EndAt()
	case userorgunit.FieldAssignedAt:
		return m.AssignedAt()
	case userorgunit.FieldAssignedBy:
		return m.AssignedBy()
	case userorgunit.FieldIsPrimary:
		return m.IsPrimary()
	case userorgunit.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserOrgUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userorgunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userorgunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userorgunit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userorgunit.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userorgunit.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userorgunit.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userorgunit.FieldTenantID:
		return m.OldTenantID(ctx)
	case userorgunit.FieldRemark:
		return m.OldRemark(ctx)
	case userorgunit.FieldUserID:
		return m.OldUserID(ctx)
	case userorgunit.FieldOrgUnitID:
		return m.OldOrgUnitID(ctx)
	case userorgunit.FieldPositionID:
		return m.OldPositionID(ctx)
	case userorgunit.FieldStartAt:
		return m.OldStartAt(ctx)
	case userorgunit.FieldEndAt:
		return m.OldEndAt(ctx)
	case userorgunit.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case userorgunit.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case userorgunit.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case userorgunit.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserOrgUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserOrgUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userorgunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userorgunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userorgunit.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userorgunit.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userorgunit.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userorgunit.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userorgunit.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case userorgunit.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case userorgunit.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userorgunit.FieldOrgUnitID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitID(v)
		return nil
	case userorgunit.FieldPositionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case userorgunit.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case userorgunit.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case userorgunit.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case userorgunit.FieldAssignedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case userorgunit.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case userorgunit.FieldStatus:
		v, ok := value.(userorgunit.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserOrgUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserOrgUnitMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userorgunit.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userorgunit.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userorgunit.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, userorgunit.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, userorgunit.FieldUserID)
	}
	if m.addorg_unit_id != nil {
		fields = append(fields, userorgunit.FieldOrgUnitID)
	}
	if m.addposition_id != nil {
		fields = append(fields, userorgunit.FieldPositionID)
	}
	if m.addassigned_by != nil {
		fields = append(fields, userorgunit.FieldAssignedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserOrgUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userorgunit.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userorgunit.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userorgunit.FieldDeletedBy:
		return m.AddedDeletedBy()
	case userorgunit.FieldTenantID:
		return m.AddedTenantID()
	case userorgunit.FieldUserID:
		return m.AddedUserID()
	case userorgunit.FieldOrgUnitID:
		return m.AddedOrgUnitID()
	case userorgunit.FieldPositionID:
		return m.AddedPositionID()
	case userorgunit.FieldAssignedBy:
		return m.AddedAssignedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserOrgUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userorgunit.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userorgunit.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userorgunit.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case userorgunit.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case userorgunit.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userorgunit.FieldOrgUnitID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgUnitID(v)
		return nil
	case userorgunit.FieldPositionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionID(v)
		return nil
	case userorgunit.FieldAssignedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserOrgUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserOrgUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userorgunit.FieldCreatedAt) {
		fields = append(fields, userorgunit.FieldCreatedAt)
	}
	if m.FieldCleared(userorgunit.FieldUpdatedAt) {
		fields = append(fields, userorgunit.FieldUpdatedAt)
	}
	if m.FieldCleared(userorgunit.FieldDeletedAt) {
		fields = append(fields, userorgunit.FieldDeletedAt)
	}
	if m.FieldCleared(userorgunit.FieldCreatedBy) {
		fields = append(fields, userorgunit.FieldCreatedBy)
	}
	if m.FieldCleared(userorgunit.FieldUpdatedBy) {
		fields = append(fields, userorgunit.FieldUpdatedBy)
	}
	if m.FieldCleared(userorgunit.FieldDeletedBy) {
		fields = append(fields, userorgunit.FieldDeletedBy)
	}
	if m.FieldCleared(userorgunit.FieldTenantID) {
		fields = append(fields, userorgunit.FieldTenantID)
	}
	if m.FieldCleared(userorgunit.FieldRemark) {
		fields = append(fields, userorgunit.FieldRemark)
	}
	if m.FieldCleared(userorgunit.FieldPositionID) {
		fields = append(fields, userorgunit.FieldPositionID)
	}
	if m.FieldCleared(userorgunit.FieldStartAt) {
		fields = append(fields, userorgunit.FieldStartAt)
	}
	if m.FieldCleared(userorgunit.FieldEndAt) {
		fields = append(fields, userorgunit.FieldEndAt)
	}
	if m.FieldCleared(userorgunit.FieldAssignedAt) {
		fields = append(fields, userorgunit.FieldAssignedAt)
	}
	if m.FieldCleared(userorgunit.FieldAssignedBy) {
		fields = append(fields, userorgunit.FieldAssignedBy)
	}
	if m.FieldCleared(userorgunit.FieldStatus) {
		fields = append(fields, userorgunit.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserOrgUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserOrgUnitMutation) ClearField(name string) error {
	switch name {
	case userorgunit.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userorgunit.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userorgunit.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userorgunit.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case userorgunit.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userorgunit.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case userorgunit.FieldTenantID:
		m.ClearTenantID()
		return nil
	case userorgunit.FieldRemark:
		m.ClearRemark()
		return nil
	case userorgunit.FieldPositionID:
		m.ClearPositionID()
		return nil
	case userorgunit.FieldStartAt:
		m.ClearStartAt()
		return nil
	case userorgunit.FieldEndAt:
		m.ClearEndAt()
		return nil
	case userorgunit.FieldAssignedAt:
		m.ClearAssignedAt()
		return nil
	case userorgunit.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case userorgunit.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown UserOrgUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserOrgUnitMutation) ResetField(name string) error {
	switch name {
	case userorgunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userorgunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userorgunit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userorgunit.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userorgunit.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userorgunit.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userorgunit.FieldTenantID:
		m.ResetTenantID()
		return nil
	case userorgunit.FieldRemark:
		m.ResetRemark()
		return nil
	case userorgunit.FieldUserID:
		m.ResetUserID()
		return nil
	case userorgunit.FieldOrgUnitID:
		m.ResetOrgUnitID()
		return nil
	case userorgunit.FieldPositionID:
		m.ResetPositionID()
		return nil
	case userorgunit.FieldStartAt:
		m.ResetStartAt()
		return nil
	case userorgunit.FieldEndAt:
		m.ResetEndAt()
		return nil
	case userorgunit.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case userorgunit.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case userorgunit.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case userorgunit.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserOrgUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserOrgUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserOrgUnitMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserOrgUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserOrgUnitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserOrgUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserOrgUnitMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserOrgUnitMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserOrgUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserOrgUnitMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserOrgUnit edge %s", name)
}

// UserPositionMutation represents an operation that mutates the UserPosition nodes in the graph.
type UserPositionMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	created_by     *uint32
	addcreated_by  *int32
	updated_by     *uint32
	addupdated_by  *int32
	deleted_by     *uint32
	adddeleted_by  *int32
	tenant_id      *uint32
	addtenant_id   *int32
	remark         *string
	user_id        *uint32
	adduser_id     *int32
	position_id    *uint32
	addposition_id *int32
	is_primary     *bool
	start_at       *time.Time
	end_at         *time.Time
	assigned_at    *time.Time
	assigned_by    *uint32
	addassigned_by *int32
	status         *userposition.Status
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UserPosition, error)
	predicates     []predicate.UserPosition
}

var _ ent.Mutation = (*UserPositionMutation)(nil)

// userpositionOption allows management of the mutation configuration using functional options.
type userpositionOption func(*UserPositionMutation)

// newUserPositionMutation creates new mutation for the UserPosition entity.
func newUserPositionMutation(c config, op Op, opts ...userpositionOption) *UserPositionMutation {
	m := &UserPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPositionID sets the ID field of the mutation.
func withUserPositionID(id uint32) userpositionOption {
	return func(m *UserPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPosition
		)
		m.oldValue = func(ctx context.Context) (*UserPosition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPosition sets the old UserPosition of the mutation.
func withUserPosition(node *UserPosition) userpositionOption {
	return func(m *UserPositionMutation) {
		m.oldValue = func(context.Context) (*UserPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPosition entities.
func (m *UserPositionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPositionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPositionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPosition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserPositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserPositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserPositionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userposition.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserPositionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userposition.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserPositionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userposition.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserPositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserPositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserPositionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userposition.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserPositionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userposition.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserPositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userposition.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserPositionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserPositionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserPositionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userposition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserPositionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userposition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserPositionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userposition.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserPositionMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserPositionMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *UserPositionMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserPositionMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserPositionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[userposition.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserPositionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[userposition.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserPositionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, userposition.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserPositionMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserPositionMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *UserPositionMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserPositionMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserPositionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userposition.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserPositionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userposition.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserPositionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userposition.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserPositionMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserPositionMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *UserPositionMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserPositionMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserPositionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[userposition.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserPositionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[userposition.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserPositionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, userposition.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserPositionMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserPositionMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *UserPositionMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserPositionMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UserPositionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[userposition.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UserPositionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[userposition.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserPositionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, userposition.FieldTenantID)
}

// SetRemark sets the "remark" field.
func (m *UserPositionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *UserPositionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *UserPositionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[userposition.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *UserPositionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[userposition.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *UserPositionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, userposition.FieldRemark)
}

// SetUserID sets the "user_id" field.
func (m *UserPositionMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPositionMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserPositionMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserPositionMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPositionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPositionID sets the "position_id" field.
func (m *UserPositionMutation) SetPositionID(u uint32) {
	m.position_id = &u
	m.addposition_id = nil
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *UserPositionMutation) PositionID() (r uint32, exists bool) {
	v := m.position_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldPositionID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// AddPositionID adds u to the "position_id" field.
func (m *UserPositionMutation) AddPositionID(u int32) {
	if m.addposition_id != nil {
		*m.addposition_id += u
	} else {
		m.addposition_id = &u
	}
}

// AddedPositionID returns the value that was added to the "position_id" field in this mutation.
func (m *UserPositionMutation) AddedPositionID() (r int32, exists bool) {
	v := m.addposition_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *UserPositionMutation) ResetPositionID() {
	m.position_id = nil
	m.addposition_id = nil
}

// SetIsPrimary sets the "is_primary" field.
func (m *UserPositionMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *UserPositionMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ClearIsPrimary clears the value of the "is_primary" field.
func (m *UserPositionMutation) ClearIsPrimary() {
	m.is_primary = nil
	m.clearedFields[userposition.FieldIsPrimary] = struct{}{}
}

// IsPrimaryCleared returns if the "is_primary" field was cleared in this mutation.
func (m *UserPositionMutation) IsPrimaryCleared() bool {
	_, ok := m.clearedFields[userposition.FieldIsPrimary]
	return ok
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *UserPositionMutation) ResetIsPrimary() {
	m.is_primary = nil
	delete(m.clearedFields, userposition.FieldIsPrimary)
}

// SetStartAt sets the "start_at" field.
func (m *UserPositionMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *UserPositionMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *UserPositionMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[userposition.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *UserPositionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[userposition.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *UserPositionMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, userposition.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *UserPositionMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *UserPositionMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *UserPositionMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[userposition.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *UserPositionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[userposition.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *UserPositionMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, userposition.FieldEndAt)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserPositionMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserPositionMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ClearAssignedAt clears the value of the "assigned_at" field.
func (m *UserPositionMutation) ClearAssignedAt() {
	m.assigned_at = nil
	m.clearedFields[userposition.FieldAssignedAt] = struct{}{}
}

// AssignedAtCleared returns if the "assigned_at" field was cleared in this mutation.
func (m *UserPositionMutation) AssignedAtCleared() bool {
	_, ok := m.clearedFields[userposition.FieldAssignedAt]
	return ok
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserPositionMutation) ResetAssignedAt() {
	m.assigned_at = nil
	delete(m.clearedFields, userposition.FieldAssignedAt)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserPositionMutation) SetAssignedBy(u uint32) {
	m.assigned_by = &u
	m.addassigned_by = nil
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserPositionMutation) AssignedBy() (r uint32, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldAssignedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// AddAssignedBy adds u to the "assigned_by" field.
func (m *UserPositionMutation) AddAssignedBy(u int32) {
	if m.addassigned_by != nil {
		*m.addassigned_by += u
	} else {
		m.addassigned_by = &u
	}
}

// AddedAssignedBy returns the value that was added to the "assigned_by" field in this mutation.
func (m *UserPositionMutation) AddedAssignedBy() (r int32, exists bool) {
	v := m.addassigned_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserPositionMutation) ClearAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	m.clearedFields[userposition.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserPositionMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[userposition.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserPositionMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	delete(m.clearedFields, userposition.FieldAssignedBy)
}

// SetStatus sets the "status" field.
func (m *UserPositionMutation) SetStatus(u userposition.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserPositionMutation) Status() (r userposition.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserPosition entity.
// If the UserPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPositionMutation) OldStatus(ctx context.Context) (v userposition.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserPositionMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the UserPositionMutation builder.
func (m *UserPositionMutation) Where(ps ...predicate.UserPosition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPosition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPosition).
func (m *UserPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPositionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, userposition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userposition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userposition.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userposition.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userposition.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, userposition.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, userposition.FieldTenantID)
	}
	if m.remark != nil {
		fields = append(fields, userposition.FieldRemark)
	}
	if m.user_id != nil {
		fields = append(fields, userposition.FieldUserID)
	}
	if m.position_id != nil {
		fields = append(fields, userposition.FieldPositionID)
	}
	if m.is_primary != nil {
		fields = append(fields, userposition.FieldIsPrimary)
	}
	if m.start_at != nil {
		fields = append(fields, userposition.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, userposition.FieldEndAt)
	}
	if m.assigned_at != nil {
		fields = append(fields, userposition.FieldAssignedAt)
	}
	if m.assigned_by != nil {
		fields = append(fields, userposition.FieldAssignedBy)
	}
	if m.status != nil {
		fields = append(fields, userposition.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userposition.FieldCreatedAt:
		return m.CreatedAt()
	case userposition.FieldUpdatedAt:
		return m.UpdatedAt()
	case userposition.FieldDeletedAt:
		return m.DeletedAt()
	case userposition.FieldCreatedBy:
		return m.CreatedBy()
	case userposition.FieldUpdatedBy:
		return m.UpdatedBy()
	case userposition.FieldDeletedBy:
		return m.DeletedBy()
	case userposition.FieldTenantID:
		return m.TenantID()
	case userposition.FieldRemark:
		return m.Remark()
	case userposition.FieldUserID:
		return m.UserID()
	case userposition.FieldPositionID:
		return m.PositionID()
	case userposition.FieldIsPrimary:
		return m.IsPrimary()
	case userposition.FieldStartAt:
		return m.StartAt()
	case userposition.FieldEndAt:
		return m.EndAt()
	case userposition.FieldAssignedAt:
		return m.AssignedAt()
	case userposition.FieldAssignedBy:
		return m.AssignedBy()
	case userposition.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userposition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userposition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userposition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userposition.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userposition.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userposition.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userposition.FieldTenantID:
		return m.OldTenantID(ctx)
	case userposition.FieldRemark:
		return m.OldRemark(ctx)
	case userposition.FieldUserID:
		return m.OldUserID(ctx)
	case userposition.FieldPositionID:
		return m.OldPositionID(ctx)
	case userposition.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case userposition.FieldStartAt:
		return m.OldStartAt(ctx)
	case userposition.FieldEndAt:
		return m.OldEndAt(ctx)
	case userposition.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case userposition.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case userposition.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserPosition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userposition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userposition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userposition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userposition.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userposition.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userposition.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userposition.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case userposition.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case userposition.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userposition.FieldPositionID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case userposition.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case userposition.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case userposition.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case userposition.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case userposition.FieldAssignedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case userposition.FieldStatus:
		v, ok := value.(userposition.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPositionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userposition.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userposition.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userposition.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, userposition.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, userposition.FieldUserID)
	}
	if m.addposition_id != nil {
		fields = append(fields, userposition.FieldPositionID)
	}
	if m.addassigned_by != nil {
		fields = append(fields, userposition.FieldAssignedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userposition.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userposition.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userposition.FieldDeletedBy:
		return m.AddedDeletedBy()
	case userposition.FieldTenantID:
		return m.AddedTenantID()
	case userposition.FieldUserID:
		return m.AddedUserID()
	case userposition.FieldPositionID:
		return m.AddedPositionID()
	case userposition.FieldAssignedBy:
		return m.AddedAssignedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userposition.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userposition.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userposition.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case userposition.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case userposition.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userposition.FieldPositionID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionID(v)
		return nil
	case userposition.FieldAssignedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userposition.FieldCreatedAt) {
		fields = append(fields, userposition.FieldCreatedAt)
	}
	if m.FieldCleared(userposition.FieldUpdatedAt) {
		fields = append(fields, userposition.FieldUpdatedAt)
	}
	if m.FieldCleared(userposition.FieldDeletedAt) {
		fields = append(fields, userposition.FieldDeletedAt)
	}
	if m.FieldCleared(userposition.FieldCreatedBy) {
		fields = append(fields, userposition.FieldCreatedBy)
	}
	if m.FieldCleared(userposition.FieldUpdatedBy) {
		fields = append(fields, userposition.FieldUpdatedBy)
	}
	if m.FieldCleared(userposition.FieldDeletedBy) {
		fields = append(fields, userposition.FieldDeletedBy)
	}
	if m.FieldCleared(userposition.FieldTenantID) {
		fields = append(fields, userposition.FieldTenantID)
	}
	if m.FieldCleared(userposition.FieldRemark) {
		fields = append(fields, userposition.FieldRemark)
	}
	if m.FieldCleared(userposition.FieldIsPrimary) {
		fields = append(fields, userposition.FieldIsPrimary)
	}
	if m.FieldCleared(userposition.FieldStartAt) {
		fields = append(fields, userposition.FieldStartAt)
	}
	if m.FieldCleared(userposition.FieldEndAt) {
		fields = append(fields, userposition.FieldEndAt)
	}
	if m.FieldCleared(userposition.FieldAssignedAt) {
		fields = append(fields, userposition.FieldAssignedAt)
	}
	if m.FieldCleared(userposition.FieldAssignedBy) {
		fields = append(fields, userposition.FieldAssignedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPositionMutation) ClearField(name string) error {
	switch name {
	case userposition.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userposition.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userposition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userposition.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case userposition.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userposition.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case userposition.FieldTenantID:
		m.ClearTenantID()
		return nil
	case userposition.FieldRemark:
		m.ClearRemark()
		return nil
	case userposition.FieldIsPrimary:
		m.ClearIsPrimary()
		return nil
	case userposition.FieldStartAt:
		m.ClearStartAt()
		return nil
	case userposition.FieldEndAt:
		m.ClearEndAt()
		return nil
	case userposition.FieldAssignedAt:
		m.ClearAssignedAt()
		return nil
	case userposition.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	}
	return fmt.Errorf("unknown UserPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPositionMutation) ResetField(name string) error {
	switch name {
	case userposition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userposition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userposition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userposition.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userposition.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userposition.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userposition.FieldTenantID:
		m.ResetTenantID()
		return nil
	case userposition.FieldRemark:
		m.ResetRemark()
		return nil
	case userposition.FieldUserID:
		m.ResetUserID()
		return nil
	case userposition.FieldPositionID:
		m.ResetPositionID()
		return nil
	case userposition.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case userposition.FieldStartAt:
		m.ResetStartAt()
		return nil
	case userposition.FieldEndAt:
		m.ResetEndAt()
		return nil
	case userposition.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case userposition.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case userposition.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPositionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPositionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPositionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserPosition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPositionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserPosition edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	created_by     *uint32
	addcreated_by  *int32
	updated_by     *uint32
	addupdated_by  *int32
	deleted_by     *uint32
	adddeleted_by  *int32
	tenant_id      *uint32
	addtenant_id   *int32
	user_id        *uint32
	adduser_id     *int32
	role_id        *uint32
	addrole_id     *int32
	start_at       *time.Time
	end_at         *time.Time
	assigned_at    *time.Time
	assigned_by    *uint32
	addassigned_by *int32
	is_primary     *bool
	status         *userrole.Status
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UserRole, error)
	predicates     []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id uint32) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRole entities.
func (m *UserRoleMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserRoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userrole.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserRoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userrole.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userrole.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userrole.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserRoleMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserRoleMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *UserRoleMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserRoleMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserRoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[userrole.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[userrole.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, userrole.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserRoleMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserRoleMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *UserRoleMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserRoleMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userrole.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserRoleMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserRoleMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldDeletedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *UserRoleMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserRoleMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserRoleMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[userrole.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserRoleMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[userrole.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserRoleMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, userrole.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserRoleMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserRoleMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *UserRoleMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserRoleMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UserRoleMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[userrole.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UserRoleMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[userrole.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserRoleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, userrole.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserRoleMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserRoleMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(u uint32) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r uint32, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *UserRoleMutation) AddRoleID(u int32) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *UserRoleMutation) AddedRoleID() (r int32, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetStartAt sets the "start_at" field.
func (m *UserRoleMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *UserRoleMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *UserRoleMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[userrole.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *UserRoleMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *UserRoleMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, userrole.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *UserRoleMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *UserRoleMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *UserRoleMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[userrole.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *UserRoleMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *UserRoleMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, userrole.FieldEndAt)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserRoleMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserRoleMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ClearAssignedAt clears the value of the "assigned_at" field.
func (m *UserRoleMutation) ClearAssignedAt() {
	m.assigned_at = nil
	m.clearedFields[userrole.FieldAssignedAt] = struct{}{}
}

// AssignedAtCleared returns if the "assigned_at" field was cleared in this mutation.
func (m *UserRoleMutation) AssignedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldAssignedAt]
	return ok
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserRoleMutation) ResetAssignedAt() {
	m.assigned_at = nil
	delete(m.clearedFields, userrole.FieldAssignedAt)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserRoleMutation) SetAssignedBy(u uint32) {
	m.assigned_by = &u
	m.addassigned_by = nil
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserRoleMutation) AssignedBy() (r uint32, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldAssignedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// AddAssignedBy adds u to the "assigned_by" field.
func (m *UserRoleMutation) AddAssignedBy(u int32) {
	if m.addassigned_by != nil {
		*m.addassigned_by += u
	} else {
		m.addassigned_by = &u
	}
}

// AddedAssignedBy returns the value that was added to the "assigned_by" field in this mutation.
func (m *UserRoleMutation) AddedAssignedBy() (r int32, exists bool) {
	v := m.addassigned_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserRoleMutation) ClearAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	m.clearedFields[userrole.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserRoleMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[userrole.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserRoleMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.addassigned_by = nil
	delete(m.clearedFields, userrole.FieldAssignedBy)
}

// SetIsPrimary sets the "is_primary" field.
func (m *UserRoleMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *UserRoleMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldIsPrimary(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *UserRoleMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetStatus sets the "status" field.
func (m *UserRoleMutation) SetStatus(u userrole.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserRoleMutation) Status() (r userrole.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldStatus(ctx context.Context) (v userrole.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserRoleMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userrole.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userrole.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, userrole.FieldDeletedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, userrole.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role_id != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.start_at != nil {
		fields = append(fields, userrole.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, userrole.FieldEndAt)
	}
	if m.assigned_at != nil {
		fields = append(fields, userrole.FieldAssignedAt)
	}
	if m.assigned_by != nil {
		fields = append(fields, userrole.FieldAssignedBy)
	}
	if m.is_primary != nil {
		fields = append(fields, userrole.FieldIsPrimary)
	}
	if m.status != nil {
		fields = append(fields, userrole.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case userrole.FieldDeletedAt:
		return m.DeletedAt()
	case userrole.FieldCreatedBy:
		return m.CreatedBy()
	case userrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case userrole.FieldDeletedBy:
		return m.DeletedBy()
	case userrole.FieldTenantID:
		return m.TenantID()
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	case userrole.FieldStartAt:
		return m.StartAt()
	case userrole.FieldEndAt:
		return m.EndAt()
	case userrole.FieldAssignedAt:
		return m.AssignedAt()
	case userrole.FieldAssignedBy:
		return m.AssignedBy()
	case userrole.FieldIsPrimary:
		return m.IsPrimary()
	case userrole.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userrole.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userrole.FieldTenantID:
		return m.OldTenantID(ctx)
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrole.FieldStartAt:
		return m.OldStartAt(ctx)
	case userrole.FieldEndAt:
		return m.OldEndAt(ctx)
	case userrole.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case userrole.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case userrole.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case userrole.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userrole.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userrole.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userrole.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userrole.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case userrole.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrole.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case userrole.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case userrole.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case userrole.FieldAssignedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case userrole.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case userrole.FieldStatus:
		v, ok := value.(userrole.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userrole.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userrole.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, userrole.FieldDeletedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, userrole.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.addrole_id != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.addassigned_by != nil {
		fields = append(fields, userrole.FieldAssignedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userrole.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case userrole.FieldDeletedBy:
		return m.AddedDeletedBy()
	case userrole.FieldTenantID:
		return m.AddedTenantID()
	case userrole.FieldUserID:
		return m.AddedUserID()
	case userrole.FieldRoleID:
		return m.AddedRoleID()
	case userrole.FieldAssignedBy:
		return m.AddedAssignedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userrole.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case userrole.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case userrole.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case userrole.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case userrole.FieldAssignedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldCreatedAt) {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.FieldCleared(userrole.FieldUpdatedAt) {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.FieldCleared(userrole.FieldDeletedAt) {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.FieldCleared(userrole.FieldCreatedBy) {
		fields = append(fields, userrole.FieldCreatedBy)
	}
	if m.FieldCleared(userrole.FieldUpdatedBy) {
		fields = append(fields, userrole.FieldUpdatedBy)
	}
	if m.FieldCleared(userrole.FieldDeletedBy) {
		fields = append(fields, userrole.FieldDeletedBy)
	}
	if m.FieldCleared(userrole.FieldTenantID) {
		fields = append(fields, userrole.FieldTenantID)
	}
	if m.FieldCleared(userrole.FieldStartAt) {
		fields = append(fields, userrole.FieldStartAt)
	}
	if m.FieldCleared(userrole.FieldEndAt) {
		fields = append(fields, userrole.FieldEndAt)
	}
	if m.FieldCleared(userrole.FieldAssignedAt) {
		fields = append(fields, userrole.FieldAssignedAt)
	}
	if m.FieldCleared(userrole.FieldAssignedBy) {
		fields = append(fields, userrole.FieldAssignedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userrole.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case userrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userrole.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case userrole.FieldTenantID:
		m.ClearTenantID()
		return nil
	case userrole.FieldStartAt:
		m.ClearStartAt()
		return nil
	case userrole.FieldEndAt:
		m.ClearEndAt()
		return nil
	case userrole.FieldAssignedAt:
		m.ClearAssignedAt()
		return nil
	case userrole.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userrole.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userrole.FieldTenantID:
		m.ResetTenantID()
		return nil
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrole.FieldStartAt:
		m.ResetStartAt()
		return nil
	case userrole.FieldEndAt:
		m.ResetEndAt()
		return nil
	case userrole.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case userrole.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case userrole.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case userrole.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserRole edge %s", name)
}
